From d11b474e53f02a4f99c4a6100dfe17fb38d90003 Mon Sep 17 00:00:00 2001
From: Sergey Lavrentiev <s.lavrentiev@samsung.com>
Date: Fri, 12 May 2023 21:00:34 +0300
Subject: [PATCH 110/225] [refactor] Rename 'axdimm' device into 'sls'

- apply renaming for driver/pnm/axdimm_resource
- apply renaming for /driver/dax/axdimm_*
- extract sls related entries from 'libaxdimm.h' to
  'sls_resources.h'

Resolves: MCS23-925

Signed-off-by: Sergey Lavrentiev <s.lavrentiev@samsung.com>
---
 MAINTAINERS                                   |   5 +-
 PNM_HOW_TO_BUILD.md                           |  16 +-
 config-pnm                                    |   4 +-
 drivers/dax/Kconfig                           |  45 +--
 drivers/dax/Makefile                          |   2 +-
 drivers/dax/axdimm_dax.h                      |  26 --
 drivers/dax/bus.c                             |   4 +-
 drivers/dax/dax-private.h                     |   4 +-
 drivers/dax/device.c                          |  38 +--
 drivers/dax/{axdimm_dax.c => sls_dax.c}       |  60 ++--
 drivers/dax/sls_dax.h                         |  26 ++
 drivers/pnm/Kconfig                           |  20 +-
 drivers/pnm/Makefile                          |   2 +-
 drivers/pnm/axdimm_resource/Makefile          |   9 -
 drivers/pnm/axdimm_resource/axdimm.c          | 248 ---------------
 drivers/pnm/axdimm_resource/axdimm.h          |  10 -
 drivers/pnm/axdimm_resource/axdimm_log.h      |  19 --
 drivers/pnm/axdimm_resource/axdimm_private.h  |  62 ----
 drivers/pnm/axdimm_resource/axdimm_sysfs.h    |  16 -
 drivers/pnm/sls_resource/Makefile             |   9 +
 .../resource.c                                |   8 +-
 drivers/pnm/sls_resource/sls.c                | 248 +++++++++++++++
 drivers/pnm/sls_resource/sls.h                |  10 +
 .../sls_allocator.c}                          | 284 +++++++++---------
 .../sls_allocator.h}                          |  32 +-
 drivers/pnm/sls_resource/sls_log.h            |  19 ++
 drivers/pnm/sls_resource/sls_private.h        |  62 ++++
 .../sls_process_manager.c}                    | 140 ++++-----
 .../sls_process_manager.h}                    |  50 +--
 .../sls_rank_scheduler.c}                     |  90 +++---
 .../sls_rank_scheduler.h}                     |  24 +-
 .../sls_sysfs.c}                              | 114 +++----
 drivers/pnm/sls_resource/sls_sysfs.h          |  16 +
 include/linux/axdimm_common.h                 |  44 ---
 include/linux/axdimm_set_mem_info.h           |  52 ++--
 include/linux/sls_common.h                    |  45 +++
 include/uapi/linux/libaxdimm.h                | 172 +----------
 include/uapi/linux/sls_resources.h            | 195 ++++++++++++
 install_axdimm_resource.sh                    |  13 -
 install_dax_drivers.sh                        |   2 +-
 ...xdimm_headers.sh => install_sls_headers.sh |   4 +
 install_sls_resource.sh                       |  13 +
 42 files changed, 1148 insertions(+), 1114 deletions(-)
 delete mode 100644 drivers/dax/axdimm_dax.h
 rename drivers/dax/{axdimm_dax.c => sls_dax.c} (64%)
 create mode 100644 drivers/dax/sls_dax.h
 delete mode 100644 drivers/pnm/axdimm_resource/Makefile
 delete mode 100644 drivers/pnm/axdimm_resource/axdimm.c
 delete mode 100644 drivers/pnm/axdimm_resource/axdimm.h
 delete mode 100644 drivers/pnm/axdimm_resource/axdimm_log.h
 delete mode 100644 drivers/pnm/axdimm_resource/axdimm_private.h
 delete mode 100644 drivers/pnm/axdimm_resource/axdimm_sysfs.h
 create mode 100644 drivers/pnm/sls_resource/Makefile
 rename drivers/pnm/{axdimm_resource => sls_resource}/resource.c (68%)
 create mode 100644 drivers/pnm/sls_resource/sls.c
 create mode 100644 drivers/pnm/sls_resource/sls.h
 rename drivers/pnm/{axdimm_resource/axdimm_allocator.c => sls_resource/sls_allocator.c} (68%)
 rename drivers/pnm/{axdimm_resource/axdimm_allocator.h => sls_resource/sls_allocator.h} (69%)
 create mode 100644 drivers/pnm/sls_resource/sls_log.h
 create mode 100644 drivers/pnm/sls_resource/sls_private.h
 rename drivers/pnm/{axdimm_resource/axdimm_process_manager.c => sls_resource/sls_process_manager.c} (71%)
 rename drivers/pnm/{axdimm_resource/axdimm_process_manager.h => sls_resource/sls_process_manager.h} (55%)
 rename drivers/pnm/{axdimm_resource/axdimm_rank_scheduler.c => sls_resource/sls_rank_scheduler.c} (65%)
 rename drivers/pnm/{axdimm_resource/axdimm_rank_scheduler.h => sls_resource/sls_rank_scheduler.h} (60%)
 rename drivers/pnm/{axdimm_resource/axdimm_sysfs.c => sls_resource/sls_sysfs.c} (78%)
 create mode 100644 drivers/pnm/sls_resource/sls_sysfs.h
 delete mode 100644 include/linux/axdimm_common.h
 create mode 100644 include/linux/sls_common.h
 create mode 100644 include/uapi/linux/sls_resources.h
 delete mode 100755 install_axdimm_resource.sh
 rename install_axdimm_headers.sh => install_sls_headers.sh (60%)
 create mode 100755 install_sls_resource.sh

diff --git a/MAINTAINERS b/MAINTAINERS
index 90ad5d1ce..0609adaaa 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -5239,8 +5239,9 @@ F:	config-pnm
 F:	drivers/pnm/
 F:	include/uapi/linux/dba_resources.h
 F:	include/uapi/linux/libaxdimm.h
-F:	install_axdimm_headers.sh
-F:	install_axdimm_resource.sh
+F:	include/uapi/linux/sls_resources.h
+F:	install_sls_headers.sh
+F:	install_sls_resource.sh
 F:	install_dax_drivers.sh
 F:	install_dba_resource.sh
 F:	install_debs.sh
diff --git a/PNM_HOW_TO_BUILD.md b/PNM_HOW_TO_BUILD.md
index edd124496..ed84b5ea5 100644
--- a/PNM_HOW_TO_BUILD.md
+++ b/PNM_HOW_TO_BUILD.md
@@ -15,8 +15,8 @@ DAX: direct access to differentiated memory (DAX) [Y/?] y
     PMEM DAX: direct access to persistent memory (DEV_DAX_PMEM) [M/n/?] m
   HMEM DAX: direct access to 'specific purpose' memory (DEV_DAX_HMEM) [M/n/y/?] m
   KMEM DAX: volatile-use of persistent memory (DEV_DAX_KMEM) [M/n/?] m
-    A base physical address of AXDIMM range in gigabytes (AXDIMM_BASE_ADDR) [4] (NEW) 4 -> choose your offset here (4 for simulation, 66 for FPGA).
-    A scale of AXDIMM memory range (AXDIMM_MEMORY_SCALE) [1] (NEW) 1 -> choose your scale here (2 for simulation 16GB range, 1 for simulation 32GB range, 0 for FPGA)
+    A base physical address of SLS range in gigabytes (SLS_BASE_ADDR) [4] (NEW) 4 -> choose your offset here (4 for simulation, 66 for FPGA).
+    A scale of SLS memory range (SLS_MEMORY_SCALE) [2] (NEW) 2 -> choose your scale here (2 for simulation 16GB range, 1 for simulation 32GB range, 0 for FPGA)
 *
 * DBA Resource Manager
 *
@@ -41,15 +41,15 @@ Built drivers can then be installed with `install_dax_drivers` script:
 $ ./install_dax_drivers.sh
 ```
 
-# AXDIMM resource driver only
+# SLS resource driver only
 
 ```bash
-$ make M=drivers/pnm/axdimm_resource/ -j32
+$ make M=drivers/pnm/sls_resource/ -j32
 ```
 
-Built drivers can then be installed with `install_axdimm_resource` script:
+Built drivers can then be installed with `install_sls_resource` script:
 ```bash
-$ ./install_axdimm_resource.sh
+$ ./install_sls_resource.sh
 ```
 
 # DBA resource driver only
@@ -63,7 +63,7 @@ Built drivers can then be installed with `install_dba_resource` script:
 $ ./install_dba_resource.sh
 ```
 
-# Install AXDIMM headers only
+# Install SLS headers only
 ```bash
-$ ./install_axdimm_headers.sh
+$ ./install_sls_headers.sh
 ```
diff --git a/config-pnm b/config-pnm
index 435081f3f..8f42c12b4 100644
--- a/config-pnm
+++ b/config-pnm
@@ -10011,8 +10011,8 @@ CONFIG_DEV_DAX_PMEM=m
 CONFIG_DEV_DAX_HMEM=m
 CONFIG_DEV_DAX_HMEM_DEVICES=y
 CONFIG_DEV_DAX_KMEM=m
-CONFIG_AXDIMM=y
-CONFIG_AXDIMM_RESOURCE=m
+CONFIG_DEV_SLS=y
+CONFIG_SLS_RESOURCE=m
 CONFIG_DBA=y
 CONFIG_DBA_RESOURCE=m
 CONFIG_NVMEM=y
diff --git a/drivers/dax/Kconfig b/drivers/dax/Kconfig
index 63891fd9c..26dfbe07d 100644
--- a/drivers/dax/Kconfig
+++ b/drivers/dax/Kconfig
@@ -49,6 +49,18 @@ config DEV_DAX_HMEM_DEVICES
 	depends on DEV_DAX_HMEM && DAX=y
 	def_bool y
 
+config DEV_SLS
+	bool "DEV_SLS support"
+	depends on DEV_DAX || DEV_DAX=m
+	default n
+	help
+	  Enable support for SLS accelerator
+
+	  SLS device is a PNM accelerator, which accelerates
+	  Sparse Length Sum operation on embedding tables preallocated
+	  in memory. This option will enable the allocation of a DAX region
+	  for use by this device.
+
 config DEV_DAX_KMEM
 	tristate "KMEM DAX: volatile-use of persistent memory"
 	default DEV_DAX
@@ -66,39 +78,28 @@ config DEV_DAX_KMEM
 
 	  Say N if unsure.
 
-config AXDIMM
-	bool "AXDIMM support"
-	depends on DEV_DAX || DEV_DAX=m
-	default n
-	help
-	  Enable support for AXDIMM accelerator.
-
-	  AXDIMM accelerator is a PNM device. It is attached
-	  through the DIMM interface. This option will enable
-	  allocation of a DAX region for use by this device.
-
-if AXDIMM
+if DEV_SLS
 
-config AXDIMM_BASE_ADDR
-	int "A base address of AXDIMM range"
-	depends on AXDIMM
+config DEV_SLS_BASE_ADDR
+	int "A base address of SLS range"
+	depends on DEV_SLS
 	range 4 66
 	default 4
 	help
-	  A base physical address of AXDIMM range in gigabytes
+	  A base physical address of SLS range in gigabytes
 
-	  This value is used to detect AXDIMM range in DAX driver and
+	  This value is used to detect SLS range in DAX driver and
 	  map it accordingly.
 
-config AXDIMM_MEMORY_SCALE
-	int "A scale of AXDIMM memory range"
-	depends on AXDIMM
+config DEV_SLS_MEMORY_SCALE
+	int "A scale of SLS memory range"
+	depends on DEV_SLS
 	range 0 4
 	default 1
 	help
-	  Setup memory range size for AXDIMM
+	  Setup memory range size for SLS
 
-	  This value is used to scale the total AXDIMM memory range
+	  This value is used to scale the total SLS memory range
 	  in DAX driver.
 	  The maximum possible memory is 64 gigabytes. And the scale
 	  parameter allows to scale this down by powers of 2. The calculation
diff --git a/drivers/dax/Makefile b/drivers/dax/Makefile
index 6355c15d2..4895ea780 100644
--- a/drivers/dax/Makefile
+++ b/drivers/dax/Makefile
@@ -7,7 +7,7 @@ obj-$(CONFIG_DEV_DAX_PMEM) += dax_pmem.o
 dax-y := super.o
 dax-y += bus.o
 device_dax-y := device.o
-device_dax-$(CONFIG_AXDIMM) += axdimm_dax.o
+device_dax-$(CONFIG_DEV_SLS) += sls_dax.o
 dax_pmem-y := pmem.o
 
 obj-y += hmem/
diff --git a/drivers/dax/axdimm_dax.h b/drivers/dax/axdimm_dax.h
deleted file mode 100644
index 676215889..000000000
--- a/drivers/dax/axdimm_dax.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
-
-#ifndef __AXDIMM_DAX_H__
-#define __AXDIMM_DAX_H__
-
-/* For normal inclusion dax-private.h requires this header */
-/* Put the header here not to change origin dax-private.h */
-#include <linux/pgtable.h>
-#include "dax-private.h"
-
-#include <linux/axdimm_common.h>
-
-#include <linux/fs.h>
-#include <linux/mm_types.h>
-
-int axdimm_dax_mmap(struct file *filep, struct vm_area_struct *vma);
-int init_axdimm_dax_device(struct dev_dax *dev_dax);
-
-static inline bool is_axdimm_range(u64 start, u64 end)
-{
-	return start >= AXDIMM_BASE_ADDR &&
-	       end < AXDIMM_BASE_ADDR + AXDIMM_MEMORY_SIZE;
-}
-
-#endif /* __AXDIMM_DAX_H__ */
diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
index d07ff92b1..f6d109fc0 100644
--- a/drivers/dax/bus.c
+++ b/drivers/dax/bus.c
@@ -1374,8 +1374,8 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
 	ida_init(&dev_dax->ida);
 	kref_get(&dax_region->kref);
 
-	/* Default initialize is_axdimm_device to false */
-	dev_dax->is_axdimm_device = 0;
+	/* Default initialize is_sls_device to false */
+	dev_dax->is_sls_device = 0;
 
 	inode = dax_inode(dax_dev);
 	dev->devt = inode->i_rdev;
diff --git a/drivers/dax/dax-private.h b/drivers/dax/dax-private.h
index dfc2b1b3b..de98e3764 100644
--- a/drivers/dax/dax-private.h
+++ b/drivers/dax/dax-private.h
@@ -58,7 +58,7 @@ struct dax_mapping {
  * @pgmap - pgmap for memmap setup / lifetime (driver owned)
  * @nr_range: size of @ranges
  * @ranges: resource-span + pgoff tuples for the instance
- * @is_axdimm_device: indicates whether underlying device is AXDIMM
+ * @is_sls_device: indicates whether underlying device is SLS
  */
 struct dev_dax {
 	struct dax_region *region;
@@ -75,7 +75,7 @@ struct dev_dax {
 		struct range range;
 		struct dax_mapping *mapping;
 	} *ranges;
-	int is_axdimm_device;
+	int is_sls_device;
 };
 
 static inline struct dev_dax *to_dev_dax(struct device *dev)
diff --git a/drivers/dax/device.c b/drivers/dax/device.c
index 79d7a1d5e..08aa6ce46 100644
--- a/drivers/dax/device.c
+++ b/drivers/dax/device.c
@@ -14,8 +14,8 @@
 #include <linux/io.h>
 
 #include "dax-private.h"
-#ifdef CONFIG_AXDIMM
-#include "axdimm_dax.h"
+#ifdef CONFIG_DEV_SLS
+#include "sls_dax.h"
 #endif
 #ifdef CONFIG_DBA
 #include "dba-private.h"
@@ -316,10 +316,10 @@ static int dax_mmap(struct file *filp, struct vm_area_struct *vma)
 	vma->vm_ops = &dax_vm_ops;
 	vma->vm_flags |= VM_HUGEPAGE;
 
-#ifdef CONFIG_AXDIMM
-	/* If DAX device is AXDIMM, do not support lazy mapping. */
-	if (dev_dax->is_axdimm_device)
-		return axdimm_dax_mmap(filp, vma);
+#ifdef CONFIG_DEV_SLS
+	/* If DAX device is SLS, do not support lazy mapping. */
+	if (dev_dax->is_sls_device)
+		return sls_dax_mmap(filp, vma);
 #endif
 
 	return 0;
@@ -418,18 +418,18 @@ int dev_dax_probe(struct dev_dax *dev_dax)
 	void *addr;
 	int rc, i;
 	struct range *range = &dev_dax->ranges[0].range;
-	bool is_axdimm_device = false;
+	bool is_sls_device = false;
 
-#ifdef CONFIG_AXDIMM
+#ifdef CONFIG_DEV_SLS
 
-	/* Even though AXDIMM device has several ranges, we remap all of them at once */
-	is_axdimm_device = dev_dax->is_axdimm_device ||
-			   is_axdimm_range(range->start, range->end);
+	/* Even though SLS device has several ranges, we remap all of them at once */
+	is_sls_device = dev_dax->is_sls_device ||
+			   is_sls_range(range->start, range->end);
 
-	if (is_axdimm_device) {
-		rc = init_axdimm_dax_device(dev_dax);
+	if (is_sls_device) {
+		rc = init_sls_dax_device(dev_dax);
 		if (rc) {
-			dev_err(dev, "couldn't initialize AXDIMM DAX device, error [%d]\n", rc);
+			dev_err(dev, "couldn't initialize SLS DAX device, error [%d]\n", rc);
 			goto out_err;
 		}
 	}
@@ -438,8 +438,8 @@ int dev_dax_probe(struct dev_dax *dev_dax)
 	pgmap = dev_dax->pgmap;
 
 	if (static_dev_dax(dev_dax))  {
-		/* AXDIMM has static pgmap and multi-range device */
-		if (dev_dax->nr_range > 1 && !dev_dax->is_axdimm_device) {
+		/* SLS has static pgmap and multi-range device */
+		if (dev_dax->nr_range > 1 && !dev_dax->is_sls_device) {
 			dev_warn(dev,
 				"static pgmap / multi-range device conflict\n");
 			rc = -EINVAL;
@@ -482,8 +482,8 @@ int dev_dax_probe(struct dev_dax *dev_dax)
 
 	pgmap->type = MEMORY_DEVICE_GENERIC;
 
-#if defined(CONFIG_AXDIMM) || defined(CONFIG_DBA)
-	if (is_axdimm_device || is_dba_range(range->start, range->end))
+#if defined(CONFIG_DEV_SLS) || defined(CONFIG_DBA)
+	if (is_sls_device || is_dba_range(range->start, range->end))
 		pgmap->type = MEMORY_DEVICE_ACCELERATOR;
 #endif
 
@@ -491,7 +491,7 @@ int dev_dax_probe(struct dev_dax *dev_dax)
 		pgmap->vmemmap_shift =
 			order_base_2(dev_dax->align >> PAGE_SHIFT);
 
-	if (!is_axdimm_device) {
+	if (!is_sls_device) {
 		addr = devm_memremap_pages(dev, pgmap);
 		if (IS_ERR(addr))
 			return PTR_ERR(addr);
diff --git a/drivers/dax/axdimm_dax.c b/drivers/dax/sls_dax.c
similarity index 64%
rename from drivers/dax/axdimm_dax.c
rename to drivers/dax/sls_dax.c
index b6a0cf939..d5c1b2451 100644
--- a/drivers/dax/axdimm_dax.c
+++ b/drivers/dax/sls_dax.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 /* Copyright(c) 2023 Samsung LTD. All rights reserved. */
 
-#include "axdimm_dax.h"
+#include "sls_dax.h"
 
 #include <linux/axdimm_set_mem_info.h>
 #include <linux/pgtable.h>
@@ -9,11 +9,11 @@
 #include <linux/pagemap.h>
 #include <linux/pfn_t.h>
 
-#define LOG_PREFIX "[axdimm_dax] "
+#define LOG_PREFIX "[sls_dax] "
 
-static const struct axdmem_info *get_mem_info(void)
+static const struct sls_mem_info *get_mem_info(void)
 {
-	static struct axdmem_info mem_info;
+	static struct sls_mem_info mem_info;
 	static bool mem_info_initialized;
 
 	if (!mem_info_initialized)
@@ -23,24 +23,24 @@ static const struct axdmem_info *get_mem_info(void)
 }
 
 /*
- * Set offsets for AXDIMM blocks with different caching policies
+ * Set offsets for SLS blocks with different caching policies
  */
 static void set_ioremap_info(ulong *offset)
 {
-	const struct axdmem_info *mem_info = get_mem_info();
+	const struct sls_mem_info *mem_info = get_mem_info();
 
 	/* Set offset(iomem resource start address) */
-	offset[AXDIMM_BASE_CS0] = mem_info->mem_offset[0][AXDIMM_BLOCK_BASE];
-	offset[AXDIMM_TAGS_CS0] = mem_info->mem_offset[0][AXDIMM_BLOCK_TAGS];
-	offset[AXDIMM_PSUM_CS0] = mem_info->mem_offset[0][AXDIMM_BLOCK_PSUM];
-	offset[AXDIMM_BASE_CS1] = mem_info->mem_offset[1][AXDIMM_BLOCK_BASE];
-	offset[AXDIMM_TAGS_CS1] = mem_info->mem_offset[1][AXDIMM_BLOCK_TAGS];
-	offset[AXDIMM_PSUM_CS1] = mem_info->mem_offset[1][AXDIMM_BLOCK_PSUM];
+	offset[SLS_BASE_CS0] = mem_info->mem_offset[0][SLS_BLOCK_BASE];
+	offset[SLS_TAGS_CS0] = mem_info->mem_offset[0][SLS_BLOCK_TAGS];
+	offset[SLS_PSUM_CS0] = mem_info->mem_offset[0][SLS_BLOCK_PSUM];
+	offset[SLS_BASE_CS1] = mem_info->mem_offset[1][SLS_BLOCK_BASE];
+	offset[SLS_TAGS_CS1] = mem_info->mem_offset[1][SLS_BLOCK_TAGS];
+	offset[SLS_PSUM_CS1] = mem_info->mem_offset[1][SLS_BLOCK_PSUM];
 }
 
 static bool is_writecombine_region(int region_no)
 {
-	return region_no == AXDIMM_BASE_CS0 || region_no == AXDIMM_BASE_CS1;
+	return region_no == SLS_BASE_CS0 || region_no == SLS_BASE_CS1;
 }
 
 static pgprot_t get_page_prot(struct vm_area_struct *vma)
@@ -49,7 +49,7 @@ static pgprot_t get_page_prot(struct vm_area_struct *vma)
 	int i;
 	unsigned long phys_offset;
 
-	/* set physical offsets for AXDIMM blocks with different caching policies */
+	/* set physical offsets for SLS blocks with different caching policies */
 	set_ioremap_info(offset);
 	phys_offset = vma->vm_pgoff << PAGE_SHIFT;
 
@@ -65,10 +65,10 @@ static pgprot_t get_page_prot(struct vm_area_struct *vma)
 	return vma->vm_page_prot;
 }
 
-int axdimm_dax_mmap(struct file *filep, struct vm_area_struct *vma)
+int sls_dax_mmap(struct file *filep, struct vm_area_struct *vma)
 {
 	size_t page_addr, page_offset;
-	off_t gpio_addr = AXDIMM_BASE_ADDR;
+	off_t gpio_addr = SLS_BASE_ADDR;
 
 	page_offset = gpio_addr >> PAGE_SHIFT;
 	page_addr = page_offset + vma->vm_pgoff;
@@ -90,39 +90,39 @@ int axdimm_dax_mmap(struct file *filep, struct vm_area_struct *vma)
 	return 0;
 }
 
-static int setup_axdimm_ranges(struct dev_dax *dev_dax)
+static int setup_sls_ranges(struct dev_dax *dev_dax)
 {
 	struct dev_dax_range *ranges;
 	unsigned long pgoff = 0;
 	unsigned long orig_range_start = dev_dax->ranges[0].range.start;
 	int i, rc, cs, block;
 	unsigned long start, end;
-	const struct axdmem_info *mem_info = get_mem_info();
+	const struct sls_mem_info *mem_info = get_mem_info();
 
 	rc = 0;
-	dev_dax->nr_range = AXDIMM_BLOCK_MAX * NUM_OF_CS;
+	dev_dax->nr_range = SLS_BLOCK_MAX * NUM_OF_CS;
 	ranges = krealloc(dev_dax->ranges, sizeof(*ranges) * dev_dax->nr_range,
 			  GFP_KERNEL);
 
 	dev_dax->ranges = ranges;
 	for (i = 0; i < dev_dax->nr_range; ++i) {
-		cs = i / AXDIMM_BLOCK_MAX;
-		block = i % AXDIMM_BLOCK_MAX;
+		cs = i / SLS_BLOCK_MAX;
+		block = i % SLS_BLOCK_MAX;
 		/* The range[0].start, which is set up by devdax driver,
-		 * has an offset from AXDIMM_BASE_ADDR because __dax_pmem_probe
+		 * has an offset from SLS_BASE_ADDR because __dax_pmem_probe
 		 * reserves memory space for 'struct page' list used for ZONE_DEVICE.
 		 * See 'nd_pfn_init' from drivers/nvdimm/pfn_devs.c to understand how
 		 * this offset is calculated.
 		 * Yet for 'end' should be calculcated as if start equals to
-		 * AXDIMM_BASE_ADDR.
+		 * SLS_BASE_ADDR.
 		 */
 		if (i == 0) {
 			start = orig_range_start;
-			end = AXDIMM_BASE_ADDR + mem_info->mem_size[cs][block] -
+			end = SLS_BASE_ADDR + mem_info->mem_size[cs][block] -
 			      1;
 		} else {
 			start = mem_info->mem_offset[cs][block] +
-				AXDIMM_BASE_ADDR;
+				SLS_BASE_ADDR;
 			end = start + mem_info->mem_size[cs][block] - 1;
 		}
 		ranges[i] = (struct dev_dax_range) {
@@ -141,15 +141,15 @@ static int setup_axdimm_ranges(struct dev_dax *dev_dax)
 	return rc;
 }
 
-int init_axdimm_dax_device(struct dev_dax *dev_dax)
+int init_sls_dax_device(struct dev_dax *dev_dax)
 {
-	/* Mark DAX device as AXDIMM, this is used in mmap implementation */
-	dev_dax->is_axdimm_device = 1;
+	/* Mark DAX device as SLS, this is used in mmap implementation */
+	dev_dax->is_sls_device = 1;
 
-	/* Setup dev_dax ranges for AXDIMM, this is needed for proper
+	/* Setup dev_dax ranges for SLS, this is needed for proper
 	 * devdax <-> system-ram transitions (devdax <-> kmem).
 	 */
-	setup_axdimm_ranges(dev_dax);
+	setup_sls_ranges(dev_dax);
 
 	return 0;
 }
diff --git a/drivers/dax/sls_dax.h b/drivers/dax/sls_dax.h
new file mode 100644
index 000000000..1dbaa4296
--- /dev/null
+++ b/drivers/dax/sls_dax.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
+
+#ifndef __SLS_DAX_H__
+#define __SLS_DAX_H__
+
+/* For normal inclusion dax-private.h requires this header */
+/* Put the header here not to change origin dax-private.h */
+#include <linux/pgtable.h>
+#include "dax-private.h"
+
+#include <linux/sls_common.h>
+
+#include <linux/fs.h>
+#include <linux/mm_types.h>
+
+int sls_dax_mmap(struct file *filep, struct vm_area_struct *vma);
+int init_sls_dax_device(struct dev_dax *dev_dax);
+
+static inline bool is_sls_range(u64 start, u64 end)
+{
+	return start >= SLS_BASE_ADDR &&
+	       end < SLS_BASE_ADDR + SLS_MEMORY_SIZE;
+}
+
+#endif /* __SLS_DAX_H__ */
diff --git a/drivers/pnm/Kconfig b/drivers/pnm/Kconfig
index e463aac58..fcbd46d58 100644
--- a/drivers/pnm/Kconfig
+++ b/drivers/pnm/Kconfig
@@ -1,13 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0-only
-config AXDIMM_RESOURCE
-	tristate "AXDIMM Resource Manager"
-	help
-	  Support for management of AXDIMM device resources
-
-	  Create /dev/pnm/axdimm_resource device with ioctl and sysfs interfaces
-	  for interaction with rank and memory allocator and other AXDIMM device
-	  resources.
-
 menuconfig DBA_RESOURCE
 	tristate "DBA Resource Manager"
 	help
@@ -23,3 +14,14 @@ if DBA_RESOURCE
 source "drivers/pnm/dba_resource/Kconfig"
 
 endif
+
+config SLS_RESOURCE
+	tristate "SLS Resource Manager"
+	help
+	  Support for management of SLS device resources
+
+	  Create /dev/pnm/sls_resource entry which is responsible for
+	  providing such sls device resources as: ranks, memory to userspace
+	  by means of ioctl interface. Also it provide monitoring facilities
+	  using sysfs interface.
+
diff --git a/drivers/pnm/Makefile b/drivers/pnm/Makefile
index 1d56238e7..795a87298 100644
--- a/drivers/pnm/Makefile
+++ b/drivers/pnm/Makefile
@@ -1,4 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0
 
-obj-$(CONFIG_AXDIMM_RESOURCE) += axdimm_resource/
+obj-$(CONFIG_SLS_RESOURCE) += sls_resource/
 obj-$(CONFIG_DBA_RESOURCE) += dba_resource/
diff --git a/drivers/pnm/axdimm_resource/Makefile b/drivers/pnm/axdimm_resource/Makefile
deleted file mode 100644
index 05050b19e..000000000
--- a/drivers/pnm/axdimm_resource/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-obj-$(CONFIG_AXDIMM_RESOURCE) += axdimm_resource.o
-
-CFLAGS_axdimm.o += -DAXDIMM_DRIVER_VERSION=\"$(shell git describe --first-parent --abbrev=0 --dirty --always)\"
-axdimm_resource-y := resource.o
-axdimm_resource-y += axdimm.o
-axdimm_resource-y += axdimm_allocator.o
-axdimm_resource-y += axdimm_process_manager.o
-axdimm_resource-y += axdimm_rank_scheduler.o
-axdimm_resource-y += axdimm_sysfs.o
diff --git a/drivers/pnm/axdimm_resource/axdimm.c b/drivers/pnm/axdimm_resource/axdimm.c
deleted file mode 100644
index 04b37d152..000000000
--- a/drivers/pnm/axdimm_resource/axdimm.c
+++ /dev/null
@@ -1,248 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 2021-2023 Samsung LTD. All rights reserved. */
-
-#include "axdimm_process_manager.h"
-#include "axdimm_private.h"
-#include "axdimm_sysfs.h"
-#include "axdimm_log.h"
-
-#include <linux/axdimm_set_mem_info.h>
-#include <linux/cdev.h>
-#include <linux/dax.h>
-#include <linux/fs.h>
-#include <linux/io.h>
-#include <linux/libaxdimm.h>
-#include <linux/mm.h>
-#include <linux/mman.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-
-#ifdef AXDIMM_DRIVER_VERSION
-MODULE_VERSION(AXDIMM_DRIVER_VERSION);
-#endif
-
-#define AXDIMM_RESOURCE_BASE_MINOR 0
-#define AXDIMM_RESOURCE_DRIVER_NAME "axdimm_resource"
-#define AXDIMM_RESOURCE_REGION_NAME AXDIMM_RESOURCE_DRIVER_NAME
-#define AXDIMM_RESOURCE_CLASS_NAME AXDIMM_RESOURCE_DRIVER_NAME
-
-#define AXDIMM_RESOURCE_ACCESS_MODE 0666
-
-#define AXDIMM_RESOURCE_DEVICE_NAME AXDIMM_RESOURCE_PATH_INTERNAL
-struct axdimm_rank_scheduler axdimm_rank_sched;
-struct axdimm_process_manager axdimm_proc_mgr;
-
-static struct axdimm_dev axdimm_device;
-static struct class *axdimm_resource_class;
-static struct device *axdimm_resource_device;
-static struct cdev axdimm_resource_cdev;
-static dev_t axdimm_resource_device_number;
-
-int axdimm_release(struct inode *node, struct file *f)
-{
-	return release_axdimm_process(&axdimm_proc_mgr, axdimm_device.allocator,
-				      &axdimm_rank_sched);
-}
-
-int axdimm_open(struct inode *inode, struct file *filp)
-{
-	return register_axdimm_process(&axdimm_proc_mgr);
-}
-
-static void dump_ioctl_err(unsigned int cmd)
-{
-	AXDIMM_ERR(" ioctl cmd: magic %u, direction %u, size %u, number %u\n",
-		   _IOC_TYPE(cmd), _IOC_DIR(cmd), _IOC_SIZE(cmd), _IOC_NR(cmd));
-}
-
-long axdimm_ioctl(struct file *filp, unsigned int cmd, unsigned long __user arg)
-{
-	int retval = 0;
-
-	/*
-	 * extract the type and number bitfields, and don't decode
-	 * wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
-	 */
-	if (_IOC_TYPE(cmd) != AXDIMM_IOC_MAGIC) {
-		AXDIMM_ERR("Wrong ioctl magic. Aborting ioctl:\n");
-		dump_ioctl_err(cmd);
-		AXDIMM_ERR(" expected magic: %u\n", AXDIMM_IOC_MAGIC);
-		return -ENOTTY;
-	}
-	if (_IOC_NR(cmd) > AXDIMM_IOC_MAXNR) {
-		AXDIMM_ERR("Ioctl number too large. Aborting ioctl:\n");
-		dump_ioctl_err(cmd);
-		AXDIMM_ERR(" maximum ioctl number: %u\n", AXDIMM_IOC_MAGIC);
-		return -ENOTTY;
-	}
-
-	AXDIMM_DBG("Handling AXDIMM ioctl %u with arg 0x%lx\n", _IOC_NR(cmd),
-		   arg);
-
-	switch (cmd) {
-	case DEVICE_IOCRESET:
-		reset_axdimm_rank_scheduler(&axdimm_rank_sched);
-		retval = reset_axdimm_allocator(axdimm_device.allocator,
-						&axdimm_device.mem_info);
-		reset_axdimm_process_manager(&axdimm_proc_mgr);
-		break;
-	case ALLOCATE_MEMORY:
-	case GET_MEMORY_OBJECTS_NUM:
-	case GET_MEMORY_ALLOCATION:
-	case DEALLOCATE_MEMORY:
-		retval = mem_process_ioctl(cmd, axdimm_device.allocator, arg);
-		break;
-	case GET_RANK_FOR_WRITE:
-	case GET_RANK_FOR_READ:
-		retval = get_axdimm_rank(&axdimm_rank_sched, cmd, arg);
-		break;
-	case RELEASE_READ_RANK:
-	case RELEASE_WRITE_RANK:
-		retval = release_axdimm_rank(&axdimm_rank_sched, cmd, arg);
-		break;
-	default:
-		AXDIMM_ERR("Unknown ioctl command:\n");
-		dump_ioctl_err(cmd);
-		retval = -ENOTTY;
-	}
-
-	AXDIMM_DBG("Returning %d from ioctl\n", retval);
-	return retval;
-}
-
-static const struct file_operations axdimm_resource_ops = {
-	.owner = THIS_MODULE,
-	.open = axdimm_open,
-	.release = axdimm_release,
-	.unlocked_ioctl = axdimm_ioctl,
-};
-
-static char *devnode_func(struct device *dev, umode_t *mode)
-{
-	if (!mode)
-		return NULL;
-
-	*mode = AXDIMM_RESOURCE_ACCESS_MODE;
-	return NULL;
-}
-
-static int init_axdimm_resource_dev(void)
-{
-	int err = 0;
-
-	err = alloc_chrdev_region(&axdimm_resource_device_number,
-				  AXDIMM_RESOURCE_BASE_MINOR, 1,
-				  AXDIMM_RESOURCE_REGION_NAME);
-	if (err) {
-		AXDIMM_ERR("Failed to allocate chrdev region\n");
-		goto fail;
-	}
-	AXDIMM_DBG("axdimm_resource chrdev region: major %d, minor %d\n",
-		   MAJOR(axdimm_resource_device_number),
-		   MINOR(axdimm_resource_device_number));
-
-	axdimm_resource_class =
-		class_create(THIS_MODULE, AXDIMM_RESOURCE_CLASS_NAME);
-	if (IS_ERR(axdimm_resource_class)) {
-		err = PTR_ERR(axdimm_resource_class);
-		AXDIMM_ERR("Failed to create device class\n");
-		goto fail_region;
-	}
-	AXDIMM_DBG("Created class %s\n", AXDIMM_RESOURCE_CLASS_NAME);
-
-	axdimm_resource_class->devnode = devnode_func;
-
-	axdimm_resource_device = device_create(axdimm_resource_class, NULL,
-					       axdimm_resource_device_number,
-					       NULL, "%s",
-					       AXDIMM_RESOURCE_DEVICE_NAME);
-	if (IS_ERR(axdimm_resource_device)) {
-		err = PTR_ERR(axdimm_resource_device);
-		AXDIMM_ERR("Failed to create %s device\n",
-			   AXDIMM_RESOURCE_DEVICE_NAME);
-		goto fail_class;
-	}
-
-	cdev_init(&axdimm_resource_cdev, &axdimm_resource_ops);
-	err = cdev_add(&axdimm_resource_cdev, axdimm_resource_device_number, 1);
-	if (err) {
-		AXDIMM_ERR("Failed to add %s cdev\n",
-			   AXDIMM_RESOURCE_DEVICE_NAME);
-		goto fail_device;
-	}
-
-	AXDIMM_INF("%s device is created\n", AXDIMM_RESOURCE_DEVICE_NAME);
-	return 0;
-
-fail_device:
-	device_destroy(axdimm_resource_class, axdimm_resource_device_number);
-fail_class:
-	class_destroy(axdimm_resource_class);
-fail_region:
-	unregister_chrdev_region(axdimm_resource_device_number, 1);
-fail:
-	return err;
-}
-
-static void destroy_axdimm_resource_dev(void)
-{
-	cdev_del(&axdimm_resource_cdev);
-	device_destroy(axdimm_resource_class, axdimm_resource_device_number);
-	class_destroy(axdimm_resource_class);
-	unregister_chrdev_region(axdimm_resource_device_number, 1);
-}
-
-int init_axdimm_device(void)
-{
-	int err;
-
-	AXDIMM_INF("Initializing AXDIMM device\n");
-
-	/* Initialize axdimm_resource device */
-	err = init_axdimm_resource_dev();
-	if (err)
-		goto out;
-
-	/* Initialize device mem_info */
-	axdimm_set_mem_info(&axdimm_device.mem_info);
-
-	/* Initialize memory allocator */
-	err = init_axdimm_allocator(&axdimm_device);
-	if (err)
-		goto out_resource_dev;
-
-	/* Initialize manager of processes which use AXDIMM resources */
-	init_axdimm_process_manager(&axdimm_proc_mgr);
-
-	/* Reset ranks status and synchronization primitives */
-	init_axdimm_rank_scheduler(&axdimm_rank_sched);
-
-	/* Create sysfs subsystem for the device */
-	err = build_axdimm_sysfs(&axdimm_device, axdimm_resource_device);
-	if (err)
-		goto out_resource_dev;
-
-	return 0;
-
-out_resource_dev:
-	destroy_axdimm_resource_dev();
-out:
-	return err;
-}
-
-void cleanup_axdimm_device(void)
-{
-	AXDIMM_INF("Cleaning up AXDIMM device\n");
-
-	/* Free allocated memory */
-	cleanup_axdimm_allocator(&axdimm_device);
-
-	/* Free allocated memory if any user processes alive upon device remove*/
-	cleanup_axdimm_process_manager(&axdimm_proc_mgr);
-
-	/* Remove test attribute */
-	destroy_axdimm_sysfs();
-
-	/* Destroy axdimm_resource device */
-	destroy_axdimm_resource_dev();
-}
diff --git a/drivers/pnm/axdimm_resource/axdimm.h b/drivers/pnm/axdimm_resource/axdimm.h
deleted file mode 100644
index 9b9cccc0c..000000000
--- a/drivers/pnm/axdimm_resource/axdimm.h
+++ /dev/null
@@ -1,10 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
-
-#ifndef __AXDIMM__
-#define __AXDIMM__
-
-int init_axdimm_device(void);
-void cleanup_axdimm_device(void);
-
-#endif /* __AXDIMM__ */
diff --git a/drivers/pnm/axdimm_resource/axdimm_log.h b/drivers/pnm/axdimm_resource/axdimm_log.h
deleted file mode 100644
index 99b9d0f44..000000000
--- a/drivers/pnm/axdimm_resource/axdimm_log.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 2022-2023 Samsung LTD. All rights reserved. */
-
-#ifndef __AXDIMM_LOG_H__
-#define __AXDIMM_LOG_H__
-
-#include <linux/kernel.h>
-
-#define AXDIMM_DD_MARK "[DAX_AXDIMM_DD]"
-
-#define AXDIMM_PRINT(level, fmt, ...)                                          \
-	pr_##level(AXDIMM_DD_MARK "[%s:%d] " fmt, __FILE__, __LINE__,          \
-	       ##__VA_ARGS__)
-#define AXDIMM_ERR(fmt, ...) AXDIMM_PRINT(err, fmt, ##__VA_ARGS__)
-#define AXDIMM_WRN(fmt, ...) AXDIMM_PRINT(warn, fmt, ##__VA_ARGS__)
-#define AXDIMM_INF(fmt, ...) AXDIMM_PRINT(info, fmt, ##__VA_ARGS__)
-#define AXDIMM_DBG(fmt, ...) AXDIMM_PRINT(debug, fmt, ##__VA_ARGS__)
-
-#endif /* __AXDIMM_LOG_H__ */
diff --git a/drivers/pnm/axdimm_resource/axdimm_private.h b/drivers/pnm/axdimm_resource/axdimm_private.h
deleted file mode 100644
index fc4ca75e5..000000000
--- a/drivers/pnm/axdimm_resource/axdimm_private.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 2021-2023 Samsung LTD. All rights reserved. */
-
-#ifndef __AXDIMM_PRIVATE_H__
-#define __AXDIMM_PRIVATE_H__
-
-#include "axdimm_log.h"
-
-#include <linux/axdimm_common.h>
-#include <linux/cdev.h>
-#include <linux/compiler.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/semaphore.h>
-#include <linux/types.h>
-#include <linux/kobject.h>
-
-#define AXDIMM_COPY_FROM_TO_USER(func, error, dst, src, size)        \
-	do {                                                         \
-		error = func(dst, src, size) ? -EFAULT : 0;          \
-		if (unlikely(error)) {                               \
-			AXDIMM_ERR("Can't copy '" #src "' to '" #dst \
-				   "' in '" #func "'\n");            \
-		}                                                    \
-	} while (0)
-#define AXDIMM_COPY_FROM_USER(error, dst, src, size) \
-	AXDIMM_COPY_FROM_TO_USER(copy_from_user, error, dst, src, size)
-#define AXDIMM_COPY_TO_USER(error, dst, src, size) \
-	AXDIMM_COPY_FROM_TO_USER(copy_to_user, error, dst, src, size)
-
-/* Just sizeof(array) with static array check */
-#define SIZEOF_ARRAY(arr) (sizeof(arr) + __must_be_array(arr))
-
-struct axdimm_device_data {
-	int rank;
-	int region;
-	int channel;
-};
-
-struct axdimm_allocator;
-
-struct axdimm_dev {
-	struct axdmem_info mem_info; /* memory info */
-	struct axdimm_allocator *allocator;
-};
-
-static inline int is_axdimm_range(u64 start, u64 end)
-{
-	return start >= AXDIMM_BASE_ADDR &&
-	       end < AXDIMM_BASE_ADDR + AXDIMM_MEMORY_SIZE;
-}
-
-void cleanup_axdimm_device(void);
-
-long axdimm_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
-
-int axdimm_release(struct inode *node, struct file *f);
-int axdimm_open(struct inode *inode, struct file *filp);
-
-#endif
-
-/* __AXDIMM_PRIVATE_H__ */
diff --git a/drivers/pnm/axdimm_resource/axdimm_sysfs.h b/drivers/pnm/axdimm_resource/axdimm_sysfs.h
deleted file mode 100644
index b0f5dab5a..000000000
--- a/drivers/pnm/axdimm_resource/axdimm_sysfs.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 2022-2023 Samsung LTD. All rights reserved. */
-
-#ifndef __AXDIMM_SYSFS__
-#define __AXDIMM_SYSFS__
-
-struct device;
-struct axdimm_dev;
-
-extern struct axdimm_rank_scheduler axdimm_rank_sched;
-extern struct axdimm_process_manager axdimm_proc_mgr;
-
-int build_axdimm_sysfs(struct axdimm_dev *dev, struct device *resource_dev);
-void destroy_axdimm_sysfs(void);
-
-#endif /* __AXDIMM_SYSFS__ */
diff --git a/drivers/pnm/sls_resource/Makefile b/drivers/pnm/sls_resource/Makefile
new file mode 100644
index 000000000..c0f1ffb6d
--- /dev/null
+++ b/drivers/pnm/sls_resource/Makefile
@@ -0,0 +1,9 @@
+obj-$(CONFIG_SLS_RESOURCE) += sls_resource.o
+
+CFLAGS_sls.o += -DSLS_DRIVER_VERSION=\"$(shell git describe --first-parent --abbrev=0 --dirty --always)\"
+sls_resource-y := resource.o
+sls_resource-y += sls.o
+sls_resource-y += sls_allocator.o
+sls_resource-y += sls_process_manager.o
+sls_resource-y += sls_rank_scheduler.o
+sls_resource-y += sls_sysfs.o
diff --git a/drivers/pnm/axdimm_resource/resource.c b/drivers/pnm/sls_resource/resource.c
similarity index 68%
rename from drivers/pnm/axdimm_resource/resource.c
rename to drivers/pnm/sls_resource/resource.c
index e8a8a3094..807e909d1 100644
--- a/drivers/pnm/axdimm_resource/resource.c
+++ b/drivers/pnm/sls_resource/resource.c
@@ -2,20 +2,20 @@
 /* Copyright(c) 2023 Samsung LTD. All rights reserved. */
 
 #include <linux/module.h>
-#include "axdimm.h"
+#include "sls.h"
 
 static int __init init_mod(void)
 {
-	return init_axdimm_device();
+	return init_sls_device();
 }
 
 static void __exit exit_mod(void)
 {
-	cleanup_axdimm_device();
+	cleanup_sls_device();
 }
 
 MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("AxDIMM resource manager");
+MODULE_DESCRIPTION("SLS resource manager");
 
 module_init(init_mod);
 module_exit(exit_mod);
diff --git a/drivers/pnm/sls_resource/sls.c b/drivers/pnm/sls_resource/sls.c
new file mode 100644
index 000000000..519760160
--- /dev/null
+++ b/drivers/pnm/sls_resource/sls.c
@@ -0,0 +1,248 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 2021-2023 Samsung LTD. All rights reserved. */
+
+#include "sls_process_manager.h"
+#include "sls_private.h"
+#include "sls_sysfs.h"
+#include "sls_log.h"
+
+#include <linux/axdimm_set_mem_info.h>
+#include <linux/cdev.h>
+#include <linux/dax.h>
+#include <linux/fs.h>
+#include <linux/io.h>
+#include <linux/sls_resources.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#ifdef SLS_DRIVER_VERSION
+MODULE_VERSION(SLS_DRIVER_VERSION);
+#endif
+
+#define SLS_RESOURCE_BASE_MINOR 0
+#define SLS_RESOURCE_DRIVER_NAME "sls_resource"
+#define SLS_RESOURCE_REGION_NAME SLS_RESOURCE_DRIVER_NAME
+#define SLS_RESOURCE_CLASS_NAME SLS_RESOURCE_DRIVER_NAME
+
+#define SLS_RESOURCE_ACCESS_MODE 0666
+
+#define SLS_RESOURCE_DEVICE_NAME SLS_RESOURCE_PATH_INTERNAL
+struct sls_rank_scheduler sls_rank_sched;
+struct sls_process_manager sls_proc_mgr;
+
+static struct sls_dev sls_device;
+static struct class *sls_resource_class;
+static struct device *sls_resource_device;
+static struct cdev sls_resource_cdev;
+static dev_t sls_resource_device_number;
+
+int sls_release(struct inode *node, struct file *f)
+{
+	return release_sls_process(&sls_proc_mgr, sls_device.allocator,
+				      &sls_rank_sched);
+}
+
+int sls_open(struct inode *inode, struct file *filp)
+{
+	return register_sls_process(&sls_proc_mgr);
+}
+
+static void dump_ioctl_err(unsigned int cmd)
+{
+	SLS_ERR(" ioctl cmd: magic %u, direction %u, size %u, number %u\n",
+		   _IOC_TYPE(cmd), _IOC_DIR(cmd), _IOC_SIZE(cmd), _IOC_NR(cmd));
+}
+
+long sls_ioctl(struct file *filp, unsigned int cmd, unsigned long __user arg)
+{
+	int retval = 0;
+
+	/*
+	 * extract the type and number bitfields, and don't decode
+	 * wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
+	 */
+	if (_IOC_TYPE(cmd) != SLS_IOC_MAGIC) {
+		SLS_ERR("Wrong ioctl magic. Aborting ioctl:\n");
+		dump_ioctl_err(cmd);
+		SLS_ERR(" expected magic: %u\n", SLS_IOC_MAGIC);
+		return -ENOTTY;
+	}
+	if (_IOC_NR(cmd) > SLS_IOC_MAXNR) {
+		SLS_ERR("Ioctl number too large. Aborting ioctl:\n");
+		dump_ioctl_err(cmd);
+		SLS_ERR(" maximum ioctl number: %u\n", SLS_IOC_MAGIC);
+		return -ENOTTY;
+	}
+
+	SLS_DBG("Handling SLS ioctl %u with arg 0x%lx\n", _IOC_NR(cmd),
+		   arg);
+
+	switch (cmd) {
+	case DEVICE_IOCRESET:
+		reset_sls_rank_scheduler(&sls_rank_sched);
+		retval = reset_sls_allocator(sls_device.allocator,
+						&sls_device.mem_info);
+		reset_sls_process_manager(&sls_proc_mgr);
+		break;
+	case ALLOCATE_MEMORY:
+	case GET_MEMORY_OBJECTS_NUM:
+	case GET_MEMORY_ALLOCATION:
+	case DEALLOCATE_MEMORY:
+		retval = mem_process_ioctl(cmd, sls_device.allocator, arg);
+		break;
+	case GET_RANK_FOR_WRITE:
+	case GET_RANK_FOR_READ:
+		retval = get_sls_rank(&sls_rank_sched, cmd, arg);
+		break;
+	case RELEASE_READ_RANK:
+	case RELEASE_WRITE_RANK:
+		retval = release_sls_rank(&sls_rank_sched, cmd, arg);
+		break;
+	default:
+		SLS_ERR("Unknown ioctl command:\n");
+		dump_ioctl_err(cmd);
+		retval = -ENOTTY;
+	}
+
+	SLS_DBG("Returning %d from ioctl\n", retval);
+	return retval;
+}
+
+static const struct file_operations sls_resource_ops = {
+	.owner = THIS_MODULE,
+	.open = sls_open,
+	.release = sls_release,
+	.unlocked_ioctl = sls_ioctl,
+};
+
+static char *devnode_func(struct device *dev, umode_t *mode)
+{
+	if (!mode)
+		return NULL;
+
+	*mode = SLS_RESOURCE_ACCESS_MODE;
+	return NULL;
+}
+
+static int init_sls_resource_dev(void)
+{
+	int err = 0;
+
+	err = alloc_chrdev_region(&sls_resource_device_number,
+				  SLS_RESOURCE_BASE_MINOR, 1,
+				  SLS_RESOURCE_REGION_NAME);
+	if (err) {
+		SLS_ERR("Failed to allocate chrdev region\n");
+		goto fail;
+	}
+	SLS_DBG("sls_resource chrdev region: major %d, minor %d\n",
+		   MAJOR(sls_resource_device_number),
+		   MINOR(sls_resource_device_number));
+
+	sls_resource_class =
+		class_create(THIS_MODULE, SLS_RESOURCE_CLASS_NAME);
+	if (IS_ERR(sls_resource_class)) {
+		err = PTR_ERR(sls_resource_class);
+		SLS_ERR("Failed to create device class\n");
+		goto fail_region;
+	}
+	SLS_DBG("Created class %s\n", SLS_RESOURCE_CLASS_NAME);
+
+	sls_resource_class->devnode = devnode_func;
+
+	sls_resource_device = device_create(sls_resource_class, NULL,
+					       sls_resource_device_number,
+					       NULL, "%s",
+					       SLS_RESOURCE_DEVICE_NAME);
+	if (IS_ERR(sls_resource_device)) {
+		err = PTR_ERR(sls_resource_device);
+		SLS_ERR("Failed to create %s device\n",
+			   SLS_RESOURCE_DEVICE_NAME);
+		goto fail_class;
+	}
+
+	cdev_init(&sls_resource_cdev, &sls_resource_ops);
+	err = cdev_add(&sls_resource_cdev, sls_resource_device_number, 1);
+	if (err) {
+		SLS_ERR("Failed to add %s cdev\n",
+			   SLS_RESOURCE_DEVICE_NAME);
+		goto fail_device;
+	}
+
+	SLS_INF("%s device is created\n", SLS_RESOURCE_DEVICE_NAME);
+	return 0;
+
+fail_device:
+	device_destroy(sls_resource_class, sls_resource_device_number);
+fail_class:
+	class_destroy(sls_resource_class);
+fail_region:
+	unregister_chrdev_region(sls_resource_device_number, 1);
+fail:
+	return err;
+}
+
+static void destroy_sls_resource_dev(void)
+{
+	cdev_del(&sls_resource_cdev);
+	device_destroy(sls_resource_class, sls_resource_device_number);
+	class_destroy(sls_resource_class);
+	unregister_chrdev_region(sls_resource_device_number, 1);
+}
+
+int init_sls_device(void)
+{
+	int err;
+
+	SLS_INF("Initializing SLS device\n");
+
+	/* Initialize sls_resource device */
+	err = init_sls_resource_dev();
+	if (err)
+		goto out;
+
+	/* Initialize device mem_info */
+	axdimm_set_mem_info(&sls_device.mem_info);
+
+	/* Initialize memory allocator */
+	err = init_sls_allocator(&sls_device);
+	if (err)
+		goto out_resource_dev;
+
+	/* Initialize manager of processes which use SLS resources */
+	init_sls_process_manager(&sls_proc_mgr);
+
+	/* Reset ranks status and synchronization primitives */
+	init_sls_rank_scheduler(&sls_rank_sched);
+
+	/* Create sysfs subsystem for the device */
+	err = build_sls_sysfs(&sls_device, sls_resource_device);
+	if (err)
+		goto out_resource_dev;
+
+	return 0;
+
+out_resource_dev:
+	destroy_sls_resource_dev();
+out:
+	return err;
+}
+
+void cleanup_sls_device(void)
+{
+	SLS_INF("Cleaning up SLS device\n");
+
+	/* Free allocated memory */
+	cleanup_sls_allocator(&sls_device);
+
+	/* Free allocated memory if any user processes alive upon device remove*/
+	cleanup_sls_process_manager(&sls_proc_mgr);
+
+	/* Remove test attribute */
+	destroy_sls_sysfs();
+
+	/* Destroy sls_resource device */
+	destroy_sls_resource_dev();
+}
diff --git a/drivers/pnm/sls_resource/sls.h b/drivers/pnm/sls_resource/sls.h
new file mode 100644
index 000000000..8df833865
--- /dev/null
+++ b/drivers/pnm/sls_resource/sls.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
+
+#ifndef __SLS__
+#define __SLS__
+
+int init_sls_device(void);
+void cleanup_sls_device(void);
+
+#endif /* __SLS__ */
diff --git a/drivers/pnm/axdimm_resource/axdimm_allocator.c b/drivers/pnm/sls_resource/sls_allocator.c
similarity index 68%
rename from drivers/pnm/axdimm_resource/axdimm_allocator.c
rename to drivers/pnm/sls_resource/sls_allocator.c
index 8d3185392..3d8f423e0 100644
--- a/drivers/pnm/axdimm_resource/axdimm_allocator.c
+++ b/drivers/pnm/sls_resource/sls_allocator.c
@@ -1,11 +1,11 @@
 // SPDX-License-Identifier: GPL-2.0
 /* Copyright(c) 2022-2023 Samsung LTD. All rights reserved. */
 
-#include "axdimm_allocator.h"
+#include "sls_allocator.h"
 
-#include "axdimm_log.h"
-#include "axdimm_private.h"
-#include "axdimm_process_manager.h"
+#include "sls_log.h"
+#include "sls_private.h"
+#include "sls_process_manager.h"
 
 #include <linux/genalloc.h>
 #include <linux/log2.h>
@@ -14,35 +14,35 @@
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 
-extern struct axdimm_process_manager axdimm_proc_mgr;
+extern struct sls_process_manager sls_proc_mgr;
 
-struct __axdimm_allocator {
-	struct axdimm_allocator data;
+struct __sls_allocator {
+	struct sls_allocator data;
 	struct mutex memory_mutex;
 } __allocator;
 
-void lock_allocator(struct axdimm_allocator *alloc)
+void lock_allocator(struct sls_allocator *alloc)
 {
-	struct __axdimm_allocator *allocator =
-		container_of(alloc, struct __axdimm_allocator, data);
+	struct __sls_allocator *allocator =
+		container_of(alloc, struct __sls_allocator, data);
 	mutex_lock(&allocator->memory_mutex);
 }
 
-void unlock_allocator(struct axdimm_allocator *alloc)
+void unlock_allocator(struct sls_allocator *alloc)
 {
-	struct __axdimm_allocator *allocator =
-		container_of(alloc, struct __axdimm_allocator, data);
+	struct __sls_allocator *allocator =
+		container_of(alloc, struct __sls_allocator, data);
 	mutex_unlock(&allocator->memory_mutex);
 }
 
-static bool allocator_is_locked(struct axdimm_allocator *alloc)
+static bool allocator_is_locked(struct sls_allocator *alloc)
 {
-	struct __axdimm_allocator *allocator =
-		container_of(alloc, struct __axdimm_allocator, data);
+	struct __sls_allocator *allocator =
+		container_of(alloc, struct __sls_allocator, data);
 	return mutex_is_locked(&allocator->memory_mutex);
 }
 
-static int init_rank_pool(struct axdimm_allocator *alloc, uint8_t rank,
+static int init_rank_pool(struct sls_allocator *alloc, uint8_t rank,
 			  uint64_t size)
 {
 	int err_code;
@@ -50,7 +50,7 @@ static int init_rank_pool(struct axdimm_allocator *alloc, uint8_t rank,
 		gen_pool_create(ilog2(alloc->gran), NUMA_NO_NODE);
 
 	if (unlikely(!pool)) {
-		AXDIMM_ERR(
+		SLS_ERR(
 			"gen_pool_create failed for rank pool[%hhu], granularity = [%llu]\n",
 			rank, alloc->gran);
 		err_code = -ENOMEM;
@@ -60,14 +60,14 @@ static int init_rank_pool(struct axdimm_allocator *alloc, uint8_t rank,
 	/* The reason why PAGE_SIZE is given below in init_memory_pools */
 	err_code = gen_pool_add(pool, PAGE_SIZE, size, NUMA_NO_NODE);
 	if (unlikely(err_code < 0)) {
-		AXDIMM_ERR(
+		SLS_ERR(
 			"Failed to init memory rank pool[%hhu], size = [%llu] with error [%d]\n",
 			rank, size, err_code);
 		gen_pool_destroy(pool);
 		goto init_rank_pool_out;
 	}
 
-	AXDIMM_INF(
+	SLS_INF(
 		"Memory rank pool[%hhu] initialized: granularity = [%llu], size = [%llu]\n",
 		rank, alloc->gran, size);
 	alloc->mem_pools[rank] = pool;
@@ -84,7 +84,7 @@ static void mem_pool_mark_zero_chunk_size(struct gen_pool *pool,
 	chunk->end_addr = chunk->start_addr - 1;
 }
 
-static void cleanup_memory_pools(struct axdimm_allocator *alloc)
+static void cleanup_memory_pools(struct sls_allocator *alloc)
 {
 	uint8_t rank;
 	struct gen_pool *pool;
@@ -92,13 +92,13 @@ static void cleanup_memory_pools(struct axdimm_allocator *alloc)
 	for (rank = 0; rank < NUM_OF_RANK; ++rank) {
 		pool = alloc->mem_pools[rank];
 		if (unlikely(!pool)) {
-			AXDIMM_WRN(
+			SLS_WRN(
 				"Trying to cleanup memory rank pool[%hhu] that was not created\n",
 				rank);
 			continue;
 		}
 		if (unlikely(gen_pool_avail(pool) != gen_pool_size(pool))) {
-			AXDIMM_ERR(
+			SLS_ERR(
 				"Memory rank pool[%hhu]: non-deallocated objects exist, size: %zu, avail: %zu\n",
 				rank, gen_pool_size(pool),
 				gen_pool_avail(pool));
@@ -112,26 +112,26 @@ static void cleanup_memory_pools(struct axdimm_allocator *alloc)
 				pool, mem_pool_mark_zero_chunk_size, NULL);
 		}
 		gen_pool_destroy(pool);
-		AXDIMM_INF("Memory rank pool[%hhu] is destroyed\n", rank);
+		SLS_INF("Memory rank pool[%hhu] is destroyed\n", rank);
 	}
 	memset(alloc->mem_pools, 0, SIZEOF_ARRAY(alloc->mem_pools));
 }
 
-static inline uint64_t get_rank_size(struct axdmem_info *mem_info, uint8_t rank)
+static inline uint64_t get_rank_size(struct sls_mem_info *mem_info, uint8_t rank)
 {
-	return mem_info->mem_size[rank % NUM_OF_CS][AXDIMM_BLOCK_BASE] /
+	return mem_info->mem_size[rank % NUM_OF_CS][SLS_BLOCK_BASE] /
 	       NUM_RANKS_PER_CS;
 }
 
-static int init_memory_pools(struct axdimm_allocator *alloc,
-			     struct axdmem_info *mem_info)
+static int init_memory_pools(struct sls_allocator *alloc,
+			     struct sls_mem_info *mem_info)
 {
 	uint8_t rank;
 	uint64_t rank_size;
 	int err_code;
 
 	if (unlikely(!is_power_of_2(alloc->gran))) {
-		AXDIMM_ERR("Memory granularity should be a power of 2!\n");
+		SLS_ERR("Memory granularity should be a power of 2!\n");
 		return -EINVAL;
 	}
 
@@ -157,8 +157,8 @@ static int init_memory_pools(struct axdimm_allocator *alloc,
 }
 
 /* General preinitializing allocator part, reset/init independent */
-static int preinit_axdimm_allocator(struct axdimm_allocator *alloc,
-				    struct axdmem_info *mem_info)
+static int preinit_sls_allocator(struct sls_allocator *alloc,
+				    struct sls_mem_info *mem_info)
 {
 	alloc->pack_counter = 0;
 	alloc->gran = PAGE_SIZE; // [TODO: @p.bred] make configurable
@@ -166,15 +166,15 @@ static int preinit_axdimm_allocator(struct axdimm_allocator *alloc,
 	return mem_info ? init_memory_pools(alloc, mem_info) : 0;
 }
 
-int init_axdimm_allocator(struct axdimm_dev *dev)
+int init_sls_allocator(struct sls_dev *dev)
 {
 	int err_code;
 
 	dev->allocator = &__allocator.data;
 
-	AXDIMM_DBG("Initializing AXDIMM allocator\n");
+	SLS_DBG("Initializing SLS allocator\n");
 
-	err_code = preinit_axdimm_allocator(dev->allocator, &dev->mem_info);
+	err_code = preinit_sls_allocator(dev->allocator, &dev->mem_info);
 	if (unlikely(err_code))
 		return err_code;
 
@@ -187,7 +187,7 @@ int init_axdimm_allocator(struct axdimm_dev *dev)
 }
 
 /* Cleanup memory object packages storage */
-static void cleanup_obj_packs(struct axdimm_allocator *alloc)
+static void cleanup_obj_packs(struct sls_allocator *alloc)
 {
 	struct list_head *cur, *n;
 	struct obj_pack *entry;
@@ -200,39 +200,39 @@ static void cleanup_obj_packs(struct axdimm_allocator *alloc)
 	}
 }
 
-int reset_axdimm_allocator(struct axdimm_allocator *alloc,
-			   struct axdmem_info *mem_info)
+int reset_sls_allocator(struct sls_allocator *alloc,
+			   struct sls_mem_info *mem_info)
 {
-	AXDIMM_DBG("Resetting AXDIMM allocator\n");
+	SLS_DBG("Resetting SLS allocator\n");
 
 	if (unlikely(allocator_is_locked(alloc))) {
-		AXDIMM_WRN("Mutex unlock forced.\n");
+		SLS_WRN("Mutex unlock forced.\n");
 		unlock_allocator(alloc);
 	}
 
 	cleanup_obj_packs(alloc);
 	cleanup_memory_pools(alloc);
 
-	return preinit_axdimm_allocator(alloc, mem_info);
+	return preinit_sls_allocator(alloc, mem_info);
 }
 
-void cleanup_axdimm_allocator(struct axdimm_dev *dev)
+void cleanup_sls_allocator(struct sls_dev *dev)
 {
-	struct __axdimm_allocator *allocator =
-		container_of(dev->allocator, struct __axdimm_allocator, data);
+	struct __sls_allocator *allocator =
+		container_of(dev->allocator, struct __sls_allocator, data);
 
-	AXDIMM_DBG("Cleaning up AXDIMM allocator\n");
-	reset_axdimm_allocator(dev->allocator, NULL);
+	SLS_DBG("Cleaning up SLS allocator\n");
+	reset_sls_allocator(dev->allocator, NULL);
 	mutex_destroy(&allocator->memory_mutex);
 }
 
-static int add_obj_pack(struct axdimm_allocator *alloc,
-			struct axd_memory_object *objects, uint64_t num_obj)
+static int add_obj_pack(struct sls_allocator *alloc,
+			struct sls_memory_object *objects, uint64_t num_obj)
 {
 	struct obj_pack *pack = kmalloc(sizeof(struct obj_pack), GFP_KERNEL);
 
 	if (unlikely(!pack)) {
-		AXDIMM_ERR("kmalloc failed for obj_pack [%zu]\n",
+		SLS_ERR("kmalloc failed for obj_pack [%zu]\n",
 			   sizeof(struct obj_pack));
 		return -ENOMEM;
 	}
@@ -251,18 +251,18 @@ static int add_obj_pack(struct axdimm_allocator *alloc,
 
 /* Get total number of allocated objects depends on user memory policy. */
 static inline uint64_t gen_num_obj(uint64_t num_user_obj,
-				   enum axd_user_preferences pref)
+				   enum sls_user_preferences pref)
 {
 	switch (GET_ALLOC_POLICY(pref)) {
-	case AXDIMM_ALLOC_AUTO:
-	case AXDIMM_ALLOC_REPLICATE_ALL:
+	case SLS_ALLOC_AUTO:
+	case SLS_ALLOC_REPLICATE_ALL:
 		return num_user_obj * NUM_OF_RANK;
-	case AXDIMM_ALLOC_DISTRIBUTE_ALL:
-	case AXDIMM_ALLOC_SINGLE:
+	case SLS_ALLOC_DISTRIBUTE_ALL:
+	case SLS_ALLOC_SINGLE:
 		return num_user_obj;
 	}
 
-	AXDIMM_ERR("Unknown memory policy [%d]\n", pref);
+	SLS_ERR("Unknown memory policy [%d]\n", pref);
 	return 0;
 }
 
@@ -270,20 +270,20 @@ static inline uint64_t gen_num_obj(uint64_t num_user_obj,
  * depends on user memory policy.
  */
 static inline uint64_t gen_rank_num_obj(uint64_t num_user_obj,
-					enum axd_user_preferences pref)
+					enum sls_user_preferences pref)
 {
 	switch (GET_ALLOC_POLICY(pref)) {
-	case AXDIMM_ALLOC_AUTO:
-	case AXDIMM_ALLOC_REPLICATE_ALL:
+	case SLS_ALLOC_AUTO:
+	case SLS_ALLOC_REPLICATE_ALL:
 		return num_user_obj;
-	case AXDIMM_ALLOC_DISTRIBUTE_ALL:
+	case SLS_ALLOC_DISTRIBUTE_ALL:
 		/* [TODO: @p.bred] Not perfectly even distribution for a small number of objects */
 		return DIV_ROUND_UP(num_user_obj, NUM_OF_RANK);
-	case AXDIMM_ALLOC_SINGLE:
+	case SLS_ALLOC_SINGLE:
 		return 1;
 	}
 
-	AXDIMM_ERR("Unknown memory policy [%d]\n", pref);
+	SLS_ERR("Unknown memory policy [%d]\n", pref);
 	return 0;
 }
 
@@ -292,33 +292,33 @@ static inline uint64_t gen_rank_num_obj(uint64_t num_user_obj,
  */
 static inline uint64_t get_user_obj_idx(uint64_t obj_idx, uint8_t rank,
 					uint64_t rank_num_obj,
-					enum axd_user_preferences pref)
+					enum sls_user_preferences pref)
 {
 	switch (GET_ALLOC_POLICY(pref)) {
-	case AXDIMM_ALLOC_AUTO:
-	case AXDIMM_ALLOC_REPLICATE_ALL:
+	case SLS_ALLOC_AUTO:
+	case SLS_ALLOC_REPLICATE_ALL:
 		return obj_idx - rank * rank_num_obj;
-	case AXDIMM_ALLOC_DISTRIBUTE_ALL:
-	case AXDIMM_ALLOC_SINGLE:
+	case SLS_ALLOC_DISTRIBUTE_ALL:
+	case SLS_ALLOC_SINGLE:
 		return obj_idx;
 	}
 
-	AXDIMM_ERR("Unknown memory policy [%d]\n", pref);
+	SLS_ERR("Unknown memory policy [%d]\n", pref);
 	return 0;
 }
 
 /* Allocate and fill object by the corresponding user object inside rank pool */
-static int pool_alloc_mem_obj(struct axdimm_allocator *alloc, uint64_t obj_idx,
+static int pool_alloc_mem_obj(struct sls_allocator *alloc, uint64_t obj_idx,
 			      uint8_t rank, uint64_t rank_num_obj,
-			      struct axd_memory_object *objects,
-			      struct axd_memory_alloc_request *request)
+			      struct sls_memory_object *objects,
+			      struct sls_memory_alloc_request *request)
 {
 	uint64_t user_obj_size, offset;
 	const uint64_t user_obj_idx = get_user_obj_idx(
 		obj_idx, rank, rank_num_obj, request->preference);
 
 	if (user_obj_idx >= request->num_user_objects) {
-		AXDIMM_ERR(
+		SLS_ERR(
 			"user_obj_idx >= num_user_objects, user_obj_idx = [%llu], num_user_objects = [%llu]\n",
 			user_obj_idx, request->num_user_objects);
 		return -EINVAL;
@@ -326,7 +326,7 @@ static int pool_alloc_mem_obj(struct axdimm_allocator *alloc, uint64_t obj_idx,
 
 	user_obj_size = request->user_objects_sizes[user_obj_idx];
 	if (unlikely(!user_obj_size)) {
-		AXDIMM_ERR(
+		SLS_ERR(
 			"Memory object size is zero, user_obj_idx = [%llu]\n",
 			user_obj_idx);
 		return -EINVAL;
@@ -334,13 +334,13 @@ static int pool_alloc_mem_obj(struct axdimm_allocator *alloc, uint64_t obj_idx,
 
 	offset = gen_pool_alloc(alloc->mem_pools[rank], user_obj_size);
 	if (unlikely(!offset)) {
-		AXDIMM_ERR(
+		SLS_ERR(
 			"No free memory for user_object_id = [%llu], user_obj_size = [%llu] at pool[%hhu]\n",
 			user_obj_idx, user_obj_size, rank);
 		return -ENOMEM;
 	}
 
-	AXDIMM_DBG(
+	SLS_DBG(
 		"Allocated obj: pool[%hhu], user object index = [%llu], offset = [0x%llx], length = [%llu]\n",
 		rank, user_obj_idx, offset, user_obj_size);
 
@@ -352,8 +352,8 @@ static int pool_alloc_mem_obj(struct axdimm_allocator *alloc, uint64_t obj_idx,
 	return 0;
 }
 
-static int deallocate_objects(struct axdimm_allocator *alloc,
-			      struct axd_memory_object *objects,
+static int deallocate_objects(struct sls_allocator *alloc,
+			      struct sls_memory_object *objects,
 			      uint64_t actual_num)
 {
 	uint8_t rank;
@@ -367,7 +367,7 @@ static int deallocate_objects(struct axdimm_allocator *alloc,
 		size = objects[obj_count].length;
 		if (unlikely(!gen_pool_has_addr(alloc->mem_pools[rank], addr,
 						size))) {
-			AXDIMM_ERR(
+			SLS_ERR(
 				"Trying to deallocate object from a pool[%hhu] that doesn't contain it: addr = [%llu], size = [%llu]\n",
 				rank, addr, size);
 			err_code = -EINVAL;
@@ -379,7 +379,7 @@ static int deallocate_objects(struct axdimm_allocator *alloc,
 	return err_code;
 }
 
-static uint8_t select_optimal_rank(struct axdimm_allocator *alloc)
+static uint8_t select_optimal_rank(struct sls_allocator *alloc)
 {
 	uint8_t rank;
 	uint8_t optimal_rank = 0;
@@ -396,9 +396,9 @@ static uint8_t select_optimal_rank(struct axdimm_allocator *alloc)
 	return optimal_rank;
 }
 
-static int allocate_single_object(struct axdimm_allocator *alloc,
-				  struct axd_memory_object *objects,
-				  struct axd_memory_alloc_request *request,
+static int allocate_single_object(struct sls_allocator *alloc,
+				  struct sls_memory_object *objects,
+				  struct sls_memory_alloc_request *request,
 				  uint64_t *actual_num)
 {
 	int err_code = 0;
@@ -417,9 +417,9 @@ static int allocate_single_object(struct axdimm_allocator *alloc,
 	return err_code;
 }
 
-static int allocate_in_ranks(uint64_t num_obj, struct axdimm_allocator *alloc,
-			     struct axd_memory_object *objects,
-			     struct axd_memory_alloc_request *request,
+static int allocate_in_ranks(uint64_t num_obj, struct sls_allocator *alloc,
+			     struct sls_memory_object *objects,
+			     struct sls_memory_alloc_request *request,
 			     uint64_t *actual_num)
 {
 	uint8_t rank;
@@ -427,7 +427,7 @@ static int allocate_in_ranks(uint64_t num_obj, struct axdimm_allocator *alloc,
 	uint64_t idx, max_idx_in_rank;
 	uint64_t rank_num_obj;
 
-	if (GET_ALLOC_POLICY(request->preference) == AXDIMM_ALLOC_SINGLE) {
+	if (GET_ALLOC_POLICY(request->preference) == SLS_ALLOC_SINGLE) {
 		err_code =
 			allocate_single_object(alloc, objects, request, &idx);
 	} else {
@@ -452,10 +452,10 @@ static int allocate_in_ranks(uint64_t num_obj, struct axdimm_allocator *alloc,
 	return err_code;
 }
 
-static int allocate_objects(struct axdimm_allocator *alloc,
-			    struct axd_memory_alloc_request *request,
+static int allocate_objects(struct sls_allocator *alloc,
+			    struct sls_memory_alloc_request *request,
 			    uint64_t *desc, uint64_t num_obj,
-			    struct axd_memory_object *objects)
+			    struct sls_memory_object *objects)
 {
 	int err_code = 0;
 	uint64_t actual_num = 0;
@@ -468,20 +468,20 @@ static int allocate_objects(struct axdimm_allocator *alloc,
 					     &actual_num);
 		if (unlikely(err_code)) {
 			if (deallocate_objects(alloc, objects, actual_num))
-				AXDIMM_ERR("Failed partial deallocation\n");
+				SLS_ERR("Failed partial deallocation\n");
 			goto alloc_obj_out;
 		}
 
 		err_code = add_obj_pack(alloc, objects, num_obj);
 		if (unlikely(err_code)) {
-			AXDIMM_ERR("Failed to add objects package\n");
+			SLS_ERR("Failed to add objects package\n");
 			goto alloc_obj_out;
 		}
 
 		/* Return new descriptor to user space */
 		*desc = alloc->pack_counter;
 
-		AXDIMM_DBG(
+		SLS_DBG(
 			"Allocation succeeded, returning package descriptor = [%llu]\n",
 			*desc);
 	}
@@ -490,8 +490,8 @@ static int allocate_objects(struct axdimm_allocator *alloc,
 	return err_code;
 }
 
-static int allocate_memory(struct axdimm_allocator *alloc,
-			   struct axd_memory_alloc_request *request,
+static int allocate_memory(struct sls_allocator *alloc,
+			   struct sls_memory_alloc_request *request,
 			   uint64_t *desc)
 {
 	int err_code;
@@ -499,17 +499,17 @@ static int allocate_memory(struct axdimm_allocator *alloc,
 	 * if no issues with allocation and filling by original user objects,
 	 * it's placed into object packages storage.
 	 */
-	struct axd_memory_object *objects = NULL;
+	struct sls_memory_object *objects = NULL;
 	/* Total number of allocated objects given the user memory policy */
 	const uint64_t num_obj =
 		gen_num_obj(request->num_user_objects, request->preference);
 
-	AXDIMM_DBG("Allocating memory for %llu objects\n", num_obj);
+	SLS_DBG("Allocating memory for %llu objects\n", num_obj);
 
-	objects = kmalloc_array(num_obj, sizeof(struct axd_memory_object),
+	objects = kmalloc_array(num_obj, sizeof(struct sls_memory_object),
 				GFP_KERNEL);
 	if (unlikely(!objects)) {
-		AXDIMM_ERR("No free memory for objects, num_obj = [%llu]\n",
+		SLS_ERR("No free memory for objects, num_obj = [%llu]\n",
 			   num_obj);
 		return -ENOMEM;
 	}
@@ -521,35 +521,35 @@ static int allocate_memory(struct axdimm_allocator *alloc,
 	return err_code;
 }
 
-static int init_alloc_kreq(struct axd_memory_alloc_request *kreq,
-			   struct axd_memory_alloc_request __user *ureq)
+static int init_alloc_kreq(struct sls_memory_alloc_request *kreq,
+			   struct sls_memory_alloc_request __user *ureq)
 {
 	int err_code;
 	uint32_t array_size;
 	uint64_t *sizes_ptr = NULL;
 
-	AXDIMM_COPY_FROM_USER(err_code, kreq, ureq,
-			      sizeof(struct axd_memory_alloc_request));
+	SLS_COPY_FROM_USER(err_code, kreq, ureq,
+			      sizeof(struct sls_memory_alloc_request));
 	if (unlikely(err_code))
 		goto alloc_kreq_out;
 
 	array_size = sizeof(uint64_t) * kreq->num_user_objects;
 	/* We must check the size before kmalloc! */
 	if (unlikely(array_size == 0)) {
-		AXDIMM_ERR("Allocate request is invalid, array_size = [0]\n");
+		SLS_ERR("Allocate request is invalid, array_size = [0]\n");
 		err_code = -EINVAL;
 		goto alloc_kreq_out;
 	}
 	sizes_ptr = kreq->user_objects_sizes;
 	kreq->user_objects_sizes = kmalloc(array_size, GFP_KERNEL);
 	if (unlikely(!kreq->user_objects_sizes)) {
-		AXDIMM_ERR("kmalloc failed for array_size = [%u]\n",
+		SLS_ERR("kmalloc failed for array_size = [%u]\n",
 			   array_size);
 		err_code = -ENOMEM;
 		goto alloc_kreq_out;
 	}
 
-	AXDIMM_COPY_FROM_USER(err_code, kreq->user_objects_sizes, sizes_ptr,
+	SLS_COPY_FROM_USER(err_code, kreq->user_objects_sizes, sizes_ptr,
 			      array_size);
 	if (unlikely(err_code))
 		kfree(kreq->user_objects_sizes);
@@ -558,14 +558,14 @@ static int init_alloc_kreq(struct axd_memory_alloc_request *kreq,
 	return err_code;
 }
 
-static int allocate_memory_ioctl(struct axdimm_allocator *alloc,
+static int allocate_memory_ioctl(struct sls_allocator *alloc,
 				 unsigned long __user arg)
 {
 	int err_code;
 	uint64_t desc;
-	struct axd_memory_alloc_request kreq;
-	struct axd_memory_alloc_request __user *ureq =
-		(struct axd_memory_alloc_request __user *)arg;
+	struct sls_memory_alloc_request kreq;
+	struct sls_memory_alloc_request __user *ureq =
+		(struct sls_memory_alloc_request __user *)arg;
 
 	err_code = init_alloc_kreq(&kreq, ureq);
 	if (unlikely(err_code))
@@ -573,19 +573,19 @@ static int allocate_memory_ioctl(struct axdimm_allocator *alloc,
 
 	err_code = allocate_memory(alloc, &kreq, &desc);
 	if (unlikely(err_code)) {
-		AXDIMM_ERR("Failed to allocate memory.\n");
+		SLS_ERR("Failed to allocate memory.\n");
 		goto deinit_kreq;
 	}
 
 	err_code = put_user(desc, &ureq->descriptor);
 	if (unlikely(err_code)) {
-		AXDIMM_ERR("Can't copy allocation descriptor to user.\n");
+		SLS_ERR("Can't copy allocation descriptor to user.\n");
 		deallocate_memory(alloc, desc);
 		goto deinit_kreq;
 	}
 
 	/* descriptor is valid and copied to user, so add it to process resources */
-	err_code = axdimm_proc_register_alloc(&axdimm_proc_mgr, desc);
+	err_code = sls_proc_register_alloc(&sls_proc_mgr, desc);
 
 deinit_kreq:
 	kfree(kreq.user_objects_sizes);
@@ -593,7 +593,7 @@ static int allocate_memory_ioctl(struct axdimm_allocator *alloc,
 	return err_code;
 }
 
-static int get_num_obj(struct axdimm_allocator *alloc, uint64_t desc,
+static int get_num_obj(struct sls_allocator *alloc, uint64_t desc,
 		       uint64_t *num_obj)
 {
 	int err_code = -EINVAL;
@@ -611,7 +611,7 @@ static int get_num_obj(struct axdimm_allocator *alloc, uint64_t desc,
 			pack = list_entry(ptr, struct obj_pack, list);
 			if (pack->desc == desc) {
 				*num_obj = pack->num_obj;
-				AXDIMM_DBG("Number of objects: [%llu]\n",
+				SLS_DBG("Number of objects: [%llu]\n",
 					   *num_obj);
 				err_code = 0;
 				goto unlock_num_obj;
@@ -625,46 +625,46 @@ static int get_num_obj(struct axdimm_allocator *alloc, uint64_t desc,
 	return err_code;
 }
 
-static int get_num_obj_ioctl(struct axdimm_allocator *alloc,
+static int get_num_obj_ioctl(struct sls_allocator *alloc,
 			     unsigned long __user arg)
 {
 	int err_code;
 	uint64_t num_obj;
-	struct axd_num_objects_request __user *usr_get_num_obj_req =
-		(struct axd_num_objects_request __user *)arg;
-	struct axd_num_objects_request kernel_get_num_obj_req = {};
+	struct sls_num_objects_request __user *usr_get_num_obj_req =
+		(struct sls_num_objects_request __user *)arg;
+	struct sls_num_objects_request kernel_get_num_obj_req = {};
 
-	AXDIMM_COPY_FROM_USER(err_code, &kernel_get_num_obj_req,
+	SLS_COPY_FROM_USER(err_code, &kernel_get_num_obj_req,
 			      usr_get_num_obj_req,
-			      sizeof(struct axd_num_objects_request));
+			      sizeof(struct sls_num_objects_request));
 	if (unlikely(err_code))
 		goto out_num_obj_ioctl;
 
 	err_code =
 		get_num_obj(alloc, kernel_get_num_obj_req.descriptor, &num_obj);
 	if (unlikely(err_code)) {
-		AXDIMM_ERR(
+		SLS_ERR(
 			"Can't get number of objects by objects package descriptor [%llu]\n",
 			kernel_get_num_obj_req.descriptor);
 		goto out_num_obj_ioctl;
 	}
 
 	kernel_get_num_obj_req.num_objects = num_obj;
-	AXDIMM_COPY_TO_USER(err_code, usr_get_num_obj_req,
+	SLS_COPY_TO_USER(err_code, usr_get_num_obj_req,
 			    &kernel_get_num_obj_req,
-			    sizeof(struct axd_num_objects_request));
+			    sizeof(struct sls_num_objects_request));
 out_num_obj_ioctl:
 	return err_code;
 }
 
-static int get_obj_pack(struct axdimm_allocator *alloc,
-			struct axd_memory_alloc *request)
+static int get_obj_pack(struct sls_allocator *alloc,
+			struct sls_memory_alloc *request)
 {
 	int err_code = -EINVAL;
 	struct list_head *ptr;
 	struct obj_pack *pack;
 
-	AXDIMM_DBG("Getting allocation for descriptor %llu\n",
+	SLS_DBG("Getting allocation for descriptor %llu\n",
 		   request->descriptor);
 	if (unlikely(request->descriptor == 0))
 		goto out;
@@ -677,16 +677,16 @@ static int get_obj_pack(struct axdimm_allocator *alloc,
 			pack = list_entry(ptr, struct obj_pack, list);
 			if (pack->desc == request->descriptor) {
 				if (request->num_objects < pack->num_obj) {
-					AXDIMM_ERR(
+					SLS_ERR(
 						"The output memory size is too small to store the [%llu] package objects\n",
 						pack->num_obj);
 					goto unlock;
 				}
-				AXDIMM_COPY_TO_USER(
+				SLS_COPY_TO_USER(
 					err_code, request->objects,
 					pack->objects,
 					pack->num_obj *
-						sizeof(struct axd_memory_object));
+						sizeof(struct sls_memory_object));
 				goto unlock;
 			}
 		}
@@ -697,38 +697,38 @@ static int get_obj_pack(struct axdimm_allocator *alloc,
 	return err_code;
 }
 
-static int get_obj_pack_ioctl(struct axdimm_allocator *alloc,
+static int get_obj_pack_ioctl(struct sls_allocator *alloc,
 			      unsigned long __user arg)
 {
 	int err_code;
-	struct axd_memory_alloc __user *usr_get_alloc_req =
-		(struct axd_memory_alloc __user *)arg;
-	struct axd_memory_alloc kernel_get_alloc_req = {};
+	struct sls_memory_alloc __user *usr_get_alloc_req =
+		(struct sls_memory_alloc __user *)arg;
+	struct sls_memory_alloc kernel_get_alloc_req = {};
 
-	AXDIMM_COPY_FROM_USER(err_code, &kernel_get_alloc_req,
+	SLS_COPY_FROM_USER(err_code, &kernel_get_alloc_req,
 			      usr_get_alloc_req,
-			      sizeof(struct axd_memory_alloc));
+			      sizeof(struct sls_memory_alloc));
 	if (unlikely(err_code))
 		goto get_pack_out;
 	err_code = get_obj_pack(alloc, &kernel_get_alloc_req);
 	if (unlikely(err_code))
-		AXDIMM_ERR("Can't get objects package by descriptor [%llu]\n",
+		SLS_ERR("Can't get objects package by descriptor [%llu]\n",
 			   kernel_get_alloc_req.descriptor);
 
 get_pack_out:
 	return err_code;
 }
 
-int deallocate_memory(struct axdimm_allocator *alloc, uint64_t desc)
+int deallocate_memory(struct sls_allocator *alloc, uint64_t desc)
 {
 	int err_code = -EINVAL;
 	struct list_head *cur, *n;
 	struct obj_pack *pack;
 
-	AXDIMM_DBG("Deallocating memory (descriptor = [%llu])\n", desc);
+	SLS_DBG("Deallocating memory (descriptor = [%llu])\n", desc);
 
 	if (unlikely(desc == 0)) {
-		AXDIMM_ERR("Memory package descriptor is zero!!!\n");
+		SLS_ERR("Memory package descriptor is zero!!!\n");
 		goto out;
 	}
 
@@ -744,7 +744,7 @@ int deallocate_memory(struct axdimm_allocator *alloc, uint64_t desc)
 			err_code = deallocate_objects(alloc, pack->objects,
 						      pack->num_obj);
 			if (err_code) {
-				AXDIMM_ERR(
+				SLS_ERR(
 					"Failed to deallocate memory by descriptor [%llu]\n",
 					desc);
 			}
@@ -762,7 +762,7 @@ int deallocate_memory(struct axdimm_allocator *alloc, uint64_t desc)
 	return err_code;
 }
 
-static int deallocate_memory_ioctl(struct axdimm_allocator *alloc,
+static int deallocate_memory_ioctl(struct sls_allocator *alloc,
 				   unsigned long __user arg)
 {
 	uint64_t in_desc = (uint64_t)arg;
@@ -771,10 +771,10 @@ static int deallocate_memory_ioctl(struct axdimm_allocator *alloc,
 	if (unlikely(err_code))
 		return err_code;
 
-	return axdimm_proc_remove_alloc(&axdimm_proc_mgr, in_desc);
+	return sls_proc_remove_alloc(&sls_proc_mgr, in_desc);
 }
 
-int mem_process_ioctl(unsigned int cmd, struct axdimm_allocator *alloc,
+int mem_process_ioctl(unsigned int cmd, struct sls_allocator *alloc,
 		      unsigned long __user arg)
 {
 	switch (cmd) {
@@ -787,7 +787,7 @@ int mem_process_ioctl(unsigned int cmd, struct axdimm_allocator *alloc,
 	case DEALLOCATE_MEMORY:
 		return deallocate_memory_ioctl(alloc, arg);
 	default:
-		AXDIMM_ERR(
+		SLS_ERR(
 			"Unknown memory operation [%u], with argument [%lu]\n",
 			cmd, arg);
 	}
diff --git a/drivers/pnm/axdimm_resource/axdimm_allocator.h b/drivers/pnm/sls_resource/sls_allocator.h
similarity index 69%
rename from drivers/pnm/axdimm_resource/axdimm_allocator.h
rename to drivers/pnm/sls_resource/sls_allocator.h
index 62d85e418..ee3f4a8f3 100644
--- a/drivers/pnm/axdimm_resource/axdimm_allocator.h
+++ b/drivers/pnm/sls_resource/sls_allocator.h
@@ -1,15 +1,15 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /* Copyright(c) 2022 Samsung LTD. All rights reserved. */
 
-#ifndef __AXDIMM_ALLOCATOR_H__
-#define __AXDIMM_ALLOCATOR_H__
+#ifndef __SLS_ALLOCATOR_H__
+#define __SLS_ALLOCATOR_H__
 
-#include <linux/libaxdimm.h>
+#include <linux/sls_resources.h>
 #include <linux/list.h>
 #include <linux/types.h>
 
-struct axdimm_dev;
-struct axdmem_info;
+struct sls_dev;
+struct sls_mem_info;
 
 /*
  * Element of the list with memory object packages.
@@ -24,13 +24,13 @@ struct obj_pack {
 	/* Number of memory objects */
 	uint64_t num_obj;
 	/* Memory objects array */
-	struct axd_memory_object *objects;
+	struct sls_memory_object *objects;
 	/* Embedded for using lists only */
 	struct list_head list;
 };
 
 /* Helper structure for memory allocation */
-struct axdimm_allocator {
+struct sls_allocator {
 	/* Allocator granularity in bytes, the number should be a power of 2 */
 	uint64_t gran;
 	/* GenAlloc memory pools for each rank, each pool has it's own virtual
@@ -47,20 +47,20 @@ struct axdimm_allocator {
 	uint64_t pack_counter;
 };
 
-int init_axdimm_allocator(struct axdimm_dev *dev);
+int init_sls_allocator(struct sls_dev *dev);
 /*
  * Not proccess(thread)-safe.
  * `mem_info` might be NULL, if it is
  * then just reset allocator, if it's not
  * then reset with memory pools initialization.
  */
-int reset_axdimm_allocator(struct axdimm_allocator *alloc,
-			   struct axdmem_info *mem_info);
-void cleanup_axdimm_allocator(struct axdimm_dev *dev);
-int mem_process_ioctl(unsigned int cmd, struct axdimm_allocator *alloc,
+int reset_sls_allocator(struct sls_allocator *alloc,
+			   struct sls_mem_info *mem_info);
+void cleanup_sls_allocator(struct sls_dev *dev);
+int mem_process_ioctl(unsigned int cmd, struct sls_allocator *alloc,
 		      unsigned long __user arg);
-int deallocate_memory(struct axdimm_allocator *alloc, uint64_t desc);
-void lock_allocator(struct axdimm_allocator *alloc);
-void unlock_allocator(struct axdimm_allocator *alloc);
+int deallocate_memory(struct sls_allocator *alloc, uint64_t desc);
+void lock_allocator(struct sls_allocator *alloc);
+void unlock_allocator(struct sls_allocator *alloc);
 
-#endif /* __AXDIMM_ALLOCATOR_H__ */
+#endif /* __SLS_ALLOCATOR_H__ */
diff --git a/drivers/pnm/sls_resource/sls_log.h b/drivers/pnm/sls_resource/sls_log.h
new file mode 100644
index 000000000..4dcc04111
--- /dev/null
+++ b/drivers/pnm/sls_resource/sls_log.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2022-2023 Samsung LTD. All rights reserved. */
+
+#ifndef __SLS_LOG_H__
+#define __SLS_LOG_H__
+
+#include <linux/kernel.h>
+
+#define SLS_DD_MARK "[DAX_SLS_DD]"
+
+#define SLS_PRINT(level, fmt, ...)                                          \
+	pr_##level(SLS_DD_MARK "[%s:%d] " fmt, __FILE__, __LINE__,          \
+	       ##__VA_ARGS__)
+#define SLS_ERR(fmt, ...) SLS_PRINT(err, fmt, ##__VA_ARGS__)
+#define SLS_WRN(fmt, ...) SLS_PRINT(warn, fmt, ##__VA_ARGS__)
+#define SLS_INF(fmt, ...) SLS_PRINT(info, fmt, ##__VA_ARGS__)
+#define SLS_DBG(fmt, ...) SLS_PRINT(debug, fmt, ##__VA_ARGS__)
+
+#endif /* __SLS_LOG_H__ */
diff --git a/drivers/pnm/sls_resource/sls_private.h b/drivers/pnm/sls_resource/sls_private.h
new file mode 100644
index 000000000..3ec5d8e07
--- /dev/null
+++ b/drivers/pnm/sls_resource/sls_private.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2021-2023 Samsung LTD. All rights reserved. */
+
+#ifndef __SLS_PRIVATE_H__
+#define __SLS_PRIVATE_H__
+
+#include "sls_log.h"
+
+#include <linux/sls_common.h>
+#include <linux/cdev.h>
+#include <linux/compiler.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/semaphore.h>
+#include <linux/types.h>
+#include <linux/kobject.h>
+
+#define SLS_COPY_FROM_TO_USER(func, error, dst, src, size)        \
+	do {                                                         \
+		error = func(dst, src, size) ? -EFAULT : 0;          \
+		if (unlikely(error)) {                               \
+			SLS_ERR("Can't copy '" #src "' to '" #dst \
+				   "' in '" #func "'\n");            \
+		}                                                    \
+	} while (0)
+#define SLS_COPY_FROM_USER(error, dst, src, size) \
+	SLS_COPY_FROM_TO_USER(copy_from_user, error, dst, src, size)
+#define SLS_COPY_TO_USER(error, dst, src, size) \
+	SLS_COPY_FROM_TO_USER(copy_to_user, error, dst, src, size)
+
+/* Just sizeof(array) with static array check */
+#define SIZEOF_ARRAY(arr) (sizeof(arr) + __must_be_array(arr))
+
+struct sls_device_data {
+	int rank;
+	int region;
+	int channel;
+};
+
+struct sls_allocator;
+
+struct sls_dev {
+	struct sls_mem_info mem_info; /* memory info */
+	struct sls_allocator *allocator;
+};
+
+static inline int is_sls_range(u64 start, u64 end)
+{
+	return start >= SLS_BASE_ADDR &&
+	       end < SLS_BASE_ADDR + SLS_MEMORY_SIZE;
+}
+
+void cleanup_sls_device(void);
+
+long sls_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+
+int sls_release(struct inode *node, struct file *f);
+int sls_open(struct inode *inode, struct file *filp);
+
+#endif
+
+/* __SLS_PRIVATE_H__ */
diff --git a/drivers/pnm/axdimm_resource/axdimm_process_manager.c b/drivers/pnm/sls_resource/sls_process_manager.c
similarity index 71%
rename from drivers/pnm/axdimm_resource/axdimm_process_manager.c
rename to drivers/pnm/sls_resource/sls_process_manager.c
index ffe1e9b4e..d979fbdd1 100644
--- a/drivers/pnm/axdimm_resource/axdimm_process_manager.c
+++ b/drivers/pnm/sls_resource/sls_process_manager.c
@@ -1,10 +1,10 @@
 // SPDX-License-Identifier: GPL-2.0
 /* Copyright(c) 2022 Samsung LTD. All rights reserved. */
 
-#include "axdimm_process_manager.h"
-#include "axdimm_rank_scheduler.h"
-#include "axdimm_allocator.h"
-#include "axdimm_log.h"
+#include "sls_process_manager.h"
+#include "sls_rank_scheduler.h"
+#include "sls_allocator.h"
+#include "sls_log.h"
 
 #include <linux/sched/signal.h>
 #include <linux/slab.h>
@@ -37,10 +37,10 @@ static pid_t get_current_process_id(void)
 }
 
 /* this function should be called with sync */
-static struct axdimm_proc_resources *
-find_current_proc_res(struct axdimm_process_manager *mgr)
+static struct sls_proc_resources *
+find_current_proc_res(struct sls_process_manager *mgr)
 {
-	struct axdimm_proc_resources *proc_res;
+	struct sls_proc_resources *proc_res;
 	pid_t pid = get_current_process_id();
 
 	list_for_each_entry(proc_res, &mgr->active_process_list, list) {
@@ -51,41 +51,41 @@ find_current_proc_res(struct axdimm_process_manager *mgr)
 	return NULL;
 }
 
-static bool has_resources_leaked(struct axdimm_proc_resources *proc_res)
+static bool has_resources_leaked(struct sls_proc_resources *proc_res)
 {
 	return proc_res->rank_write_mask || proc_res->rank_read_mask ||
 	       !list_empty(&proc_res->alloc_desc_list);
 }
 
-static void track_leaked_resources(struct axdimm_process_manager *mgr,
-				   struct axdimm_proc_resources *proc_res)
+static void track_leaked_resources(struct sls_process_manager *mgr,
+				   struct sls_proc_resources *proc_res)
 {
-	struct axdimm_proc_desc *proc_desc;
+	struct sls_proc_desc *proc_desc;
 
 	atomic64_inc(&mgr->leaked);
 	list_move(&proc_res->list, &mgr->leaked_process_list);
 
-	AXDIMM_DBG("Tracked leakage by pid: %d, tid: %d; rank_rw_mask: %d, rank_rd_mask: %d\n",
+	SLS_DBG("Tracked leakage by pid: %d, tid: %d; rank_rw_mask: %d, rank_rd_mask: %d\n",
 		   get_current_process_id(), current->pid,
 		   proc_res->rank_write_mask, proc_res->rank_read_mask);
 
 	list_for_each_entry(proc_desc, &proc_res->alloc_desc_list, list) {
-		AXDIMM_DBG("Leaked memory under desc[%lld]\n",
+		SLS_DBG("Leaked memory under desc[%lld]\n",
 			   proc_desc->alloc_desc);
 	}
 }
 
-static int release_process_resources(struct axdimm_proc_resources *proc_res,
-				     struct axdimm_allocator *alloc,
-				     struct axdimm_rank_scheduler *rank_sched)
+static int release_process_resources(struct sls_proc_resources *proc_res,
+				     struct sls_allocator *alloc,
+				     struct sls_rank_scheduler *rank_sched)
 {
 	/* in base case scenario the resources above should be already
 	 * released, but we need to check in case we are on
 	 * 'killed process' path
 	 */
 	int i;
-	struct axdimm_proc_desc *proc_desc;
-	struct axdimm_proc_desc *proc_desc_tmp;
+	struct sls_proc_desc *proc_desc;
+	struct sls_proc_desc *proc_desc_tmp;
 	bool failed = false;
 
 	/* handle unreleased ranks */
@@ -93,7 +93,7 @@ static int release_process_resources(struct axdimm_proc_resources *proc_res,
 		if (proc_res->rank_write_mask & (1 << i)) {
 			failed |= (release_rank_write(rank_sched, i) != i);
 			proc_res->rank_write_mask &= ~(1 << i);
-			AXDIMM_INF(
+			SLS_INF(
 				"Abnormal release rank_wr[%d], pid: %d, tid: %d\n",
 				i, get_current_process_id(), current->pid);
 		}
@@ -101,7 +101,7 @@ static int release_process_resources(struct axdimm_proc_resources *proc_res,
 		if (proc_res->rank_read_mask & (1 << i)) {
 			failed |= (release_rank_read(rank_sched, i) != i);
 			proc_res->rank_read_mask &= ~(1 << i);
-			AXDIMM_INF(
+			SLS_INF(
 				"Abnormal release rank_rd[%d], pid: %d, tid: %d\n",
 				i, get_current_process_id(), current->pid);
 		}
@@ -112,7 +112,7 @@ static int release_process_resources(struct axdimm_proc_resources *proc_res,
 				 &proc_res->alloc_desc_list, list) {
 		failed |=
 			(deallocate_memory(alloc, proc_desc->alloc_desc) != 0);
-		AXDIMM_INF("Abnormal release desc[%lld], pid: %d, tid: %d\n",
+		SLS_INF("Abnormal release desc[%lld], pid: %d, tid: %d\n",
 			   proc_desc->alloc_desc, get_current_process_id(),
 			   current->pid);
 		list_del(&proc_desc->list);
@@ -122,12 +122,12 @@ static int release_process_resources(struct axdimm_proc_resources *proc_res,
 	return failed ? -1 : 0;
 }
 
-int release_axdimm_process(struct axdimm_process_manager *mgr,
-			   struct axdimm_allocator *alloc,
-			   struct axdimm_rank_scheduler *rank_sched)
+int release_sls_process(struct sls_process_manager *mgr,
+			   struct sls_allocator *alloc,
+			   struct sls_rank_scheduler *rank_sched)
 {
 	int err_code = 0;
-	struct axdimm_proc_resources *proc_res = NULL;
+	struct sls_proc_resources *proc_res = NULL;
 	bool res_leaked;
 
 	mutex_lock(&mgr->proc_list_lock);
@@ -138,7 +138,7 @@ int release_axdimm_process(struct axdimm_process_manager *mgr,
 		proc_res = find_current_proc_res(mgr);
 
 		if (!proc_res) {
-			AXDIMM_ERR(
+			SLS_ERR(
 				"Tried to release already released process by pid: %d, tid: %d\n",
 				get_current_process_id(), current->pid);
 			goto release_process_unlock;
@@ -150,7 +150,7 @@ int release_axdimm_process(struct axdimm_process_manager *mgr,
 		 *   - process got finished abnormally
 		 */
 		if (proc_res->ref_cnt == 0) {
-			AXDIMM_DBG("Releasing process pid: %d, tid: %d\n",
+			SLS_DBG("Releasing process pid: %d, tid: %d\n",
 				   get_current_process_id(), current->pid);
 
 			res_leaked = has_resources_leaked(proc_res);
@@ -176,13 +176,13 @@ int release_axdimm_process(struct axdimm_process_manager *mgr,
 	return err_code;
 }
 
-static int set_rank_status(struct axdimm_process_manager *mgr,
+static int set_rank_status(struct sls_process_manager *mgr,
 			   enum rank_access_type type, int rank, bool set)
 {
 	int *rank_mask;
 	int mask_tmp;
 	int err_code = 0;
-	struct axdimm_proc_resources *proc_res = NULL;
+	struct sls_proc_resources *proc_res = NULL;
 
 	mutex_lock(&mgr->proc_list_lock);
 	{
@@ -209,21 +209,21 @@ static int set_rank_status(struct axdimm_process_manager *mgr,
 	return err_code;
 }
 
-int axdimm_proc_register_rank(struct axdimm_process_manager *mgr, int rank,
+int sls_proc_register_rank(struct sls_process_manager *mgr, int rank,
 			      unsigned int cmd)
 {
 	enum rank_access_type rank_type = get_rank_access_type(cmd);
 
 	if (unlikely(rank_type == RANK_ACCESS_INVAL)) {
-		AXDIMM_ERR("Unknown rank type\n");
+		SLS_ERR("Unknown rank type\n");
 		return -1;
 	}
 
-	AXDIMM_DBG("Registering rank_%s[%d], pid: %d, tid: %d\n",
+	SLS_DBG("Registering rank_%s[%d], pid: %d, tid: %d\n",
 		   rank_access_type_to_str(rank_type), rank,
 		   get_current_process_id(), current->pid);
 	if (set_rank_status(mgr, rank_type, rank, true)) {
-		AXDIMM_ERR("Fail to register rank_%s[%d], pid: %d, tid: %d\n",
+		SLS_ERR("Fail to register rank_%s[%d], pid: %d, tid: %d\n",
 			   rank_access_type_to_str(rank_type), rank,
 			   get_current_process_id(), current->pid);
 		return -1;
@@ -231,21 +231,21 @@ int axdimm_proc_register_rank(struct axdimm_process_manager *mgr, int rank,
 	return 0;
 }
 
-int axdimm_proc_remove_rank(struct axdimm_process_manager *mgr, int rank,
+int sls_proc_remove_rank(struct sls_process_manager *mgr, int rank,
 			    unsigned int cmd)
 {
 	int rank_type = get_rank_access_type(cmd);
 
 	if (unlikely(rank_type == RANK_ACCESS_INVAL)) {
-		AXDIMM_ERR("Unknown rank type\n");
+		SLS_ERR("Unknown rank type\n");
 		return -1;
 	}
 
-	AXDIMM_DBG("Removing rank_%s[%d], pid: %d, tid: %d\n",
+	SLS_DBG("Removing rank_%s[%d], pid: %d, tid: %d\n",
 		   rank_access_type_to_str(rank_type), rank,
 		   get_current_process_id(), current->pid);
 	if (set_rank_status(mgr, rank_type, rank, false)) {
-		AXDIMM_ERR("Fail to remove rank_%s[%d], pid: %d, tid: %d\n",
+		SLS_ERR("Fail to remove rank_%s[%d], pid: %d, tid: %d\n",
 			   rank_access_type_to_str(rank_type), rank,
 			   get_current_process_id(), current->pid);
 		return -1;
@@ -253,13 +253,13 @@ int axdimm_proc_remove_rank(struct axdimm_process_manager *mgr, int rank,
 	return 0;
 }
 
-static int update_descriptor_status(struct axdimm_process_manager *mgr,
+static int update_descriptor_status(struct sls_process_manager *mgr,
 				    uint64_t desc, bool is_registration)
 {
-	struct axdimm_proc_desc *proc_desc_tmp;
+	struct sls_proc_desc *proc_desc_tmp;
 	int err_code = 0;
-	struct axdimm_proc_resources *proc_res = NULL;
-	struct axdimm_proc_desc *proc_desc = NULL;
+	struct sls_proc_resources *proc_res = NULL;
+	struct sls_proc_desc *proc_desc = NULL;
 
 	mutex_lock(&mgr->proc_list_lock);
 	{
@@ -274,7 +274,7 @@ static int update_descriptor_status(struct axdimm_process_manager *mgr,
 		}
 
 		if (is_registration) { /* allocate and add descritor to descriptors list */
-			proc_desc = kzalloc(sizeof(struct axdimm_proc_desc),
+			proc_desc = kzalloc(sizeof(struct sls_proc_desc),
 					    GFP_KERNEL);
 
 			if (proc_desc == NULL) {
@@ -300,47 +300,47 @@ static int update_descriptor_status(struct axdimm_process_manager *mgr,
 	return err_code;
 }
 
-static int register_descriptor(struct axdimm_process_manager *mgr,
+static int register_descriptor(struct sls_process_manager *mgr,
 			       uint64_t desc)
 {
 	return update_descriptor_status(mgr, desc, true);
 }
 
-static int unregister_descriptor(struct axdimm_process_manager *mgr,
+static int unregister_descriptor(struct sls_process_manager *mgr,
 				 uint64_t desc)
 {
 	return update_descriptor_status(mgr, desc, false);
 }
 
-int axdimm_proc_register_alloc(struct axdimm_process_manager *mgr,
+int sls_proc_register_alloc(struct sls_process_manager *mgr,
 			       uint64_t desc)
 {
-	AXDIMM_DBG("Registering allocation, desc[%lld], pid: %d, tid: %d\n",
+	SLS_DBG("Registering allocation, desc[%lld], pid: %d, tid: %d\n",
 		   desc, get_current_process_id(), current->pid);
 	if (register_descriptor(mgr, desc)) {
-		AXDIMM_ERR("Fail to register desc: %lld, pid: %d, tid: %d\n",
+		SLS_ERR("Fail to register desc: %lld, pid: %d, tid: %d\n",
 			   desc, get_current_process_id(), current->pid);
 		return -1;
 	}
 	return 0;
 }
 
-int axdimm_proc_remove_alloc(struct axdimm_process_manager *mgr, uint64_t desc)
+int sls_proc_remove_alloc(struct sls_process_manager *mgr, uint64_t desc)
 {
-	AXDIMM_DBG("Removing allocation, desc[%lld], pid: %d, tid: %d\n", desc,
+	SLS_DBG("Removing allocation, desc[%lld], pid: %d, tid: %d\n", desc,
 		   get_current_process_id(), current->pid);
 	if (unregister_descriptor(mgr, desc)) {
-		AXDIMM_ERR("Fail to remove desc: %lld, pid: %d, tid: %d\n",
+		SLS_ERR("Fail to remove desc: %lld, pid: %d, tid: %d\n",
 			   desc, get_current_process_id(), current->pid);
 		return -1;
 	}
 	return 0;
 }
 
-int register_axdimm_process(struct axdimm_process_manager *mgr)
+int register_sls_process(struct sls_process_manager *mgr)
 {
 	int err_code = 0;
-	struct axdimm_proc_resources *proc_res = NULL;
+	struct sls_proc_resources *proc_res = NULL;
 	pid_t pid = get_current_process_id();
 
 	mutex_lock(&mgr->proc_list_lock);
@@ -353,11 +353,11 @@ int register_axdimm_process(struct axdimm_process_manager *mgr)
 		if (proc_res)
 			goto inc_ref_count;
 
-		proc_res = kzalloc(sizeof(struct axdimm_proc_resources),
+		proc_res = kzalloc(sizeof(struct sls_proc_resources),
 				   GFP_KERNEL);
 
 		if (!proc_res) {
-			AXDIMM_ERR(
+			SLS_ERR(
 				"Failed to register process, pid: %d, tid: %d\n",
 				pid, current->pid);
 			err_code = -ENOMEM;
@@ -367,7 +367,7 @@ int register_axdimm_process(struct axdimm_process_manager *mgr)
 		proc_res->pid = pid;
 		INIT_LIST_HEAD(&proc_res->alloc_desc_list);
 		list_add(&proc_res->list, &mgr->active_process_list);
-		AXDIMM_DBG("Registered process, pid: %d, tid: %d\n", pid,
+		SLS_DBG("Registered process, pid: %d, tid: %d\n", pid,
 			   current->pid);
 
 inc_ref_count:
@@ -378,15 +378,15 @@ int register_axdimm_process(struct axdimm_process_manager *mgr)
 	return err_code;
 }
 
-int axdimm_proc_manager_cleanup_on(struct axdimm_process_manager *mgr,
-				   struct axdimm_allocator *alloc,
-				   struct axdimm_rank_scheduler *rank_sched)
+int sls_proc_manager_cleanup_on(struct sls_process_manager *mgr,
+				   struct sls_allocator *alloc,
+				   struct sls_rank_scheduler *rank_sched)
 {
-	struct axdimm_proc_resources *proc_res_tmp;
-	struct axdimm_proc_resources *proc_res;
+	struct sls_proc_resources *proc_res_tmp;
+	struct sls_proc_resources *proc_res;
 	int err_code = 0;
 
-	AXDIMM_DBG("Enabling cleanup\n");
+	SLS_DBG("Enabling cleanup\n");
 
 	atomic64_set(&mgr->enable_cleanup, 1);
 
@@ -410,16 +410,16 @@ int axdimm_proc_manager_cleanup_on(struct axdimm_process_manager *mgr,
 	return err_code ? -1 : 0;
 }
 
-void axdimm_proc_manager_cleanup_off(struct axdimm_process_manager *mgr)
+void sls_proc_manager_cleanup_off(struct sls_process_manager *mgr)
 {
-	AXDIMM_DBG("Disabling cleanup\n");
+	SLS_DBG("Disabling cleanup\n");
 	atomic64_set(&mgr->enable_cleanup, 0);
 }
 
 void cleanup_process_list(struct list_head *process_list)
 {
-	struct axdimm_proc_resources *proc_res_tmp;
-	struct axdimm_proc_resources *proc_res;
+	struct sls_proc_resources *proc_res_tmp;
+	struct sls_proc_resources *proc_res;
 
 	list_for_each_entry_safe(proc_res, proc_res_tmp, process_list, list) {
 		list_del(&proc_res->list);
@@ -427,16 +427,16 @@ void cleanup_process_list(struct list_head *process_list)
 	}
 }
 
-void reset_axdimm_process_manager(struct axdimm_process_manager *mgr)
+void reset_sls_process_manager(struct sls_process_manager *mgr)
 {
 	cleanup_process_list(&mgr->active_process_list);
 	cleanup_process_list(&mgr->leaked_process_list);
 }
 
-void cleanup_axdimm_process_manager(struct axdimm_process_manager *mgr)
+void cleanup_sls_process_manager(struct sls_process_manager *mgr)
 {
-	struct axdimm_proc_resources *proc_res_tmp;
-	struct axdimm_proc_resources *proc_res;
+	struct sls_proc_resources *proc_res_tmp;
+	struct sls_proc_resources *proc_res;
 
 	mutex_lock(&mgr->proc_list_lock);
 	{
@@ -452,7 +452,7 @@ void cleanup_axdimm_process_manager(struct axdimm_process_manager *mgr)
 	mutex_unlock(&mgr->proc_list_lock);
 }
 
-void init_axdimm_process_manager(struct axdimm_process_manager *mgr)
+void init_sls_process_manager(struct sls_process_manager *mgr)
 {
 	INIT_LIST_HEAD(&mgr->active_process_list);
 	INIT_LIST_HEAD(&mgr->leaked_process_list);
diff --git a/drivers/pnm/axdimm_resource/axdimm_process_manager.h b/drivers/pnm/sls_resource/sls_process_manager.h
similarity index 55%
rename from drivers/pnm/axdimm_resource/axdimm_process_manager.h
rename to drivers/pnm/sls_resource/sls_process_manager.h
index d51b147e5..acac2940f 100644
--- a/drivers/pnm/axdimm_resource/axdimm_process_manager.h
+++ b/drivers/pnm/sls_resource/sls_process_manager.h
@@ -1,23 +1,23 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /* Copyright(c) 2022 Samsung LTD. All rights reserved. */
 
-#ifndef __AXDIMM_PROCESS_MANAGER_H__
-#define __AXDIMM_PROCESS_MANAGER_H__
+#ifndef __SLS_PROCESS_MANAGER_H__
+#define __SLS_PROCESS_MANAGER_H__
 
-#include "axdimm_rank_scheduler.h"
-#include "axdimm_allocator.h"
+#include "sls_rank_scheduler.h"
+#include "sls_allocator.h"
 
 #include <linux/mutex.h>
 #include <linux/list.h>
 
 /* list of descriptors held by process */
-struct axdimm_proc_desc {
+struct sls_proc_desc {
 	uint64_t alloc_desc;
 	struct list_head list;
 };
 
 /* resources allocated for particular process */
-struct axdimm_proc_resources {
+struct sls_proc_resources {
 	int pid;
 	/* [TODO:] need to checkout performance impact of using just list,
 	 * maybe some more advanced data structure is required (rb_tree)
@@ -38,7 +38,7 @@ struct axdimm_proc_resources {
  * data structure for tracking device resources, allocated to user space
  * processes
  */
-struct axdimm_process_manager {
+struct sls_process_manager {
 	/* [TODO:] need to checkout performance impact of using just list,
 	 * maybe some more advanced data structure is required (rb_tree)
 	 */
@@ -50,33 +50,33 @@ struct axdimm_process_manager {
 	struct mutex proc_list_lock;
 };
 
-/* We have circle dependence with axdimm allocator */
-struct axdimm_allocator;
+/* We have circle dependence with sls allocator */
+struct sls_allocator;
 
-void init_axdimm_process_manager(struct axdimm_process_manager *mgr);
-void cleanup_axdimm_process_manager(struct axdimm_process_manager *mgr);
-void reset_axdimm_process_manager(struct axdimm_process_manager *mgr);
+void init_sls_process_manager(struct sls_process_manager *mgr);
+void cleanup_sls_process_manager(struct sls_process_manager *mgr);
+void reset_sls_process_manager(struct sls_process_manager *mgr);
 /* function for handling 'open' file operation */
-int register_axdimm_process(struct axdimm_process_manager *mgr);
+int register_sls_process(struct sls_process_manager *mgr);
 /* function for handling 'release' file operation */
-int release_axdimm_process(struct axdimm_process_manager *mgr,
-			   struct axdimm_allocator *alloc,
-			   struct axdimm_rank_scheduler *rank_sched);
+int release_sls_process(struct sls_process_manager *mgr,
+			   struct sls_allocator *alloc,
+			   struct sls_rank_scheduler *rank_sched);
 
 /* functions for adding allocation/ranks into process's resources data structure*/
-int axdimm_proc_register_alloc(struct axdimm_process_manager *mgr,
+int sls_proc_register_alloc(struct sls_process_manager *mgr,
 			       uint64_t desc);
-int axdimm_proc_register_rank(struct axdimm_process_manager *mgr, int rank,
+int sls_proc_register_rank(struct sls_process_manager *mgr, int rank,
 			      unsigned int cmd);
 
 /* function for removing allocation/ranks from process's resources data structure*/
-int axdimm_proc_remove_alloc(struct axdimm_process_manager *mgr, uint64_t desc);
-int axdimm_proc_remove_rank(struct axdimm_process_manager *mgr, int rank,
+int sls_proc_remove_alloc(struct sls_process_manager *mgr, uint64_t desc);
+int sls_proc_remove_rank(struct sls_process_manager *mgr, int rank,
 			    unsigned int cmd);
 
-int axdimm_proc_manager_cleanup_on(struct axdimm_process_manager *mgr,
-				   struct axdimm_allocator *alloc,
-				   struct axdimm_rank_scheduler *rank_sched);
-void axdimm_proc_manager_cleanup_off(struct axdimm_process_manager *mgr);
+int sls_proc_manager_cleanup_on(struct sls_process_manager *mgr,
+				   struct sls_allocator *alloc,
+				   struct sls_rank_scheduler *rank_sched);
+void sls_proc_manager_cleanup_off(struct sls_process_manager *mgr);
 
-#endif /* __AXDIMM_PROCESS_MANAGER_H__ */
+#endif /* __SLS_PROCESS_MANAGER_H__ */
diff --git a/drivers/pnm/axdimm_resource/axdimm_rank_scheduler.c b/drivers/pnm/sls_resource/sls_rank_scheduler.c
similarity index 65%
rename from drivers/pnm/axdimm_resource/axdimm_rank_scheduler.c
rename to drivers/pnm/sls_resource/sls_rank_scheduler.c
index 56e1531d0..79752150f 100644
--- a/drivers/pnm/axdimm_resource/axdimm_rank_scheduler.c
+++ b/drivers/pnm/sls_resource/sls_rank_scheduler.c
@@ -1,9 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0
 /* Copyright(c) 2022 Samsung LTD. All rights reserved. */
 
-#include "axdimm_process_manager.h"
-#include "axdimm_rank_scheduler.h"
-#include "axdimm_log.h"
+#include "sls_process_manager.h"
+#include "sls_rank_scheduler.h"
+#include "sls_log.h"
 
 #include <linux/bitops.h>
 #include <linux/uaccess.h>
@@ -23,11 +23,11 @@ static atomic_t rd_flag = ATOMIC_INIT(0);
 static DECLARE_WAIT_QUEUE_HEAD(wr_wq);
 static DECLARE_WAIT_QUEUE_HEAD(rd_wq);
 
-static unsigned long acquire_free_rank_for_write(struct axdimm_rank_scheduler *rank_sched,
+static unsigned long acquire_free_rank_for_write(struct sls_rank_scheduler *rank_sched,
 				       unsigned int rw_msk, unsigned int wo_msk)
 {
 	unsigned long rank;
-	struct axdimm_rank_stat_t *axd_rs = rank_sched->axd_rank_stats;
+	struct sls_rank_stat_t *axd_rs = rank_sched->axd_rank_stats;
 
 	rank = __ffs(rw_msk ? rw_msk : wo_msk);
 
@@ -36,12 +36,12 @@ static unsigned long acquire_free_rank_for_write(struct axdimm_rank_scheduler *r
 	return rank;
 }
 
-static void find_free_ranks(struct axdimm_rank_scheduler *rank_sched,
+static void find_free_ranks(struct sls_rank_scheduler *rank_sched,
 			    unsigned int msk, unsigned int *rw_msk,
 			    unsigned int *wo_msk)
 {
 	size_t rank;
-	struct axdimm_rank_stat_t *axd_rs = rank_sched->axd_rank_stats;
+	struct sls_rank_stat_t *axd_rs = rank_sched->axd_rank_stats;
 
 	/* fill wo_msk and rw_msk according to actual read and write
 	 * rank statuses and user requested mask
@@ -55,15 +55,15 @@ static void find_free_ranks(struct axdimm_rank_scheduler *rank_sched,
 		}
 	}
 
-	AXDIMM_DBG("Find free ranks: rw = 0x%x, wo = 0x%x for mask = 0x%x",
+	SLS_DBG("Find free ranks: rw = 0x%x, wo = 0x%x for mask = 0x%x",
 		   *rw_msk, *wo_msk, msk);
 }
 
-void reset_axdimm_rank_scheduler(struct axdimm_rank_scheduler *rank_sched)
+void reset_sls_rank_scheduler(struct sls_rank_scheduler *rank_sched)
 {
 	size_t rank;
 
-	AXDIMM_DBG("Resetting AXDIMM rank scheduler\n");
+	SLS_DBG("Resetting SLS rank scheduler\n");
 
 	/* set all ranks as idle */
 	for (rank = 0; rank < NUM_OF_RANK; rank++) {
@@ -75,13 +75,13 @@ void reset_axdimm_rank_scheduler(struct axdimm_rank_scheduler *rank_sched)
 	atomic64_set(&rank_sched->retry_timeout_ns, RETRY_TIMEOUT_NS);
 }
 
-void init_axdimm_rank_scheduler(struct axdimm_rank_scheduler *rank_sched)
+void init_sls_rank_scheduler(struct sls_rank_scheduler *rank_sched)
 {
-	reset_axdimm_rank_scheduler(rank_sched);
+	reset_sls_rank_scheduler(rank_sched);
 	mutex_init(&rank_sched->rank_stat_lock);
 }
 
-static int get_rank_write(struct axdimm_rank_scheduler *rank_sched,
+static int get_rank_write(struct sls_rank_scheduler *rank_sched,
 			  unsigned int msk)
 {
 	int ret = -1;
@@ -89,10 +89,10 @@ static int get_rank_write(struct axdimm_rank_scheduler *rank_sched,
 	unsigned int rw_mask = 0;
 	unsigned int wo_mask = 0;
 
-	AXDIMM_DBG("Acquiring rank for write (mask 0x%x)\n", msk);
+	SLS_DBG("Acquiring rank for write (mask 0x%x)\n", msk);
 
 	if (msk > MAX_MSK_VAL) {
-		AXDIMM_ERR("Invalid mask value: 0x%x\n", msk);
+		SLS_ERR("Invalid mask value: 0x%x\n", msk);
 		return ret;
 	}
 
@@ -109,23 +109,23 @@ static int get_rank_write(struct axdimm_rank_scheduler *rank_sched,
 	mutex_unlock(&rank_sched->rank_stat_lock);
 
 	if (ret < 0)
-		AXDIMM_DBG("No free rank for write\n");
+		SLS_DBG("No free rank for write\n");
 	else
-		AXDIMM_DBG("Acquired rank %d for write\n", ret);
+		SLS_DBG("Acquired rank %d for write\n", ret);
 
 	return ret;
 }
 
-static int get_rank_read(struct axdimm_rank_scheduler *rank_sched,
+static int get_rank_read(struct sls_rank_scheduler *rank_sched,
 			 unsigned int rank_id)
 {
 	int ret = -1;
-	struct axdimm_rank_stat_t *axd_rs = rank_sched->axd_rank_stats;
+	struct sls_rank_stat_t *axd_rs = rank_sched->axd_rank_stats;
 
-	AXDIMM_DBG("Acquiring rank %u for read\n", rank_id);
+	SLS_DBG("Acquiring rank %u for read\n", rank_id);
 
 	if (rank_id > (NUM_OF_RANK - 1)) {
-		AXDIMM_ERR("Invalid rank value: %u\n", rank_id);
+		SLS_ERR("Invalid rank value: %u\n", rank_id);
 		return ret;
 	}
 
@@ -140,23 +140,23 @@ static int get_rank_read(struct axdimm_rank_scheduler *rank_sched,
 	mutex_unlock(&rank_sched->rank_stat_lock);
 
 	if (ret < 0)
-		AXDIMM_DBG("Could not acquire rank %u for read\n", rank_id);
+		SLS_DBG("Could not acquire rank %u for read\n", rank_id);
 	else
-		AXDIMM_DBG("Acquired rank %u for read\n", rank_id);
+		SLS_DBG("Acquired rank %u for read\n", rank_id);
 
 	return ret;
 }
 
-int release_rank_write(struct axdimm_rank_scheduler *rank_sched,
+int release_rank_write(struct sls_rank_scheduler *rank_sched,
 		       unsigned int rank_id)
 {
 	int ret = rank_id;
-	struct axdimm_rank_stat_t *axd_rs = rank_sched->axd_rank_stats;
+	struct sls_rank_stat_t *axd_rs = rank_sched->axd_rank_stats;
 
-	AXDIMM_DBG("Releasing rank %u for write\n", rank_id);
+	SLS_DBG("Releasing rank %u for write\n", rank_id);
 
 	if (rank_id > (NUM_OF_RANK - 1)) {
-		AXDIMM_ERR("Invalid rank value: %u\n", rank_id);
+		SLS_ERR("Invalid rank value: %u\n", rank_id);
 		return -1;
 	}
 
@@ -170,16 +170,16 @@ int release_rank_write(struct axdimm_rank_scheduler *rank_sched,
 	return ret;
 }
 
-int release_rank_read(struct axdimm_rank_scheduler *rank_sched,
+int release_rank_read(struct sls_rank_scheduler *rank_sched,
 		      unsigned int rank_id)
 {
 	int ret = rank_id;
-	struct axdimm_rank_stat_t *axd_rs = rank_sched->axd_rank_stats;
+	struct sls_rank_stat_t *axd_rs = rank_sched->axd_rank_stats;
 
-	AXDIMM_DBG("Releasing rank %u for read\n", rank_id);
+	SLS_DBG("Releasing rank %u for read\n", rank_id);
 
 	if (rank_id > (NUM_OF_RANK - 1)) {
-		AXDIMM_ERR("Invalid rank value: %u\n", rank_id);
+		SLS_ERR("Invalid rank value: %u\n", rank_id);
 		return -1;
 	}
 
@@ -195,7 +195,7 @@ int release_rank_read(struct axdimm_rank_scheduler *rank_sched,
 // Here we disable kcsan checks due to unavoidable data race in
 // wait_event_interruptible_hrtimeout. We can't replace that function because the
 // HW is hanging
-static __no_kcsan int wait_for_rank(struct axdimm_rank_scheduler *rank_sched,
+static __no_kcsan int wait_for_rank(struct sls_rank_scheduler *rank_sched,
 			 atomic_t *flag, struct wait_queue_head *wq)
 {
 	atomic_set(flag, 0);
@@ -205,7 +205,7 @@ static __no_kcsan int wait_for_rank(struct axdimm_rank_scheduler *rank_sched,
 		atomic64_read(&rank_sched->retry_timeout_ns));
 }
 
-int get_retry_read(struct axdimm_rank_scheduler *rank_sched, unsigned int arg)
+int get_retry_read(struct sls_rank_scheduler *rank_sched, unsigned int arg)
 {
 	if (wait_for_rank(rank_sched, &rd_flag, &rd_wq) >= 0)
 		return get_rank_read(rank_sched, arg);
@@ -213,14 +213,14 @@ int get_retry_read(struct axdimm_rank_scheduler *rank_sched, unsigned int arg)
 	return -1;
 }
 
-int get_retry_write(struct axdimm_rank_scheduler *rank_sched, unsigned int arg)
+int get_retry_write(struct sls_rank_scheduler *rank_sched, unsigned int arg)
 {
 	if (wait_for_rank(rank_sched, &wr_flag, &wr_wq) >= 0)
 		return get_rank_write(rank_sched, arg);
 
 	return -1;
 }
-int get_rank_retry(struct axdimm_rank_scheduler *rank_sched, unsigned int cmd,
+int get_rank_retry(struct sls_rank_scheduler *rank_sched, unsigned int cmd,
 		   unsigned int arg)
 {
 	if (cmd == GET_RANK_FOR_READ)
@@ -228,11 +228,11 @@ int get_rank_retry(struct axdimm_rank_scheduler *rank_sched, unsigned int cmd,
 	else if (cmd == GET_RANK_FOR_WRITE)
 		return get_retry_write(rank_sched, arg);
 
-	AXDIMM_ERR("Unknown rank operation cmd [%d]\n", cmd);
+	SLS_ERR("Unknown rank operation cmd [%d]\n", cmd);
 	return -EINVAL;
 }
 
-static int get_rank(struct axdimm_rank_scheduler *rank_sched, unsigned int cmd,
+static int get_rank(struct sls_rank_scheduler *rank_sched, unsigned int cmd,
 		    unsigned int arg)
 {
 	if (cmd == GET_RANK_FOR_WRITE)
@@ -240,11 +240,11 @@ static int get_rank(struct axdimm_rank_scheduler *rank_sched, unsigned int cmd,
 	if (cmd == GET_RANK_FOR_READ)
 		return get_rank_read(rank_sched, arg);
 
-	AXDIMM_ERR("Unknown rank operation cmd [%d]\n", cmd);
+	SLS_ERR("Unknown rank operation cmd [%d]\n", cmd);
 	return -EINVAL;
 }
 
-int get_axdimm_rank(struct axdimm_rank_scheduler *rank_sched, unsigned int cmd,
+int get_sls_rank(struct sls_rank_scheduler *rank_sched, unsigned int cmd,
 		    unsigned int arg)
 {
 	int ret = get_rank(rank_sched, cmd, arg);
@@ -253,12 +253,12 @@ int get_axdimm_rank(struct axdimm_rank_scheduler *rank_sched, unsigned int cmd,
 		ret = get_rank_retry(rank_sched, cmd, arg);
 
 	if (ret >= 0) /* finally got rank, add to process resources */
-		axdimm_proc_register_rank(&axdimm_proc_mgr, ret, cmd);
+		sls_proc_register_rank(&sls_proc_mgr, ret, cmd);
 
 	return ret;
 }
 
-static void wakeup_queue(struct axdimm_rank_scheduler *rank_sched, int rank,
+static void wakeup_queue(struct sls_rank_scheduler *rank_sched, int rank,
 			 atomic_t *flag, struct wait_queue_head *wq)
 {
 	if (rank >= 0) { /* wake up someone */
@@ -267,7 +267,7 @@ static void wakeup_queue(struct axdimm_rank_scheduler *rank_sched, int rank,
 	}
 }
 
-static int release_and_wakeup(struct axdimm_rank_scheduler *rank_sched,
+static int release_and_wakeup(struct sls_rank_scheduler *rank_sched,
 			      unsigned int cmd, unsigned int arg)
 {
 	int rank;
@@ -279,14 +279,14 @@ static int release_and_wakeup(struct axdimm_rank_scheduler *rank_sched,
 		rank = release_rank_read(rank_sched, arg);
 		wakeup_queue(rank_sched, rank, &rd_flag, &rd_wq);
 	} else {
-		AXDIMM_ERR("Unknown rank operation cmd [%d]\n", cmd);
+		SLS_ERR("Unknown rank operation cmd [%d]\n", cmd);
 		return -EINVAL;
 	}
 
 	return rank;
 }
 
-int release_axdimm_rank(struct axdimm_rank_scheduler *rank_sched,
+int release_sls_rank(struct sls_rank_scheduler *rank_sched,
 			unsigned int cmd, unsigned int arg)
 {
 	int rank;
@@ -294,7 +294,7 @@ int release_axdimm_rank(struct axdimm_rank_scheduler *rank_sched,
 	rank = release_and_wakeup(rank_sched, cmd, arg);
 
 	if (rank >= 0)
-		return axdimm_proc_remove_rank(&axdimm_proc_mgr, rank, cmd);
+		return sls_proc_remove_rank(&sls_proc_mgr, rank, cmd);
 
 	return -1;
 }
diff --git a/drivers/pnm/axdimm_resource/axdimm_rank_scheduler.h b/drivers/pnm/sls_resource/sls_rank_scheduler.h
similarity index 60%
rename from drivers/pnm/axdimm_resource/axdimm_rank_scheduler.h
rename to drivers/pnm/sls_resource/sls_rank_scheduler.h
index b3d810343..ef6f8edf2 100644
--- a/drivers/pnm/axdimm_resource/axdimm_rank_scheduler.h
+++ b/drivers/pnm/sls_resource/sls_rank_scheduler.h
@@ -1,18 +1,18 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /* Copyright(c) 2022 Samsung LTD. All rights reserved. */
 
-#ifndef __AXDIMM_RANK_SCHEDULER_H__
-#define __AXDIMM_RANK_SCHEDULER_H__
+#ifndef __SLS_RANK_SCHEDULER_H__
+#define __SLS_RANK_SCHEDULER_H__
 
 #include <linux/atomic.h>
 
-#include <linux/libaxdimm.h>
+#include <linux/sls_resources.h>
 #include <linux/types.h>
 #include <linux/mutex.h>
 
-struct axdimm_rank_scheduler {
+struct sls_rank_scheduler {
 	/* struct for managing rank read and write status */
-	struct axdimm_rank_stat_t {
+	struct sls_rank_stat_t {
 		uint8_t wr_stat;
 		uint8_t cacheline_padding_1[L1_CACHE_BYTES - sizeof(uint8_t)];
 		uint8_t rd_stat;
@@ -25,21 +25,21 @@ struct axdimm_rank_scheduler {
 	struct mutex rank_stat_lock;
 };
 
-extern struct axdimm_process_manager axdimm_proc_mgr;
+extern struct sls_process_manager sls_proc_mgr;
 
-void reset_axdimm_rank_scheduler(struct axdimm_rank_scheduler *rank_sched);
-void init_axdimm_rank_scheduler(struct axdimm_rank_scheduler *rank_sched);
-int get_axdimm_rank(struct axdimm_rank_scheduler *rank_sched, unsigned int cmd,
+void reset_sls_rank_scheduler(struct sls_rank_scheduler *rank_sched);
+void init_sls_rank_scheduler(struct sls_rank_scheduler *rank_sched);
+int get_sls_rank(struct sls_rank_scheduler *rank_sched, unsigned int cmd,
 		    unsigned int arg);
-int release_axdimm_rank(struct axdimm_rank_scheduler *rank_sched,
+int release_sls_rank(struct sls_rank_scheduler *rank_sched,
 			unsigned int cmd, unsigned int arg);
 
 /* these functions are intended for direct rank status manipulation from
  * resource manager, in order to free resources which were not freed by
  * user space process itself
  */
-int release_rank_write(struct axdimm_rank_scheduler *rank_sched,
+int release_rank_write(struct sls_rank_scheduler *rank_sched,
 		       unsigned int rank_id);
-int release_rank_read(struct axdimm_rank_scheduler *rank_sched,
+int release_rank_read(struct sls_rank_scheduler *rank_sched,
 		      unsigned int rank_id);
 #endif
diff --git a/drivers/pnm/axdimm_resource/axdimm_sysfs.c b/drivers/pnm/sls_resource/sls_sysfs.c
similarity index 78%
rename from drivers/pnm/axdimm_resource/axdimm_sysfs.c
rename to drivers/pnm/sls_resource/sls_sysfs.c
index ac21cb19e..97756c994 100644
--- a/drivers/pnm/axdimm_resource/axdimm_sysfs.c
+++ b/drivers/pnm/sls_resource/sls_sysfs.c
@@ -1,17 +1,17 @@
 // SPDX-License-Identifier: GPL-2.0
 /* Copyright(c) 2022 Samsung LTD. All rights reserved. */
 
-#include "axdimm_sysfs.h"
-#include "axdimm_allocator.h"
-#include "axdimm_log.h"
-#include "axdimm_rank_scheduler.h"
-#include "axdimm_process_manager.h"
-#include "axdimm_private.h"
+#include "sls_sysfs.h"
+#include "sls_allocator.h"
+#include "sls_log.h"
+#include "sls_rank_scheduler.h"
+#include "sls_process_manager.h"
+#include "sls_private.h"
 
 #include <linux/device.h>
 #include <linux/genalloc.h>
 #include <linux/kernel.h>
-#include <linux/libaxdimm.h>
+#include <linux/sls_resources.h>
 #include <linux/string.h>
 #include <linux/types.h>
 
@@ -21,13 +21,13 @@
 #define REGION_SYSFS_ATTR_COUNT 2
 #define WITH_NULL_TERM(var) (var + 1)
 
-static struct axdimm_dev *axdimm_device;
+static struct sls_dev *sls_device;
 static struct kobject *ranks_kobj;
 
 static ssize_t leaked_show(struct device *device, struct device_attribute *attr,
 			   char *buf)
 {
-	return sprintf(buf, "%llu\n", atomic64_read(&axdimm_proc_mgr.leaked));
+	return sprintf(buf, "%llu\n", atomic64_read(&sls_proc_mgr.leaked));
 }
 static DEVICE_ATTR_RO(leaked);
 
@@ -35,7 +35,7 @@ static ssize_t cleanup_show(struct device *device,
 			    struct device_attribute *attr, char *buf)
 {
 	return sprintf(buf, "%llu\n",
-		       atomic64_read(&axdimm_proc_mgr.enable_cleanup));
+		       atomic64_read(&sls_proc_mgr.enable_cleanup));
 }
 
 static ssize_t cleanup_store(struct device *device,
@@ -43,14 +43,14 @@ static ssize_t cleanup_store(struct device *device,
 			     size_t count)
 {
 	if (sysfs_streq(buf, "1")) {
-		if (axdimm_proc_manager_cleanup_on(&axdimm_proc_mgr,
-						   axdimm_device->allocator,
-						   &axdimm_rank_sched))
-			AXDIMM_ERR("Failed to enable resource manager\n");
+		if (sls_proc_manager_cleanup_on(&sls_proc_mgr,
+						   sls_device->allocator,
+						   &sls_rank_sched))
+			SLS_ERR("Failed to enable resource manager\n");
 	} else if (sysfs_streq(buf, "0")) {
-		axdimm_proc_manager_cleanup_off(&axdimm_proc_mgr);
+		sls_proc_manager_cleanup_off(&sls_proc_mgr);
 	} else {
-		AXDIMM_DBG(
+		SLS_DBG(
 			"Ignoring invalid value ('%s') written into sysfs 'cleanup' file\n",
 			buf);
 	}
@@ -63,7 +63,7 @@ static ssize_t acq_timeout_show(struct device *device,
 				struct device_attribute *attr, char *buf)
 {
 	return sprintf(buf, "%llu\n",
-		       atomic64_read(&axdimm_rank_sched.retry_timeout_ns));
+		       atomic64_read(&sls_rank_sched.retry_timeout_ns));
 }
 
 static ssize_t acq_timeout_store(struct device *device,
@@ -73,13 +73,13 @@ static ssize_t acq_timeout_store(struct device *device,
 	uint64_t acq_timeout;
 
 	if (kstrtoull(buf, 10, &acq_timeout)) {
-		AXDIMM_ERR(
+		SLS_ERR(
 			"Failed to convert rank acquisition timeout string ('%s') to integer.\n",
 			buf);
 		return -EINVAL;
 	}
-	AXDIMM_DBG("Setting acq_timeout to %llu ns via sysfs\n", acq_timeout);
-	atomic64_set(&axdimm_rank_sched.retry_timeout_ns, acq_timeout);
+	SLS_DBG("Setting acq_timeout to %llu ns via sysfs\n", acq_timeout);
+	atomic64_set(&sls_rank_sched.retry_timeout_ns, acq_timeout);
 	return count;
 }
 static DEVICE_ATTR_RW(acq_timeout);
@@ -88,13 +88,13 @@ static ssize_t reset_store(struct device *device, struct device_attribute *attr,
 			   const char *buf, size_t count)
 {
 	if (sysfs_streq(buf, "1")) {
-		AXDIMM_DBG("Resetting AXDIMM device via sysfs\n");
-		if (axdimm_ioctl(NULL, DEVICE_IOCRESET, 0))
-			AXDIMM_ERR("Failed to reset device via sysfs.\n");
+		SLS_DBG("Resetting SLS device via sysfs\n");
+		if (sls_ioctl(NULL, DEVICE_IOCRESET, 0))
+			SLS_ERR("Failed to reset device via sysfs.\n");
 	} else {
 		// Usual behavior is to silently ignore this, so there is no reason
-		// to make it an AXDIMM_WRN.
-		AXDIMM_DBG(
+		// to make it an SLS_WRN.
+		SLS_DBG(
 			"Ignoring invalid value ('%s') written into sysfs 'reset' file\n",
 			buf);
 	}
@@ -134,12 +134,12 @@ struct region_attribute {
 };
 
 struct regions_sysfs {
-	struct region_attribute region_attrs[AXDIMM_BLOCK_MAX]
+	struct region_attribute region_attrs[SLS_BLOCK_MAX]
 					    [REGION_SYSFS_ATTR_COUNT];
-	struct attribute *attrs[AXDIMM_BLOCK_MAX]
+	struct attribute *attrs[SLS_BLOCK_MAX]
 			       [WITH_NULL_TERM(REGION_SYSFS_ATTR_COUNT)];
-	struct attribute_group group[AXDIMM_BLOCK_MAX];
-	const struct attribute_group *groups[WITH_NULL_TERM(AXDIMM_BLOCK_MAX)];
+	struct attribute_group group[SLS_BLOCK_MAX];
+	const struct attribute_group *groups[WITH_NULL_TERM(SLS_BLOCK_MAX)];
 	struct kobject regions_kobj;
 };
 
@@ -167,33 +167,33 @@ static ssize_t rank_show(struct rank_attribute *attr, char *buf)
 	struct gen_pool *pool;
 
 	if (strcmp(attr->attr.name, rank_attr_name[0]) == 0) {
-		struct axdimm_rank_stat_t *axd_rs =
-			axdimm_rank_sched.axd_rank_stats;
-		mutex_lock(&axdimm_rank_sched.rank_stat_lock);
+		struct sls_rank_stat_t *axd_rs =
+			sls_rank_sched.axd_rank_stats;
+		mutex_lock(&sls_rank_sched.rank_stat_lock);
 		state = axd_rs[attr->rank].wr_stat;
-		mutex_unlock(&axdimm_rank_sched.rank_stat_lock);
+		mutex_unlock(&sls_rank_sched.rank_stat_lock);
 		return sprintf(buf, "%u\n", state);
 	}
 
 	if (strcmp(attr->attr.name, rank_attr_name[1]) == 0) {
-		lock_allocator(axdimm_device->allocator);
-		pool = axdimm_device->allocator->mem_pools[attr->rank];
+		lock_allocator(sls_device->allocator);
+		pool = sls_device->allocator->mem_pools[attr->rank];
 		size = pool ? gen_pool_size(pool) : 0;
-		unlock_allocator(axdimm_device->allocator);
+		unlock_allocator(sls_device->allocator);
 		return sprintf(buf, "%llu\n", size);
 	}
 
 	if (strcmp(attr->attr.name, rank_attr_name[2]) == 0) {
-		lock_allocator(axdimm_device->allocator);
-		pool = axdimm_device->allocator->mem_pools[attr->rank];
+		lock_allocator(sls_device->allocator);
+		pool = sls_device->allocator->mem_pools[attr->rank];
 		free_size = pool ? gen_pool_avail(pool) : 0;
-		unlock_allocator(axdimm_device->allocator);
+		unlock_allocator(sls_device->allocator);
 		return sprintf(buf, "%llu\n", free_size);
 	}
 
 	if (strcmp(attr->attr.name, rank_attr_name[3]) == 0) {
-		struct axdimm_rank_stat_t *axd_rs =
-			axdimm_rank_sched.axd_rank_stats;
+		struct sls_rank_stat_t *axd_rs =
+			sls_rank_sched.axd_rank_stats;
 		wr_acq_count =
 			atomic64_read(&axd_rs[attr->rank].wr_acquisition_count);
 		return sprintf(buf, "%llu\n", wr_acq_count);
@@ -228,13 +228,13 @@ static ssize_t region_show(struct region_attribute *attr, char *buf)
 	if (strcmp(attr->attr.name, region_attr_name[0]) == 0)
 		return sprintf(
 			buf, "%llu\n",
-			axdimm_device->mem_info.mem_size[attr->rank % NUM_OF_CS]
+			sls_device->mem_info.mem_size[attr->rank % NUM_OF_CS]
 							[attr->region] /
 				NUM_RANKS_PER_CS);
 
 	if (strcmp(attr->attr.name, region_attr_name[1]) == 0)
 		return sprintf(buf, "%llu\n",
-			       axdimm_device->mem_info
+			       sls_device->mem_info
 				       .mem_offset[attr->rank % NUM_OF_CS]
 						  [attr->region]);
 
@@ -283,10 +283,10 @@ static void fill_regions_sysfs(struct regions_sysfs *regions_fs, uint8_t rank)
 {
 	int region;
 
-	for (region = 0; region < AXDIMM_BLOCK_MAX; region++)
+	for (region = 0; region < SLS_BLOCK_MAX; region++)
 		fill_region_sysfs(regions_fs, rank, region);
 
-	regions_fs->groups[AXDIMM_BLOCK_MAX] = NULL;
+	regions_fs->groups[SLS_BLOCK_MAX] = NULL;
 }
 
 static const struct sysfs_ops regions_sysfs_ops = {
@@ -362,7 +362,7 @@ static int build_rank_sysfs(struct kobject *kobj, uint8_t rank)
 	char buf[4];
 	int err;
 
-	AXDIMM_DBG("Building AXDIMM sysfs for rank %hhu\n", rank);
+	SLS_DBG("Building SLS sysfs for rank %hhu\n", rank);
 
 	kobject_init(&ranks_fs[rank].rank_idx_kobj, &rank_type);
 	sprintf(buf, "%hhu", rank);
@@ -389,40 +389,40 @@ static int build_rank_sysfs(struct kobject *kobj, uint8_t rank)
 	return err;
 }
 
-int build_axdimm_sysfs(struct axdimm_dev *dev, struct device *resource_dev)
+int build_sls_sysfs(struct sls_dev *dev, struct device *resource_dev)
 {
 	int rank;
 	int err = 0;
 
-	axdimm_device = dev;
+	sls_device = dev;
 
-	AXDIMM_DBG("Building AXDIMM sysfs\n");
+	SLS_DBG("Building SLS sysfs\n");
 	ranks_kobj = kobject_create_and_add("ranks", &resource_dev->kobj);
 	if (sysfs_create_groups(ranks_kobj, dev_attr_groups)) {
 		err = -ENOMEM;
-		goto axdimm_sysfs_out;
+		goto sls_sysfs_out;
 	}
 
 	for (rank = 0; rank < NUM_OF_RANK; ++rank) {
 		err = build_rank_sysfs(ranks_kobj, rank);
 		if (err) {
-			AXDIMM_ERR("Failed to build sysfs for rank [%d]\n",
+			SLS_ERR("Failed to build sysfs for rank [%d]\n",
 				   rank);
-			goto axdimm_sysfs_out;
+			goto sls_sysfs_out;
 		}
 	}
 
-	AXDIMM_DBG("Built AXDIMM sysfs\n");
+	SLS_DBG("Built SLS sysfs\n");
 
-axdimm_sysfs_out:
+sls_sysfs_out:
 	return err;
 }
 
-void destroy_axdimm_sysfs(void)
+void destroy_sls_sysfs(void)
 {
 	int rank;
 
-	AXDIMM_DBG("Destroying AXDIMM sysfs\n");
+	SLS_DBG("Destroying SLS sysfs\n");
 
 	for (rank = 0; rank < NUM_OF_RANK; ++rank) {
 		sysfs_remove_groups(&ranks_fs[rank].regions_fs.regions_kobj,
@@ -435,5 +435,5 @@ void destroy_axdimm_sysfs(void)
 	sysfs_remove_groups(ranks_kobj, dev_attr_groups);
 	kobject_del(ranks_kobj);
 
-	AXDIMM_DBG("Destroyed AXDIMM sysfs\n");
+	SLS_DBG("Destroyed SLS sysfs\n");
 }
diff --git a/drivers/pnm/sls_resource/sls_sysfs.h b/drivers/pnm/sls_resource/sls_sysfs.h
new file mode 100644
index 000000000..732032bc9
--- /dev/null
+++ b/drivers/pnm/sls_resource/sls_sysfs.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2022-2023 Samsung LTD. All rights reserved. */
+
+#ifndef __SLS_SYSFS__
+#define __SLS_SYSFS__
+
+struct device;
+struct sls_dev;
+
+extern struct sls_rank_scheduler sls_rank_sched;
+extern struct sls_process_manager sls_proc_mgr;
+
+int build_sls_sysfs(struct sls_dev *dev, struct device *resource_dev);
+void destroy_sls_sysfs(void);
+
+#endif /* __SLS_SYSFS__ */
diff --git a/include/linux/axdimm_common.h b/include/linux/axdimm_common.h
deleted file mode 100644
index fdb6463bc..000000000
--- a/include/linux/axdimm_common.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
-
-/*
- * This file contains common definitions and macros used both by DAX and
- * axdimm_resource.
- */
-
-#ifndef __AXDIMM_COMMON_H__
-#define __AXDIMM_COMMON_H__
-
-#include <linux/types.h>
-#include <linux/libaxdimm.h>
-
-/* A scale of AXDIMM memory range */
-#define AXDIMM_MEMORY_SCALE ((uint64_t)CONFIG_AXDIMM_MEMORY_SCALE)
-
-/* Total Memory size for AXDIMM */
-#define AXDIMM_MEMORY_SIZE (0x1000000000ULL >> AXDIMM_MEMORY_SCALE)
-
-/* Start address of AXDIMM */
-#define AXDIMM_BASE_ADDR ((uint64_t)CONFIG_AXDIMM_BASE_ADDR << 30)
-
-/* Base offset for each CS */
-#define EMBT_BASE_CS0_OFFSET 0ULL
-#define EMBT_BASE_CS1_OFFSET (0x800000000ULL >> AXDIMM_MEMORY_SCALE)
-
-/* The enumeration of axdimm memory addresses */
-enum axd_mem_regions_e {
-	AXDIMM_BASE_CS0 = 0,
-	AXDIMM_TAGS_CS0 = 1,
-	AXDIMM_PSUM_CS0 = 2,
-	AXDIMM_BASE_CS1 = 3,
-	AXDIMM_TAGS_CS1 = 4,
-	AXDIMM_PSUM_CS1 = 5,
-	NUM_OF_MEM_REGION = 6 /* Number of index for memory mapping region */
-};
-
-struct axdmem_info {
-	uint64_t mem_offset[NUM_OF_CS][AXDIMM_BLOCK_MAX];
-	uint64_t mem_size[NUM_OF_CS][AXDIMM_BLOCK_MAX];
-};
-
-#endif /* __AXDIMM_COMMON_H__ */
diff --git a/include/linux/axdimm_set_mem_info.h b/include/linux/axdimm_set_mem_info.h
index e8cd52838..c48ff30ea 100644
--- a/include/linux/axdimm_set_mem_info.h
+++ b/include/linux/axdimm_set_mem_info.h
@@ -3,15 +3,15 @@
 
 /*
  * This file contains struct mem_info filling code common for DAX and
- * axdimm_resource. These functions have been factored out to this
+ * sls_resource. These functions have been factored out to this
  * file to avoid "Function defined but not used" warnings for code that
- * only uses definitions from axdimm_common.h.
+ * only uses definitions from sls_common.h.
  */
 
 #ifndef __AXDIMM_SET_MEM_INFO_H__
 #define __AXDIMM_SET_MEM_INFO_H__
 
-#include <linux/axdimm_common.h>
+#include <linux/sls_common.h>
 #include <linux/types.h>
 
 static uint64_t axdimm_make_address(int channel, int rank, int bankgroup,
@@ -71,57 +71,57 @@ static uint64_t axdimm_make_address(int channel, int rank, int bankgroup,
 	 * it's a common shift for INST/CONF/PSUM relative to the start of BASE,
 	 * in other words it's a BASE block size.
 	 */
-	addr += ((row_t >> 12) & 0x1f) >> AXDIMM_MEMORY_SCALE << 30;
+	addr += ((row_t >> 12) & 0x1f) >> SLS_MEMORY_SCALE << 30;
 
 	/*
 	 * CS bit[35], Chip Select bit, it also scales to proper switch
 	 * between CS when using scale on a simulator.
 	 */
-	addr += ((uint64_t)rank << 35) >> AXDIMM_MEMORY_SCALE;
+	addr += ((uint64_t)rank << 35) >> SLS_MEMORY_SCALE;
 	/* CH bit[36], always 0 */
-	addr += (((uint64_t)channel & 0x1) << 36) >> AXDIMM_MEMORY_SCALE;
+	addr += (((uint64_t)channel & 0x1) << 36) >> SLS_MEMORY_SCALE;
 
 	return addr;
 }
 
-static void axdimm_set_mem_info(struct axdmem_info *mem_info)
+static void axdimm_set_mem_info(struct sls_mem_info *mem_info)
 {
 	int cs;
 
 	/* Calculate system addr & size */
 	for (cs = 0; cs < NUM_OF_CS; cs++) {
 		/* init register address for each cs */
-		mem_info->mem_offset[cs][AXDIMM_BLOCK_BASE] =
+		mem_info->mem_offset[cs][SLS_BLOCK_BASE] =
 			(cs & 1) ?
 				EMBT_BASE_CS1_OFFSET :
 				EMBT_BASE_CS0_OFFSET; // CS0: rank 0,2	CS1: rank 1,3
-		mem_info->mem_offset[cs][AXDIMM_BLOCK_INST] =
+		mem_info->mem_offset[cs][SLS_BLOCK_INST] =
 			axdimm_make_address(AXDIMM_CH_ID, cs, 0, 0, 0x1F000, 0);
-		mem_info->mem_offset[cs][AXDIMM_BLOCK_CFGR] =
+		mem_info->mem_offset[cs][SLS_BLOCK_CFGR] =
 			axdimm_make_address(AXDIMM_CH_ID, cs, 0, 0, 0x1F100, 0);
-		mem_info->mem_offset[cs][AXDIMM_BLOCK_TAGS] =
+		mem_info->mem_offset[cs][SLS_BLOCK_TAGS] =
 			axdimm_make_address(AXDIMM_CH_ID, cs, 0, 0, 0x1F200, 0);
-		mem_info->mem_offset[cs][AXDIMM_BLOCK_PSUM] =
+		mem_info->mem_offset[cs][SLS_BLOCK_PSUM] =
 			axdimm_make_address(AXDIMM_CH_ID, cs, 0, 0, 0x1F400, 0);
 
 		/* init register size for each cs */
-		mem_info->mem_size[cs][AXDIMM_BLOCK_BASE] =
-			mem_info->mem_offset[cs][AXDIMM_BLOCK_INST] -
-			mem_info->mem_offset[cs][AXDIMM_BLOCK_BASE];
-		mem_info->mem_size[cs][AXDIMM_BLOCK_INST] =
-			mem_info->mem_offset[cs][AXDIMM_BLOCK_CFGR] -
-			mem_info->mem_offset[cs][AXDIMM_BLOCK_INST];
-		mem_info->mem_size[cs][AXDIMM_BLOCK_CFGR] =
-			mem_info->mem_offset[cs][AXDIMM_BLOCK_TAGS] -
-			mem_info->mem_offset[cs][AXDIMM_BLOCK_CFGR];
-		mem_info->mem_size[cs][AXDIMM_BLOCK_TAGS] =
-			mem_info->mem_offset[cs][AXDIMM_BLOCK_PSUM] -
-			mem_info->mem_offset[cs][AXDIMM_BLOCK_TAGS];
-		mem_info->mem_size[cs][AXDIMM_BLOCK_PSUM] =
+		mem_info->mem_size[cs][SLS_BLOCK_BASE] =
+			mem_info->mem_offset[cs][SLS_BLOCK_INST] -
+			mem_info->mem_offset[cs][SLS_BLOCK_BASE];
+		mem_info->mem_size[cs][SLS_BLOCK_INST] =
+			mem_info->mem_offset[cs][SLS_BLOCK_CFGR] -
+			mem_info->mem_offset[cs][SLS_BLOCK_INST];
+		mem_info->mem_size[cs][SLS_BLOCK_CFGR] =
+			mem_info->mem_offset[cs][SLS_BLOCK_TAGS] -
+			mem_info->mem_offset[cs][SLS_BLOCK_CFGR];
+		mem_info->mem_size[cs][SLS_BLOCK_TAGS] =
+			mem_info->mem_offset[cs][SLS_BLOCK_PSUM] -
+			mem_info->mem_offset[cs][SLS_BLOCK_TAGS];
+		mem_info->mem_size[cs][SLS_BLOCK_PSUM] =
 			EMBT_BASE_CS1_OFFSET -
 			mem_info->mem_offset
 				[0]
-				[AXDIMM_BLOCK_PSUM]; // Assume that all psum sizes are the same
+				[SLS_BLOCK_PSUM]; // Assume that all psum sizes are the same
 	}
 }
 
diff --git a/include/linux/sls_common.h b/include/linux/sls_common.h
new file mode 100644
index 000000000..fca49822d
--- /dev/null
+++ b/include/linux/sls_common.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
+
+/*
+ * This file contains common definitions and macros used both by DAX and
+ * sls_resource.
+ */
+
+#ifndef __SLS_COMMON_H__
+#define __SLS_COMMON_H__
+
+#include <linux/libaxdimm.h>
+#include <linux/sls_resources.h>
+#include <linux/types.h>
+
+struct sls_mem_info {
+	uint64_t mem_offset[NUM_OF_CS][SLS_BLOCK_MAX];
+	uint64_t mem_size[NUM_OF_CS][SLS_BLOCK_MAX];
+};
+
+/* A scale of SLS memory range */
+#define SLS_MEMORY_SCALE ((uint64_t)CONFIG_DEV_SLS_MEMORY_SCALE)
+
+/* Total Memory size for SLS */
+#define SLS_MEMORY_SIZE (0x1000000000ULL >> SLS_MEMORY_SCALE)
+
+/* Start address of SLS */
+#define SLS_BASE_ADDR ((uint64_t)CONFIG_DEV_SLS_BASE_ADDR << 30)
+
+/* Base offset for each CS */
+#define EMBT_BASE_CS0_OFFSET 0ULL
+#define EMBT_BASE_CS1_OFFSET (0x800000000ULL >> SLS_MEMORY_SCALE)
+
+/* The enumeration of sls memory addresses */
+enum sls_mem_regions_e {
+	SLS_BASE_CS0 = 0,
+	SLS_TAGS_CS0 = 1,
+	SLS_PSUM_CS0 = 2,
+	SLS_BASE_CS1 = 3,
+	SLS_TAGS_CS1 = 4,
+	SLS_PSUM_CS1 = 5,
+	NUM_OF_MEM_REGION = 6 /* Number of index for memory mapping region */
+};
+
+#endif /* __SLS_COMMON_H__ */
diff --git a/include/uapi/linux/libaxdimm.h b/include/uapi/linux/libaxdimm.h
index ccad58e74..c03ea0e2e 100644
--- a/include/uapi/linux/libaxdimm.h
+++ b/include/uapi/linux/libaxdimm.h
@@ -21,11 +21,6 @@
 /* Interleaving Stride length : 128Bytes (0x80) */
 #define AXDIMM_STRIDE_LENGTH 0x80
 
-/* Offset at config reg */
-#define REG_SLS_EN 0x0
-#define REG_SLS_EXEC 0x40
-#define REG_POLLING 0x840
-
 /* [TODO: @y-lavrinenko] Redundant and unused. Should be removed*/
 #define MEM_SEG_NUM 5
 
@@ -42,182 +37,17 @@
 #define AXDIMM_CH_ID 0
 
 /* total number of ranks for axdimm */
-#define NUM_OF_RANK 4
+#define AXDIMM_NUM_OF_RANK 4
 
 /* number of ranks on one chip select */
 #define NUM_RANKS_PER_CS (NUM_OF_RANK / NUM_OF_CS)
 
-/* number of Instruction, Psum & Tags buffers */
-#define NUM_OF_INST_BUF 1
-#define NUM_OF_PSUM_BUF 2
-#define NUM_OF_TAGS_BUF 2
-
-/* Single TAG size (Bytes) */
-#define ALIGNED_TAG_SIZE 64
-
-/* Instruction Size (Bytes) */
-#define INSTRUCTION_SIZE 8
-
-/* Data Size (Bytes) */
-#define DATA_SIZE 4
-
-/* Instruction, Psum & Tags Buffers Size (Bytes) */
-#define HW_BUF_SIZE (256 * 1024)
-
-#define INST_BUF_SIZE HW_BUF_SIZE
-#define PSUM_BUF_SIZE HW_BUF_SIZE
-#define TAGS_BUF_SIZE HW_BUF_SIZE
-
 /* Channel interleaving unit size (Bytes) */
 #define CHANNEL_INTERLEAVING_SIZE 0x20000
 
 /* Rank interleaving unit size (Bytes) */
 #define RANK_INTERLEAVING_SIZE 0x80
 
-/* Path to AXDIMM resource manager device within /dev */
-#define AXDIMM_RESOURCE_PATH_INTERNAL "pnm/axdimm_resource"
-
-/* Path to AXDIMM resource manager device */
-#define AXDIMM_RESOURCE_PATH "/dev/" AXDIMM_RESOURCE_PATH_INTERNAL
-
-/* Path to AXDIMM memory device */
-#define AXDIMM_MEMDEV_PATH "/dev/axdimm_device"
-
-/* Path to DAX device */
-#define DAX_PATH "/dev/dax0.0"
-
-/* Path to axdimm_resource sysfs root */
-/* [TODO: @a.korzun] Rename this to AXDIMM_SYSFS_ROOT or a similar name. */
-#define DAX_SYSFS_ROOT "/sys/class/axdimm_resource"
-
-// Block of sysfs relative paths for device
-// DAX_SYSFS_ROOT"/dax%d.%d/ranks"
-
-/* O_WRONLY Path to reset device, write "1" for reset */
-#define DEVICE_RESET_PATH "reset"
-/* O_RDWR Path to acquisition timeout, measured in ns */
-#define DEVICE_ACQUISITION_TIMEOUT_PATH "acq_timeout"
-/*
- * O_RDWR Path to enabling/disabling cleanup of leaked resources by
- * resource manager, write "1" to enable and "0" to disable
- */
-#define DEVICE_RESOURCE_CLEANUP_PATH "cleanup"
-/*
- * O_RDONLY Path to read resource leakage status, holds number of processes
- * failed to free resources before exit
- */
-#define DEVICE_LEAKED_PATH "leaked"
-
-// Block of sysfs paths for ranks info, all O_RDONLY
-// DAX_SYSFS_ROOT"/dax%d.%d/ranks/%d
-
-/* Rank state, 0 = free, 1 = busy */
-#define RANK_STATE_PATH "state"
-/* Rank acquisitions count */
-#define RANK_ACQUISITION_COUNT_PATH "acquisition_count"
-/* Get free size in bytes */
-#define RANK_FREE_SIZE_PATH "free_size"
-
-#define RANK_REGION_SIZE_PATH(region) "regions/" #region "/size"
-#define RANK_REGION_OFFSET_PATH(region) "regions/" #region "/offset"
-
-/* BASE region's size and offset */
-#define RANK_REGION_BASE_SIZE_PATH RANK_REGION_SIZE_PATH(base)
-#define RANK_REGION_BASE_OFFSET_PATH RANK_REGION_OFFSET_PATH(base)
-/* INST region's size and offset */
-#define RANK_REGION_INST_SIZE_PATH RANK_REGION_SIZE_PATH(inst)
-#define RANK_REGION_INST_OFFSET_PATH RANK_REGION_OFFSET_PATH(inst)
-/* CFGR region's size and offset */
-#define RANK_REGION_CFGR_SIZE_PATH RANK_REGION_SIZE_PATH(cfgr)
-#define RANK_REGION_CFGR_OFFSET_PATH RANK_REGION_OFFSET_PATH(cfgr)
-/* TAGS region's size and offset */
-#define RANK_REGION_TAGS_SIZE_PATH RANK_REGION_SIZE_PATH(tags)
-#define RANK_REGION_TAGS_OFFSET_PATH RANK_REGION_OFFSET_PATH(tags)
-/* PSUM region's size and offset */
-#define RANK_REGION_PSUM_SIZE_PATH RANK_REGION_SIZE_PATH(psum)
-#define RANK_REGION_PSUM_OFFSET_PATH RANK_REGION_OFFSET_PATH(psum)
-
-/* The enumeration of axdimm blocks addresses */
-enum axd_mem_blocks_e {
-	AXDIMM_BLOCK_BASE = 0,
-	AXDIMM_BLOCK_INST = 1,
-	AXDIMM_BLOCK_CFGR = 2,
-	AXDIMM_BLOCK_TAGS = 3,
-	AXDIMM_BLOCK_PSUM = 4,
-	AXDIMM_BLOCK_MAX = 5
-};
-
-/* The enumeration of table allocation preferences */
-enum axd_user_preferences {
-	AXDIMM_ALLOC_AUTO = 0,
-	AXDIMM_ALLOC_REPLICATE_ALL,
-	AXDIMM_ALLOC_DISTRIBUTE_ALL,
-	AXDIMM_ALLOC_SINGLE
-};
-
-#define AXD_USER_PREF_BITS 8
-#define AXD_USER_RANK_BITS 8
-
-#define AXD_USER_PREF_MASK ((1U << AXD_USER_PREF_BITS) - 1)
-#define AXD_USER_RANK_MASK \
-	(((1U << AXD_USER_RANK_BITS) - 1) << AXD_USER_PREF_BITS)
-
-#define AXDIMM_ALLOC_SINGLE_RANK(rank) \
-	(AXDIMM_ALLOC_SINGLE | ((rank + 1) << AXD_USER_PREF_BITS))
-
-#define GET_ALLOC_POLICY(preference) (preference & AXD_USER_PREF_MASK)
-#define GET_ALLOC_SINGLE_RANK_PREFERENCE(preference) \
-	((preference & AXD_USER_RANK_MASK) >> AXD_USER_PREF_BITS)
-
-struct axd_memory_object {
-	uint8_t rank;
-	/* Sometimes it's useful to know memory */
-	/* object mapping to its origin in user space */
-	uint64_t user_object_id;
-	uint64_t offset;
-	uint64_t length;
-};
-
-/* Tables allocation parameters */
-struct axd_memory_alloc_request {
-	uint64_t descriptor;
-	uint64_t *user_objects_sizes;
-	uint64_t num_user_objects;
-	enum axd_user_preferences preference;
-};
-
-/* Get memory objects by descriptor */
-struct axd_memory_alloc {
-	uint64_t descriptor;
-	uint64_t num_objects;
-	struct axd_memory_object *objects;
-};
-
-/* Get memory objects number by descriptor */
-struct axd_num_objects_request {
-	uint64_t descriptor;
-	uint64_t num_objects;
-};
-
-#define AXDIMM_IOC_MAGIC 'T'
-
-#define DEVICE_IOCRESET _IO(AXDIMM_IOC_MAGIC, 0)
-#define SET_FIRST_BUFFER _IO(AXDIMM_IOC_MAGIC, 1)
-#define SET_SECOND_BUFFER _IO(AXDIMM_IOC_MAGIC, 2)
-#define WHICH_BUFFER _IOR(AXDIMM_IOC_MAGIC, 3, int)
-#define ALLOCATE_MEMORY                                                        \
-	_IOWR(AXDIMM_IOC_MAGIC, 4, struct axd_memory_alloc_request *)
-#define GET_MEMORY_OBJECTS_NUM                                                 \
-	_IOWR(AXDIMM_IOC_MAGIC, 5, struct axd_num_objects_request *)
-#define GET_MEMORY_ALLOCATION                                                  \
-	_IOWR(AXDIMM_IOC_MAGIC, 6, struct axd_memory_alloc *)
-#define DEALLOCATE_MEMORY _IOW(AXDIMM_IOC_MAGIC, 7, uint64_t)
-#define GET_RANK_FOR_WRITE _IOW(AXDIMM_IOC_MAGIC, 8, unsigned int)
-#define GET_RANK_FOR_READ _IOW(AXDIMM_IOC_MAGIC, 9, unsigned int)
-#define RELEASE_WRITE_RANK _IOW(AXDIMM_IOC_MAGIC, 10, unsigned int)
-#define RELEASE_READ_RANK _IOW(AXDIMM_IOC_MAGIC, 11, unsigned int)
-
-#define AXDIMM_IOC_MAXNR (11)
 
 #endif
 
diff --git a/include/uapi/linux/sls_resources.h b/include/uapi/linux/sls_resources.h
new file mode 100644
index 000000000..604795806
--- /dev/null
+++ b/include/uapi/linux/sls_resources.h
@@ -0,0 +1,195 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2023 Samsung Electronics Co. LTD
+ *
+ * This software is proprietary of Samsung Electronics.
+ * No part of this software, either material or conceptual may be copied or
+ * distributed, transmitted, transcribed, stored in a retrieval system or
+ * translated into any human or computer language in any form by any means,
+ * electronic, mechanical, manual or otherwise, or disclosed to third parties
+ * without the express written permission of Samsung Electronics.
+ */
+#ifndef __SLS_RESOURCES_H__
+#define __SLS_RESOURCES_H__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h> // for uint64_t
+#endif
+#include <linux/libaxdimm.h>
+
+#define NUM_OF_RANK AXDIMM_NUM_OF_RANK
+
+/* Offset at config reg */
+#define REG_SLS_EN 0x0
+#define REG_SLS_EXEC 0x40
+#define REG_POLLING 0x840
+
+/* number of Instruction, Psum & Tags buffers */
+#define NUM_OF_INST_BUF 1
+#define NUM_OF_PSUM_BUF 2
+#define NUM_OF_TAGS_BUF 2
+
+/* Single TAG size (Bytes) */
+#define ALIGNED_TAG_SIZE 64
+
+/* Instruction Size (Bytes) */
+#define INSTRUCTION_SIZE 8
+
+/* Data Size (Bytes) */
+#define DATA_SIZE 4
+
+/* Instruction, Psum & Tags Buffers Size (Bytes) */
+#define HW_BUF_SIZE (256 * 1024)
+
+#define INST_BUF_SIZE HW_BUF_SIZE
+#define PSUM_BUF_SIZE HW_BUF_SIZE
+#define TAGS_BUF_SIZE HW_BUF_SIZE
+
+/* Path to SLS resource manager device within /dev */
+#define SLS_RESOURCE_PATH_INTERNAL "pnm/sls_resource"
+
+/* Path to SLS resource manager device */
+#define SLS_RESOURCE_PATH "/dev/" SLS_RESOURCE_PATH_INTERNAL
+
+/* Path to SLS memory device */
+#define SLS_MEMDEV_PATH "/dev/sls_device"
+
+/* Path to DAX device */
+#define DAX_PATH "/dev/dax0.0"
+
+/* Path to sls_resource sysfs root */
+/* [TODO: @a.korzun] Rename this to SLS_SYSFS_ROOT or a similar name. */
+#define DAX_SYSFS_ROOT "/sys/class/sls_resource"
+
+// Block of sysfs relative paths for device
+// DAX_SYSFS_ROOT"/dax%d.%d/ranks"
+
+/* O_WRONLY Path to reset device, write "1" for reset */
+#define DEVICE_RESET_PATH "reset"
+/* O_RDWR Path to acquisition timeout, measured in ns */
+#define DEVICE_ACQUISITION_TIMEOUT_PATH "acq_timeout"
+/*
+ * O_RDWR Path to enabling/disabling cleanup of leaked resources by
+ * resource manager, write "1" to enable and "0" to disable
+ */
+#define DEVICE_RESOURCE_CLEANUP_PATH "cleanup"
+/*
+ * O_RDONLY Path to read resource leakage status, holds number of processes
+ * failed to free resources before exit
+ */
+#define DEVICE_LEAKED_PATH "leaked"
+
+// Block of sysfs paths for ranks info, all O_RDONLY
+// DAX_SYSFS_ROOT"/dax%d.%d/ranks/%d
+
+/* Rank state, 0 = free, 1 = busy */
+#define RANK_STATE_PATH "state"
+/* Rank acquisitions count */
+#define RANK_ACQUISITION_COUNT_PATH "acquisition_count"
+/* Get free size in bytes */
+#define RANK_FREE_SIZE_PATH "free_size"
+
+#define RANK_REGION_SIZE_PATH(region) "regions/" #region "/size"
+#define RANK_REGION_OFFSET_PATH(region) "regions/" #region "/offset"
+
+/* BASE region's size and offset */
+#define RANK_REGION_BASE_SIZE_PATH RANK_REGION_SIZE_PATH(base)
+#define RANK_REGION_BASE_OFFSET_PATH RANK_REGION_OFFSET_PATH(base)
+/* INST region's size and offset */
+#define RANK_REGION_INST_SIZE_PATH RANK_REGION_SIZE_PATH(inst)
+#define RANK_REGION_INST_OFFSET_PATH RANK_REGION_OFFSET_PATH(inst)
+/* CFGR region's size and offset */
+#define RANK_REGION_CFGR_SIZE_PATH RANK_REGION_SIZE_PATH(cfgr)
+#define RANK_REGION_CFGR_OFFSET_PATH RANK_REGION_OFFSET_PATH(cfgr)
+/* TAGS region's size and offset */
+#define RANK_REGION_TAGS_SIZE_PATH RANK_REGION_SIZE_PATH(tags)
+#define RANK_REGION_TAGS_OFFSET_PATH RANK_REGION_OFFSET_PATH(tags)
+/* PSUM region's size and offset */
+#define RANK_REGION_PSUM_SIZE_PATH RANK_REGION_SIZE_PATH(psum)
+#define RANK_REGION_PSUM_OFFSET_PATH RANK_REGION_OFFSET_PATH(psum)
+
+/* The enumeration of sls blocks addresses */
+enum sls_mem_blocks_e {
+	SLS_BLOCK_BASE = 0,
+	SLS_BLOCK_INST = 1,
+	SLS_BLOCK_CFGR = 2,
+	SLS_BLOCK_TAGS = 3,
+	SLS_BLOCK_PSUM = 4,
+	SLS_BLOCK_MAX = 5
+};
+
+/* The enumeration of table allocation preferences */
+enum sls_user_preferences {
+	SLS_ALLOC_AUTO = 0,
+	SLS_ALLOC_REPLICATE_ALL,
+	SLS_ALLOC_DISTRIBUTE_ALL,
+	SLS_ALLOC_SINGLE
+};
+
+#define SLS_USER_PREF_BITS 8
+#define SLS_USER_RANK_BITS 8
+
+#define SLS_USER_PREF_MASK ((1U << SLS_USER_PREF_BITS) - 1)
+#define SLS_USER_RANK_MASK \
+	(((1U << SLS_USER_RANK_BITS) - 1) << SLS_USER_PREF_BITS)
+
+#define SLS_ALLOC_SINGLE_RANK(rank) \
+	(SLS_ALLOC_SINGLE | ((rank + 1) << SLS_USER_PREF_BITS))
+
+#define GET_ALLOC_POLICY(preference) (preference & SLS_USER_PREF_MASK)
+#define GET_ALLOC_SINGLE_RANK_PREFERENCE(preference) \
+	((preference & SLS_USER_RANK_MASK) >> SLS_USER_PREF_BITS)
+
+struct sls_memory_object {
+	uint8_t rank;
+	/* Sometimes it's useful to know memory */
+	/* object mapping to its origin in user space */
+	uint64_t user_object_id;
+	uint64_t offset;
+	uint64_t length;
+};
+
+/* Tables allocation parameters */
+struct sls_memory_alloc_request {
+	uint64_t descriptor;
+	uint64_t *user_objects_sizes;
+	uint64_t num_user_objects;
+	enum sls_user_preferences preference;
+};
+
+/* Get memory objects by descriptor */
+struct sls_memory_alloc {
+	uint64_t descriptor;
+	uint64_t num_objects;
+	struct sls_memory_object *objects;
+};
+
+/* Get memory objects number by descriptor */
+struct sls_num_objects_request {
+	uint64_t descriptor;
+	uint64_t num_objects;
+};
+
+#define SLS_IOC_MAGIC 'T'
+
+#define DEVICE_IOCRESET _IO(SLS_IOC_MAGIC, 0)
+#define SET_FIRST_BUFFER _IO(SLS_IOC_MAGIC, 1)
+#define SET_SECOND_BUFFER _IO(SLS_IOC_MAGIC, 2)
+#define WHICH_BUFFER _IOR(SLS_IOC_MAGIC, 3, int)
+#define ALLOCATE_MEMORY                                                        \
+	_IOWR(SLS_IOC_MAGIC, 4, struct sls_memory_alloc_request *)
+#define GET_MEMORY_OBJECTS_NUM                                                 \
+	_IOWR(SLS_IOC_MAGIC, 5, struct sls_num_objects_request *)
+#define GET_MEMORY_ALLOCATION                                                  \
+	_IOWR(SLS_IOC_MAGIC, 6, struct sls_memory_alloc *)
+#define DEALLOCATE_MEMORY _IOW(SLS_IOC_MAGIC, 7, uint64_t)
+#define GET_RANK_FOR_WRITE _IOW(SLS_IOC_MAGIC, 8, unsigned int)
+#define GET_RANK_FOR_READ _IOW(SLS_IOC_MAGIC, 9, unsigned int)
+#define RELEASE_WRITE_RANK _IOW(SLS_IOC_MAGIC, 10, unsigned int)
+#define RELEASE_READ_RANK _IOW(SLS_IOC_MAGIC, 11, unsigned int)
+
+#define SLS_IOC_MAXNR (11)
+
+#endif /* __SLS_RESOURCES_H__ */
diff --git a/install_axdimm_resource.sh b/install_axdimm_resource.sh
deleted file mode 100755
index 30be9c996..000000000
--- a/install_axdimm_resource.sh
+++ /dev/null
@@ -1,13 +0,0 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0
-# Copyright(c) 2023 Samsung LTD. All rights reserved.
-
-set -e
-
-script_dir="`dirname "$0"`"
-
-sudo cp -v drivers/pnm/axdimm_resource/*.ko \
- /lib/modules/`uname -r`/kernel/drivers/pnm/axdimm_resource/
-sudo modprobe axdimm_resource "$@"
-
-sh "$script_dir/install_axdimm_headers.sh"
diff --git a/install_dax_drivers.sh b/install_dax_drivers.sh
index 32a75d71d..0d3a114f9 100755
--- a/install_dax_drivers.sh
+++ b/install_dax_drivers.sh
@@ -9,7 +9,7 @@ script_dir="`dirname "$0"`"
 sudo cp -v drivers/dax/*.ko /lib/modules/`uname -r`/kernel/drivers/dax/
 sudo cp -v drivers/dax/hmem/*.ko /lib/modules/`uname -r`/kernel/drivers/dax/hmem
 
-sh "$script_dir/install_axdimm_headers.sh"
+sh "$script_dir/install_sls_headers.sh"
 
 lsmod | grep device_dax > /dev/null && sudo rmmod device_dax
 sudo modprobe -v device_dax "$@"
diff --git a/install_axdimm_headers.sh b/install_sls_headers.sh
similarity index 60%
rename from install_axdimm_headers.sh
rename to install_sls_headers.sh
index 8b44dfebe..00bcad25f 100755
--- a/install_axdimm_headers.sh
+++ b/install_sls_headers.sh
@@ -7,3 +7,7 @@ set -e
 sudo cp -v include/uapi/linux/libaxdimm.h /usr/include/linux
 sudo cp -v include/uapi/linux/libaxdimm.h \
  /usr/src/linux-headers-`uname -r`/include/uapi/linux/libaxdimm.h
+
+sudo cp -v include/uapi/linux/sls_resources.h /usr/include/linux
+sudo cp -v include/uapi/linux/sls_resources.h \
+ /usr/src/linux-headers-`uname -r`/include/uapi/linux/sls_resources.h
diff --git a/install_sls_resource.sh b/install_sls_resource.sh
new file mode 100755
index 000000000..71c5b3131
--- /dev/null
+++ b/install_sls_resource.sh
@@ -0,0 +1,13 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0
+# Copyright(c) 2023 Samsung LTD. All rights reserved.
+
+set -e
+
+script_dir="`dirname "$0"`"
+
+sudo cp -v drivers/pnm/sls_resource/*.ko \
+ /lib/modules/`uname -r`/kernel/drivers/pnm/sls_resource/
+sudo modprobe sls_resource "$@"
+
+sh "$script_dir/install_sls_headers.sh"
-- 
2.34.1

