From d0e5435cf13310a4cb1b23a858b725687f478f67 Mon Sep 17 00:00:00 2001
From: Petr Bred <p.bred@samsung.com>
Date: Wed, 2 Aug 2023 18:15:36 +0000
Subject: [PATCH 167/225] [SLS] Dynamic topology

- Added device mappings
- Device mappings exported to sysfs
- Added cuits mappings
- Cunits mappings exported to sysfs
- Dax depends on sls_resource

Resolved: MCS23-1166

Signed-off-by: Petr Bred <p.bred@samsung.com>
Signed-off-by: Savelii Motov <s.motov@samsung.com>
---
 drivers/dax/sls_dax.c                         | 152 +++-----
 drivers/dax/sls_dax.h                         |   9 +-
 drivers/pnm/Kconfig                           |   2 +-
 drivers/pnm/sls_resource/Makefile             |  17 +-
 drivers/pnm/sls_resource/allocator.c          |  67 ++--
 drivers/pnm/sls_resource/allocator.h          |   8 +-
 drivers/pnm/sls_resource/mem_info.c           | 124 ++++++
 drivers/pnm/sls_resource/mem_info.h           |  16 +
 drivers/pnm/sls_resource/parameters.c         |  50 ---
 drivers/pnm/sls_resource/parameters.h         |  36 --
 drivers/pnm/sls_resource/private.h            |  11 -
 drivers/pnm/sls_resource/process_manager.c    |   7 +-
 drivers/pnm/sls_resource/process_manager.h    |   4 +-
 drivers/pnm/sls_resource/rank_scheduler.c     |  34 +-
 drivers/pnm/sls_resource/rank_scheduler.h     |   4 -
 drivers/pnm/sls_resource/sls.c                | 108 ++---
 drivers/pnm/sls_resource/sysfs.c              | 368 +++++++++++++++---
 drivers/pnm/sls_resource/sysfs.h              |   9 +-
 drivers/pnm/sls_resource/topo/axdimm.h        |  35 ++
 drivers/pnm/sls_resource/topo/cxl.h           |  37 ++
 drivers/pnm/sls_resource/topo/export.c        | 116 ++++++
 .../{topology_export.h => topo/export.h}      |   2 +-
 drivers/pnm/sls_resource/topo/params.c        | 217 +++++++++++
 drivers/pnm/sls_resource/topo/params.h        |  38 ++
 drivers/pnm/sls_resource/topology_export.c    | 151 -------
 include/linux/pnm_sls_set_mem_info.h          | 145 -------
 include/linux/sls_common.h                    |  66 ++--
 include/uapi/linux/pnm_sls_mem_topology.h     |  29 --
 include/uapi/linux/sls_resources.h            |  85 ++--
 install_sls_headers.sh                        |   4 -
 30 files changed, 1126 insertions(+), 825 deletions(-)
 create mode 100644 drivers/pnm/sls_resource/mem_info.c
 create mode 100644 drivers/pnm/sls_resource/mem_info.h
 delete mode 100644 drivers/pnm/sls_resource/parameters.c
 delete mode 100644 drivers/pnm/sls_resource/parameters.h
 create mode 100644 drivers/pnm/sls_resource/topo/axdimm.h
 create mode 100644 drivers/pnm/sls_resource/topo/cxl.h
 create mode 100644 drivers/pnm/sls_resource/topo/export.c
 rename drivers/pnm/sls_resource/{topology_export.h => topo/export.h} (92%)
 create mode 100644 drivers/pnm/sls_resource/topo/params.c
 create mode 100644 drivers/pnm/sls_resource/topo/params.h
 delete mode 100644 drivers/pnm/sls_resource/topology_export.c
 delete mode 100644 include/linux/pnm_sls_set_mem_info.h
 delete mode 100644 include/uapi/linux/pnm_sls_mem_topology.h

diff --git a/drivers/dax/sls_dax.c b/drivers/dax/sls_dax.c
index 23b6237dc..38d64e4cb 100644
--- a/drivers/dax/sls_dax.c
+++ b/drivers/dax/sls_dax.c
@@ -3,7 +3,6 @@
 
 #include "sls_dax.h"
 
-#include <linux/pnm_sls_set_mem_info.h>
 #include <linux/pgtable.h>
 #include <linux/memremap.h>
 #include <linux/pagemap.h>
@@ -11,84 +10,43 @@
 
 #define LOG_PREFIX "[sls_dax] "
 
-static const struct sls_mem_info *get_mem_info(void)
+static inline bool is_writecombine_region(enum sls_mem_blocks_e type)
 {
-	static struct sls_mem_info mem_info;
-
-	mem_info.devtype = get_device_type(sls_device_name);
-	mem_info.num_of_cs = sls_param_num_of_chip_select;
-
-	mem_info.mem_offset = kcalloc(mem_info.num_of_cs * SLS_BLOCK_MAX,
-				      sizeof(uint64_t), GFP_KERNEL);
-	mem_info.mem_size = kcalloc(mem_info.num_of_cs * SLS_BLOCK_MAX,
-				    sizeof(uint64_t), GFP_KERNEL);
-
-	if (mem_info.mem_size == NULL || mem_info.mem_offset == NULL) {
-		kfree(mem_info.mem_offset);
-		kfree(mem_info.mem_size);
-		return NULL;
-	}
-
-	sls_set_mem_info(&mem_info);
-
-	return &mem_info;
-}
-
-/*
- * Set offsets for SLS blocks with different caching policies
- */
-static int set_ioremap_info(ulong *offset)
-{
-	const struct sls_mem_info *mem_info = get_mem_info();
-
-	if (mem_info == NULL)
-		return -ENOMEM;
-
-	/* Set offset(iomem resource start address) */
-	offset[SLS_BASE_CS0] = mem_info->mem_offset[0][SLS_BLOCK_BASE];
-	offset[SLS_TAGS_CS0] = mem_info->mem_offset[0][SLS_BLOCK_TAGS];
-	offset[SLS_PSUM_CS0] = mem_info->mem_offset[0][SLS_BLOCK_PSUM];
-	offset[SLS_BASE_CS1] = mem_info->mem_offset[1][SLS_BLOCK_BASE];
-	offset[SLS_TAGS_CS1] = mem_info->mem_offset[1][SLS_BLOCK_TAGS];
-	offset[SLS_PSUM_CS1] = mem_info->mem_offset[1][SLS_BLOCK_PSUM];
-
-	kfree(mem_info->mem_offset);
-	kfree(mem_info->mem_size);
-
-	return 0;
+	return type == SLS_BLOCK_BASE || type == SLS_BLOCK_CFGR ||
+	       type == SLS_BLOCK_INST;
 }
 
-static bool is_writecombine_region(int region_no)
+static inline bool is_in_range(unsigned long phys_offset,
+			       const struct range *range)
 {
-	return region_no == SLS_BASE_CS0 || region_no == SLS_BASE_CS1;
+	return phys_offset >= range->start && phys_offset < range->end;
 }
 
 static int get_page_prot(struct vm_area_struct *vma, pgprot_t *p_prot)
 {
-	unsigned long offset[NUM_OF_MEM_REGION];
 	int i;
-	unsigned long phys_offset;
+	const unsigned long phys_offset = vma->vm_pgoff << PAGE_SHIFT;
+	// [TODO: @p-bred] do not allocate memory on each mapping syscall
+	const struct sls_mem_info *mem_info = sls_create_mem_info();
 
-	if (set_ioremap_info(offset))
+	if (!mem_info)
 		return -ENOMEM;
 
-	/* set physical offsets for SLS blocks with different caching policies */
-	phys_offset = vma->vm_pgoff << PAGE_SHIFT;
-
-	for (i = 0; i < NUM_OF_MEM_REGION - 1; ++i) {
-		if (phys_offset >= offset[i] && phys_offset < offset[i + 1]) {
-			if (is_writecombine_region(i)) {
-				*p_prot =
-					pgprot_writecombine(vma->vm_page_prot);
-				return 0;
-			}
-			*p_prot = vma->vm_page_prot;
-			return 0;
+	/* WB by default */
+	*p_prot = vma->vm_page_prot;
+
+	/* set WC caching policy for SLS BASE blocks */
+	for (i = 0; i < mem_info->nr_regions; ++i) {
+		if (!is_in_range(phys_offset, &mem_info->regions[i].range))
+			continue;
+
+		if (is_writecombine_region(mem_info->regions[i].type)) {
+			*p_prot = pgprot_writecombine(vma->vm_page_prot);
+			break;
 		}
 	}
 
-	/* last region corresponds to cs1 PSUM which is write-back */
-	*p_prot = vma->vm_page_prot;
+	sls_destroy_mem_info(mem_info);
 	return 0;
 }
 
@@ -123,46 +81,58 @@ int sls_dax_mmap(struct file *filep, struct vm_area_struct *vma)
 
 static int setup_sls_ranges(struct dev_dax *dev_dax)
 {
-	struct dev_dax_range *ranges;
 	unsigned long pgoff = 0;
-	unsigned long orig_range_start = dev_dax->ranges[0].range.start;
-	int i, rc, cs, block;
-	unsigned long start, end;
-	const struct sls_mem_info *mem_info = get_mem_info();
+	const uint64_t orig_range_start = dev_dax->ranges[0].range.start;
+	const struct sls_mem_info *mem_info = sls_create_mem_info();
+	uint64_t start, end;
+	struct dev_dax_range *ranges;
+	int i;
+	int rc = 0;
 
-	if (mem_info == NULL)
-		return -ENOMEM;
+	if (!mem_info) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	if (orig_range_start < SLS_BASE_ADDR) {
+		pr_err(LOG_PREFIX "Setup sls ranges failed\n");
+		rc = -EFAULT;
+		goto mem_info_err;
+	}
 
-	rc = 0;
-	dev_dax->nr_range = SLS_BLOCK_MAX * mem_info->num_of_cs;
+	dev_dax->nr_range = mem_info->nr_regions;
 	ranges = krealloc(dev_dax->ranges, sizeof(*ranges) * dev_dax->nr_range,
 			  GFP_KERNEL);
+	if (!ranges) {
+		rc = -ENOMEM;
+		goto mem_info_err;
+	}
 
 	dev_dax->ranges = ranges;
 	for (i = 0; i < dev_dax->nr_range; ++i) {
-		cs = i / SLS_BLOCK_MAX;
-		block = i % SLS_BLOCK_MAX;
 		/* The range[0].start, which is set up by devdax driver,
 		 * has an offset from SLS_BASE_ADDR because __dax_pmem_probe
 		 * reserves memory space for 'struct page' list used for ZONE_DEVICE.
 		 * See 'nd_pfn_init' from drivers/nvdimm/pfn_devs.c to understand how
 		 * this offset is calculated.
-		 * Yet for 'end' should be calculcated as if start equals to
+		 * Yet for 'end' should be calculated as if start equals to
 		 * SLS_BASE_ADDR.
 		 */
-		if (i == 0) {
+		if (i == 0)
 			start = orig_range_start;
-			end = SLS_BASE_ADDR + mem_info->mem_size[cs][block] - 1;
-		} else {
-			start = mem_info->mem_offset[cs][block] + SLS_BASE_ADDR;
-			end = start + mem_info->mem_size[cs][block] - 1;
-		}
-		ranges[i] = (struct dev_dax_range) {
-		.pgoff = pgoff,
-		.range = {
-			.start = start,
-			.end = end,
-			},
+		else
+			start = SLS_BASE_ADDR +
+				mem_info->regions[i].range.start;
+
+		end = SLS_BASE_ADDR + mem_info->regions[i].range.end;
+
+		ranges[i] = (struct dev_dax_range){
+			.pgoff = pgoff,
+			.range =
+				(struct range){
+					.start = start,
+					.end = end,
+				},
 		};
 		pgoff += PHYS_PFN(range_len(&ranges[i].range));
 		pr_info(LOG_PREFIX
@@ -170,9 +140,9 @@ static int setup_sls_ranges(struct dev_dax *dev_dax)
 			i, ranges[i].range.start, ranges[i].range.end);
 	}
 
-	kfree(mem_info->mem_offset);
-	kfree(mem_info->mem_size);
-
+mem_info_err:
+	sls_destroy_mem_info(mem_info);
+out:
 	return rc;
 }
 
diff --git a/drivers/dax/sls_dax.h b/drivers/dax/sls_dax.h
index 9a5680327..bf65fb7ea 100644
--- a/drivers/dax/sls_dax.h
+++ b/drivers/dax/sls_dax.h
@@ -9,14 +9,13 @@
 #include <linux/pgtable.h>
 #include "dax-private.h"
 
-#include <linux/sls_common.h>
-
 #include <linux/fs.h>
 #include <linux/mm_types.h>
+#include <linux/module.h>
+#include <linux/sls_common.h>
 
-extern int sls_param_num_of_rank;
-extern int sls_param_num_of_chip_select;
-extern char *sls_device_name;
+extern struct sls_mem_info *sls_create_mem_info(void);
+extern void sls_destroy_mem_info(const struct sls_mem_info *mem_info);
 
 int sls_dax_mmap(struct file *filep, struct vm_area_struct *vma);
 int init_sls_dax_device(struct dev_dax *dev_dax);
diff --git a/drivers/pnm/Kconfig b/drivers/pnm/Kconfig
index 6ebb65bcb..822a7907e 100644
--- a/drivers/pnm/Kconfig
+++ b/drivers/pnm/Kconfig
@@ -16,7 +16,7 @@ config SLS_RESOURCE
 	  Support for management of SLS device resources
 
 	  Create /dev/pnm/sls_resource entry which is responsible for
-	  providing such sls device resources as: ranks, memory to userspace
+	  providing such sls device resources as: cunits, memory to userspace
 	  by means of ioctl interface. Also it provide monitoring facilities
 	  using sysfs interface.
 
diff --git a/drivers/pnm/sls_resource/Makefile b/drivers/pnm/sls_resource/Makefile
index a4b12f97c..1c67d30f9 100644
--- a/drivers/pnm/sls_resource/Makefile
+++ b/drivers/pnm/sls_resource/Makefile
@@ -1,13 +1,16 @@
 obj-$(CONFIG_SLS_RESOURCE) += sls_resource.o
 
 CFLAGS_sls.o += -DSLS_DRIVER_VERSION=\"$(shell git rev-parse --short HEAD)\"
-subdir-ccflags-y := -I $(srctree)/$(src)/..
+subdir-ccflags-y += -I $(srctree)/$(src)/ -I $(srctree)/$(src)/..
 
-sls_resource-y := resource.o
-sls_resource-y += sls.o
-sls_resource-y += allocator.o
-sls_resource-y += process_manager.o
+topo-y := topo/export.o
+topo-y += topo/params.o
+
+sls_resource-y := allocator.o
 sls_resource-y += rank_scheduler.o
+sls_resource-y += mem_info.o
+sls_resource-y += process_manager.o
+sls_resource-y += sls.o
 sls_resource-y += sysfs.o
-sls_resource-y += topology_export.o
-sls_resource-y += parameters.o
+sls_resource-y += resource.o
+sls_resource-y += $(topo-y)
diff --git a/drivers/pnm/sls_resource/allocator.c b/drivers/pnm/sls_resource/allocator.c
index 14390783a..feb0dd295 100644
--- a/drivers/pnm/sls_resource/allocator.c
+++ b/drivers/pnm/sls_resource/allocator.c
@@ -3,9 +3,9 @@
 
 #include "allocator.h"
 #include "log.h"
-#include "parameters.h"
 #include "private.h"
 #include "process_manager.h"
+#include "topo/params.h"
 
 #include <linux/genalloc.h>
 #include <linux/kernel.h>
@@ -15,21 +15,17 @@
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 
-#define HUGE_PAGE_SIZE (2 << 20)
-
 /* Helper structure for memory allocation */
 struct allocator {
 	/* Allocator granularity in bytes, the number should be a power of 2 */
 	uint64_t gran;
-	uint64_t num_of_cs;
-	/* GenAlloc memory pools for each rank, each pool has it's own virtual
+	/* GenAlloc memory pools for each cunit, each pool has it's own virtual
 	 * range, currently this range is not bound to the real memory by PA,
-	 * Range: [reserved_indent == PAGE_SIZE, rank_size - reserved_indent]
+	 * Range: [reserved_indent == PAGE_SIZE, cunit_size - reserved_indent]
 	 */
 	struct gen_pool **pools;
 	uint8_t nr_pools;
-	enum sls_device_type devtype;
-	struct sls_mem_info *mem_info;
+	const struct sls_mem_cunit_info *mem_cunit_info;
 } static allocator;
 
 DEFINE_MUTEX(memory_mutex);
@@ -112,18 +108,21 @@ static void cleanup_pools(struct allocator *alloc)
 	kfree(alloc->pools);
 }
 
-static inline uint64_t get_rank_size(struct allocator *alloc, uint8_t rank)
+static inline uint64_t get_rank_size(struct allocator *alloc, uint8_t cunit)
 {
-	uint64_t num_of_ranks_per_cs =
-		sls_param_num_of_rank / sls_param_num_of_chip_select;
-	uint64_t size =
-		alloc->mem_info
-			->mem_size[rank % alloc->num_of_cs][SLS_BLOCK_BASE];
-
-	if (alloc->devtype == SLS_AXDIMM)
-		size /= num_of_ranks_per_cs;
-
-	return size;
+	const uint64_t nr_cunits = alloc->mem_cunit_info->nr_cunits;
+	const uint64_t nr_regions_per_cunit =
+		alloc->mem_cunit_info->nr_regions / nr_cunits;
+	const struct sls_mem_cunit_region *cunit_regions =
+		&alloc->mem_cunit_info->regions[cunit * nr_regions_per_cunit];
+	uint64_t idx;
+
+	for (idx = 0; idx < nr_regions_per_cunit; ++idx)
+		if (cunit_regions[idx].type == SLS_BLOCK_BASE)
+			return range_len(&cunit_regions[idx].range);
+
+	SLS_ERR("There is no BASE region for cunit[%hhu]\n", cunit);
+	return 0;
 }
 
 static int init_pools(struct allocator *alloc)
@@ -168,42 +167,30 @@ static int set_granularity(struct allocator *alloc, uint64_t gran)
 }
 
 // [TODO: @p.bred] Generalize all PNM allocators logic
-static int init(struct allocator *alloc, struct sls_mem_info *mem_info,
-		enum sls_device_type devtype)
+static int init(struct allocator *alloc,
+		const struct sls_mem_cunit_info *mem_cunit_info)
 {
 	int err = 0;
 
-	if (devtype == SLS_UNDEFINED) {
-		SLS_ERR("Initialize an allocator with an undefined device!\n");
+	if (!mem_cunit_info) {
+		SLS_ERR("mem_cunit_info is NULL!\n");
 		return -EINVAL;
 	}
 
-	if (!mem_info) {
-		SLS_ERR("mem_info is NULL!\n");
-		return -EINVAL;
-	}
+	alloc->mem_cunit_info = mem_cunit_info;
+	alloc->nr_pools = mem_cunit_info->nr_cunits;
 
-	alloc->mem_info = mem_info;
-	alloc->devtype = devtype;
-	alloc->num_of_cs = sls_param_num_of_chip_select;
-	alloc->nr_pools = sls_param_num_of_rank;
-
-	if (alloc->devtype == SLS_AXDIMM) {
-		err = set_granularity(alloc, PAGE_SIZE);
-	} else { /* SLS_CXL case */
-		err = set_granularity(alloc, HUGE_PAGE_SIZE);
-	}
+	err = set_granularity(alloc, sls_topo()->alignment_sz);
 	if (err)
 		return err;
 
 	return init_pools(alloc);
 }
 
-int init_sls_allocator(struct sls_mem_info *mem_info,
-		       enum sls_device_type devtype)
+int init_sls_allocator(const struct sls_mem_cunit_info *mem_cunit_info)
 {
 	SLS_DBG("Initializing SLS allocator\n");
-	return init(&allocator, mem_info, devtype);
+	return init(&allocator, mem_cunit_info);
 }
 
 static void reset_lock(void)
diff --git a/drivers/pnm/sls_resource/allocator.h b/drivers/pnm/sls_resource/allocator.h
index 2fc82558f..9b7d1e842 100644
--- a/drivers/pnm/sls_resource/allocator.h
+++ b/drivers/pnm/sls_resource/allocator.h
@@ -6,15 +6,11 @@
 
 #include <linux/fs.h>
 #include <linux/list.h>
+#include <linux/sls_common.h>
 #include <linux/sls_resources.h>
 #include <linux/types.h>
 
-//[TODO: s-motov] make common sls_dev structure
-struct sls_mem_info;
-enum sls_device_type;
-
-int init_sls_allocator(struct sls_mem_info *mem_info,
-		       enum sls_device_type devtype);
+int init_sls_allocator(const struct sls_mem_cunit_info *mem_cunit_info);
 /*
  * Not proccess(thread)-safe.
  * `mem_info` might be NULL, if it is
diff --git a/drivers/pnm/sls_resource/mem_info.c b/drivers/pnm/sls_resource/mem_info.c
new file mode 100644
index 000000000..04b617c4f
--- /dev/null
+++ b/drivers/pnm/sls_resource/mem_info.c
@@ -0,0 +1,124 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 2021-2023 Samsung LTD. All rights reserved. */
+
+#include "mem_info.h"
+#include "topo/params.h"
+
+#include <linux/module.h>
+#include <linux/slab.h>
+
+const struct sls_mem_info *sls_create_mem_info(void)
+{
+	const size_t nr_regions = sls_topo()->nr_cs * SLS_BLOCK_MAX;
+	struct sls_mem_info *mem_info = NULL;
+	size_t start = 0;
+	enum sls_mem_blocks_e type;
+	uint8_t idx;
+
+	mem_info =
+		kzalloc(struct_size(mem_info, regions, nr_regions), GFP_KERNEL);
+
+	if (!mem_info)
+		return NULL;
+
+	mem_info->nr_regions = nr_regions;
+
+	for (idx = 0; idx < nr_regions; ++idx) {
+		type = idx % SLS_BLOCK_MAX;
+
+		mem_info->regions[idx].range = (struct range){
+			.start = start,
+			.end = start + sls_topo()->block_sz[type] -
+			       1, // struct range is closed
+		};
+
+		mem_info->regions[idx].type = type;
+		start = mem_info->regions[idx].range.end +
+			1; // struct range is closed
+	}
+
+	return mem_info;
+}
+EXPORT_SYMBOL(sls_create_mem_info);
+
+void sls_destroy_mem_info(const struct sls_mem_info *mem_info)
+{
+	kfree(mem_info);
+}
+EXPORT_SYMBOL(sls_destroy_mem_info);
+
+static inline void make_cuinit_regions(uint64_t nr_regions_per_cunit,
+				       struct sls_mem_cunit_region *dst_regions,
+				       const struct sls_mem_region *src_regions)
+{
+	const int cunits_per_cs = sls_topo()->nr_cunits / sls_topo()->nr_cs;
+	const struct sls_mem_region *src = src_regions;
+	struct sls_mem_cunit_region *dst = dst_regions;
+	uint8_t r = 0;
+
+	for (r = 0; r < nr_regions_per_cunit; ++r) {
+		dst[r].type = src[r].type;
+		dst[r].map_range = dst[r].range = src[r].range;
+		dst[r].range.end = dst[r].range.start +
+				   range_len(&src[r].range) / cunits_per_cs - 1;
+	}
+}
+
+static inline void apply_interleaving(uint64_t nr_regions_per_cunit, u64 cs,
+				      struct sls_mem_cunit_region *dst)
+{
+	const size_t interleaving = cs * sls_topo()->interleaving_stride;
+	uint8_t r = 0;
+
+	for (r = 0; r < nr_regions_per_cunit; ++r) {
+		dst[r].range.start += interleaving;
+		dst[r].range.end += interleaving;
+	}
+}
+
+const struct sls_mem_cunit_info *
+sls_create_mem_cunit_info(const struct sls_mem_info *mem_info)
+{
+	const uint64_t nr_cunits = sls_topo()->nr_cunits;
+	const uint64_t nr_regions_per_cunit = SLS_BLOCK_MAX;
+	const uint64_t nr_regions = nr_regions_per_cunit * nr_cunits;
+	struct sls_mem_cunit_info *mem_cunit_info = NULL;
+	const struct sls_mem_region *src = NULL;
+	struct sls_mem_cunit_region *dst = NULL;
+	uint8_t cu = 0, cs = 0;
+
+	mem_cunit_info = kzalloc(
+		struct_size(mem_cunit_info, regions, nr_regions), GFP_KERNEL);
+
+	if (!mem_cunit_info)
+		return NULL;
+
+	mem_cunit_info->nr_cunits = nr_cunits;
+	mem_cunit_info->nr_regions = nr_regions;
+
+	/* Here we create compute units layout */
+	for (cu = 0; cu < nr_cunits; ++cu) {
+		/* get cs from cunit */
+		cs = cu % sls_topo()->nr_cs;
+
+		/* choose cunit regions array */
+		dst = &mem_cunit_info->regions[cu * nr_regions_per_cunit];
+
+		/* choose device regions array */
+		src = &mem_info->regions[cs * nr_regions_per_cunit];
+
+		/* form cunit address layout */
+		make_cuinit_regions(nr_regions_per_cunit, dst, src);
+
+		/* apply cunit interleaving */
+		apply_interleaving(nr_regions_per_cunit, cs, dst);
+	}
+
+	return mem_cunit_info;
+}
+
+void sls_destroy_mem_cunit_info(const struct sls_mem_cunit_info *cunit_mem_info)
+{
+	kfree(cunit_mem_info);
+}
+EXPORT_SYMBOL(sls_destroy_mem_cunit_info);
diff --git a/drivers/pnm/sls_resource/mem_info.h b/drivers/pnm/sls_resource/mem_info.h
new file mode 100644
index 000000000..580f195be
--- /dev/null
+++ b/drivers/pnm/sls_resource/mem_info.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2021-2023 Samsung LTD. All rights reserved. */
+
+#ifndef __MEM_INFO_H__
+#define __MEM_INFO_H__
+
+#include <linux/sls_common.h>
+
+const struct sls_mem_info *sls_create_mem_info(void);
+void sls_destroy_mem_info(const struct sls_mem_info *mem_info);
+
+const struct sls_mem_cunit_info *
+sls_create_mem_cunit_info(const struct sls_mem_info *mem_info);
+void sls_destroy_mem_cunit_info(const struct sls_mem_cunit_info *cunit_mem_info);
+
+#endif /* __MEM_INFO_H__ */
diff --git a/drivers/pnm/sls_resource/parameters.c b/drivers/pnm/sls_resource/parameters.c
deleted file mode 100644
index e18ee69c5..000000000
--- a/drivers/pnm/sls_resource/parameters.c
+++ /dev/null
@@ -1,50 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
-
-#include "parameters.h"
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-
-//[TODO: y-lavrinenko] Add the parameters validation
-int sls_param_num_of_rank = 0x4;
-EXPORT_SYMBOL(sls_param_num_of_rank);
-int sls_param_num_of_chip_select = 0x2;
-EXPORT_SYMBOL(sls_param_num_of_chip_select);
-int sls_param_num_of_channel = 0x2;
-int sls_param_rank_interleaving_size = 0x80;
-int sls_param_channel_interleaving_size = 0x20000;
-int sls_param_interleaving_stride_len = 0x80;
-int sls_param_register_exec = 0x40;
-int sls_param_register_enable;
-int sls_param_register_polling = 0x840;
-int sls_param_aligned_tag_size = 64;
-int sls_param_instruction_size = 8;
-int sls_param_data_size = 4;
-
-module_param_named(num_of_rank, sls_param_num_of_rank, int, 0400);
-module_param_named(num_of_cs, sls_param_num_of_chip_select, int, 0400);
-module_param_named(num_of_ch, sls_param_num_of_channel, int, 0400);
-module_param_named(rank_interleaving_size, sls_param_rank_interleaving_size,
-		   int, 0400);
-module_param_named(channel_interleaving_size,
-		   sls_param_channel_interleaving_size, int, 0400);
-module_param_named(interleaving_stride, sls_param_interleaving_stride_len, int,
-		   0400);
-module_param_named(reg_en, sls_param_register_enable, int, 0400);
-module_param_named(reg_exec, sls_param_register_exec, int, 0400);
-module_param_named(reg_polling, sls_param_register_polling, int, 0400);
-module_param_named(aligned_tag_size, sls_param_aligned_tag_size, int, 0400);
-module_param_named(instruction_size, sls_param_instruction_size, int, 0400);
-module_param_named(data_size, sls_param_data_size, int, 0400);
-
-#define HW_BUF_SIZE (256 * 1024)
-
-int sls_param_inst_buf_size[MAX_NUM_OF_BUF] = { HW_BUF_SIZE };
-module_param_array_named(inst_buf, sls_param_inst_buf_size, int, NULL, 0400);
-
-int sls_param_psum_buf_size[MAX_NUM_OF_BUF] = { HW_BUF_SIZE, HW_BUF_SIZE };
-module_param_array_named(psum_buf, sls_param_psum_buf_size, int, NULL, 0400);
-
-int sls_param_tags_buf_size[MAX_NUM_OF_BUF] = { HW_BUF_SIZE, HW_BUF_SIZE };
-module_param_array_named(tags_buf, sls_param_tags_buf_size, int, NULL, 0400);
diff --git a/drivers/pnm/sls_resource/parameters.h b/drivers/pnm/sls_resource/parameters.h
deleted file mode 100644
index 2263dc5ab..000000000
--- a/drivers/pnm/sls_resource/parameters.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
-
-#ifndef PNMLINUX_PARAMETERS_H
-#define PNMLINUX_PARAMETERS_H
-
-#include <linux/types.h>
-
-extern int sls_param_num_of_rank;
-extern int sls_param_num_of_chip_select;
-extern int sls_param_num_of_channel;
-
-extern int sls_param_rank_interleaving_size;
-extern int sls_param_channel_interleaving_size;
-extern int sls_param_interleaving_stride_len;
-
-extern int sls_param_register_enable;
-extern int sls_param_register_exec;
-extern int sls_param_register_polling;
-
-/* Single TAG size (Bytes) */
-extern int sls_param_aligned_tag_size;
-
-/* Instruction Size (Bytes) */
-extern int sls_param_instruction_size;
-
-/* Data Size (Bytes) */
-extern int sls_param_data_size;
-
-/* Instruction, Psum & Tags Buffers Size (Bytes) */
-#define MAX_NUM_OF_BUF 4
-extern int sls_param_inst_buf_size[MAX_NUM_OF_BUF];
-extern int sls_param_psum_buf_size[MAX_NUM_OF_BUF];
-extern int sls_param_tags_buf_size[MAX_NUM_OF_BUF];
-
-#endif //PNMLINUX_PARAMETERS_H
diff --git a/drivers/pnm/sls_resource/private.h b/drivers/pnm/sls_resource/private.h
index e775242ef..10b6cb184 100644
--- a/drivers/pnm/sls_resource/private.h
+++ b/drivers/pnm/sls_resource/private.h
@@ -28,17 +28,6 @@
 #define SLS_COPY_TO_USER(error, dst, src, size) \
 	SLS_COPY_FROM_TO_USER(copy_to_user, error, dst, src, size)
 
-struct sls_device_data {
-	int rank;
-	int region;
-	int channel;
-};
-
-static inline int is_sls_range(u64 start, u64 end)
-{
-	return start >= SLS_BASE_ADDR && end < SLS_BASE_ADDR + SLS_MEMORY_SIZE;
-}
-
 void cleanup_sls_device(void);
 
 long sls_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
diff --git a/drivers/pnm/sls_resource/process_manager.c b/drivers/pnm/sls_resource/process_manager.c
index 70c35cc74..66d587a8c 100644
--- a/drivers/pnm/sls_resource/process_manager.c
+++ b/drivers/pnm/sls_resource/process_manager.c
@@ -56,7 +56,11 @@ static struct process_manager proc_mgr = {
 	.proc_list_lock = __MUTEX_INITIALIZER(proc_mgr.proc_list_lock)
 };
 
-enum rank_access_type { RANK_ACCESS_RD, RANK_ACCESS_WR, RANK_ACCESS_INVAL };
+enum rank_access_type {
+	RANK_ACCESS_RD,
+	RANK_ACCESS_WR,
+	RANK_ACCESS_INVAL,
+};
 
 static inline bool sls_req_less(struct sls_memory_alloc_request a,
 				struct sls_memory_alloc_request b)
@@ -385,6 +389,7 @@ static int update_alloc_tree(struct file *filp, struct process_manager *mgr,
 		if (!desc_delete(&proc_res->alloc_desc_tree, req))
 			err_code = -1;
 	}
+
 unlock_mutex_out:
 	mutex_unlock(&proc_res->sls_proc_lock);
 	return err_code;
diff --git a/drivers/pnm/sls_resource/process_manager.h b/drivers/pnm/sls_resource/process_manager.h
index 10a334ebe..eaae0f773 100644
--- a/drivers/pnm/sls_resource/process_manager.h
+++ b/drivers/pnm/sls_resource/process_manager.h
@@ -19,12 +19,12 @@ int register_sls_process(struct file *filp);
 /* function for handling 'release' file operation */
 int release_sls_process(struct file *filp);
 
-/* functions for adding allocation/ranks into process's resources data structure*/
+/* functions for adding allocation/cunits into process's resources data structure*/
 int sls_proc_register_alloc(struct file *filp,
 			    struct sls_memory_alloc_request req);
 int sls_proc_register_rank(struct file *filp, int rank, unsigned int cmd);
 
-/* function for removing allocation/ranks from process's resources data structure*/
+/* function for removing allocation/cunits from process's resources data structure*/
 int sls_proc_remove_alloc(struct file *filp,
 			  struct sls_memory_alloc_request req);
 int sls_proc_remove_rank(struct file *filp, int rank, unsigned int cmd);
diff --git a/drivers/pnm/sls_resource/rank_scheduler.c b/drivers/pnm/sls_resource/rank_scheduler.c
index 562a666cc..44da47230 100644
--- a/drivers/pnm/sls_resource/rank_scheduler.c
+++ b/drivers/pnm/sls_resource/rank_scheduler.c
@@ -3,8 +3,8 @@
 
 #include "rank_scheduler.h"
 #include "log.h"
-#include "parameters.h"
 #include "process_manager.h"
+#include "topo/params.h"
 
 #include <linux/bitops.h>
 #include <linux/slab.h>
@@ -31,7 +31,6 @@ struct rank_scheduler {
 	} *rank_stats;
 	atomic64_t retry_timeout_ns;
 	uint8_t cacheline_padding_4[L1_CACHE_BYTES - sizeof(atomic64_t)];
-	uint64_t num_of_rank;
 	struct mutex rank_stat_lock;
 };
 
@@ -65,7 +64,7 @@ static void find_free_ranks(struct rank_scheduler *rank_sched, unsigned int msk,
 	/* fill wo_msk and rw_msk according to actual read and write
 	 * rank statuses and user requested mask
 	 */
-	for (rank = 0; rank < rank_sched->num_of_rank; rank++) {
+	for (rank = 0; rank < sls_topo()->nr_cunits; rank++) {
 		if (msk & (1 << rank) && rs[rank].wr_stat == IDLE_STATE) {
 			if (rs[rank].rd_stat == IDLE_STATE)
 				*rw_msk |= (1 << rank);
@@ -85,7 +84,7 @@ void reset_rank_scheduler(void)
 	SLS_DBG("Resetting SLS rank scheduler\n");
 
 	/* set all ranks as idle */
-	for (rank = 0; rank < sls_rank_sched.num_of_rank; rank++) {
+	for (rank = 0; rank < sls_topo()->nr_cunits; rank++) {
 		sls_rank_sched.rank_stats[rank].wr_stat = IDLE_STATE;
 		sls_rank_sched.rank_stats[rank].rd_stat = IDLE_STATE;
 		atomic64_set(
@@ -98,8 +97,7 @@ void reset_rank_scheduler(void)
 
 int init_rank_scheduler(void)
 {
-	sls_rank_sched.num_of_rank = sls_param_num_of_rank;
-	sls_rank_sched.rank_stats = kcalloc(sls_rank_sched.num_of_rank,
+	sls_rank_sched.rank_stats = kcalloc(sls_topo()->nr_cunits,
 					    sizeof(struct sls_rank_stat_t),
 					    GFP_KERNEL);
 
@@ -126,7 +124,7 @@ static int get_rank_write(struct rank_scheduler *rank_sched, unsigned int msk)
 	/* masks for saving available ranks in corresponding bits */
 	unsigned int rw_mask = 0;
 	unsigned int wo_mask = 0;
-	unsigned int max_msk_val = (1 << rank_sched->num_of_rank) - 1;
+	unsigned int max_msk_val = (1 << sls_topo()->nr_cunits) - 1;
 
 	SLS_DBG("Acquiring rank for write (mask 0x%x)\n", msk);
 
@@ -159,11 +157,10 @@ static int get_rank_read(struct rank_scheduler *rank_sched,
 			 unsigned int rank_id)
 {
 	int ret = -1;
-	struct sls_rank_stat_t *rs = rank_sched->rank_stats;
 
 	SLS_DBG("Acquiring rank %u for read\n", rank_id);
 
-	if (rank_id > (rank_sched->num_of_rank - 1)) {
+	if (rank_id > (sls_topo()->nr_cunits - 1)) {
 		SLS_ERR("Invalid rank value: %u\n", rank_id);
 		return ret;
 	}
@@ -171,9 +168,9 @@ static int get_rank_read(struct rank_scheduler *rank_sched,
 	mutex_lock(&rank_sched->rank_stat_lock);
 	{
 		ASSERT_EXCLUSIVE_ACCESS_SCOPED(rank_sched->rank_stats);
-		if (rs[rank_id].rd_stat == IDLE_STATE) {
+		if (rank_sched->rank_stats[rank_id].rd_stat == IDLE_STATE) {
 			ret = rank_id;
-			rs[rank_id].rd_stat = BUSY_STATE;
+			rank_sched->rank_stats[rank_id].rd_stat = BUSY_STATE;
 		}
 	}
 	mutex_unlock(&rank_sched->rank_stat_lock);
@@ -189,11 +186,10 @@ static int get_rank_read(struct rank_scheduler *rank_sched,
 int release_rank_write(unsigned int rank_id)
 {
 	int ret = rank_id;
-	struct sls_rank_stat_t *rs = sls_rank_sched.rank_stats;
 
 	SLS_DBG("Releasing rank %u for write\n", rank_id);
 
-	if (rank_id > (sls_rank_sched.num_of_rank - 1)) {
+	if (rank_id > (sls_topo()->nr_cunits - 1)) {
 		SLS_ERR("Invalid rank value: %u\n", rank_id);
 		return -1;
 	}
@@ -201,7 +197,7 @@ int release_rank_write(unsigned int rank_id)
 	mutex_lock(&sls_rank_sched.rank_stat_lock);
 	{
 		ASSERT_EXCLUSIVE_ACCESS_SCOPED(sls_rank_sched.rank_stats);
-		rs[rank_id].wr_stat = IDLE_STATE;
+		sls_rank_sched.rank_stats[rank_id].wr_stat = IDLE_STATE;
 	}
 	mutex_unlock(&sls_rank_sched.rank_stat_lock);
 
@@ -211,11 +207,10 @@ int release_rank_write(unsigned int rank_id)
 int release_rank_read(unsigned int rank_id)
 {
 	int ret = rank_id;
-	struct sls_rank_stat_t *rs = sls_rank_sched.rank_stats;
 
 	SLS_DBG("Releasing rank %u for read\n", rank_id);
 
-	if (rank_id > (sls_rank_sched.num_of_rank - 1)) {
+	if (rank_id > (sls_topo()->nr_cunits - 1)) {
 		SLS_ERR("Invalid rank value: %u\n", rank_id);
 		return -1;
 	}
@@ -223,7 +218,7 @@ int release_rank_read(unsigned int rank_id)
 	mutex_lock(&sls_rank_sched.rank_stat_lock);
 	{
 		ASSERT_EXCLUSIVE_ACCESS_SCOPED(sls_rank_sched.rank_stats);
-		rs[rank_id].rd_stat = IDLE_STATE;
+		sls_rank_sched.rank_stats[rank_id].rd_stat = IDLE_STATE;
 	}
 	mutex_unlock(&sls_rank_sched.rank_stat_lock);
 	return ret;
@@ -360,8 +355,3 @@ int release_sls_rank(struct file *filp, unsigned int cmd, unsigned int arg)
 
 	return -1;
 }
-
-uint64_t rank_scheduler_rank_num(void)
-{
-	return sls_rank_sched.num_of_rank;
-}
diff --git a/drivers/pnm/sls_resource/rank_scheduler.h b/drivers/pnm/sls_resource/rank_scheduler.h
index 62103e16a..3f439739d 100644
--- a/drivers/pnm/sls_resource/rank_scheduler.h
+++ b/drivers/pnm/sls_resource/rank_scheduler.h
@@ -4,10 +4,7 @@
 #ifndef __SLS_RANK_SCHEDULER_H__
 #define __SLS_RANK_SCHEDULER_H__
 
-#include <linux/atomic.h>
-
 #include <linux/fs.h>
-#include <linux/mutex.h>
 #include <linux/sls_resources.h>
 #include <linux/types.h>
 
@@ -26,7 +23,6 @@ int release_rank_read(unsigned int rank_id);
 
 bool rank_scheduler_rank_state(uint8_t rank);
 uint64_t rank_scheduler_acquisition_count(uint8_t rank);
-uint64_t rank_scheduler_rank_num(void);
 
 uint64_t rank_scheduler_acquisition_timeout(void);
 void rank_scheduler_set_acquisition_timeout(uint64_t timeout);
diff --git a/drivers/pnm/sls_resource/sls.c b/drivers/pnm/sls_resource/sls.c
index f10d19abc..706292da5 100644
--- a/drivers/pnm/sls_resource/sls.c
+++ b/drivers/pnm/sls_resource/sls.c
@@ -2,10 +2,11 @@
 /* Copyright(c) 2021-2023 Samsung LTD. All rights reserved. */
 
 #include "log.h"
-#include "parameters.h"
+#include "mem_info.h"
 #include "private.h"
 #include "process_manager.h"
 #include "sysfs.h"
+#include "topo/params.h"
 
 #include "device_resource.h"
 
@@ -15,7 +16,6 @@
 #include <linux/mm.h>
 #include <linux/mman.h>
 #include <linux/module.h>
-#include <linux/pnm_sls_set_mem_info.h>
 #include <linux/slab.h>
 #include <linux/sls_resources.h>
 
@@ -25,57 +25,13 @@ MODULE_VERSION(SLS_DRIVER_VERSION);
 
 #define SLS_RESOURCE_BASE_MINOR 0
 
-static struct sls_mem_info mem_info;
+static const struct sls_mem_info *mem_info;
+static const struct sls_mem_cunit_info *mem_cunit_info;
 static struct device *sls_resource_device;
 static struct cdev sls_resource_cdev;
 static dev_t sls_resource_device_number;
 
-static int set_sls_device_type(const char *val, const struct kernel_param *kp)
-{
-	enum sls_device_type *dev_type = (enum sls_device_type *)kp->arg;
-
-	if (strcmp("AXDIMM", val) == 0) {
-		*dev_type = SLS_AXDIMM;
-		return 0;
-	}
-
-	if (strcmp("CXL", val) == 0) {
-		*dev_type = SLS_CXL;
-		return 0;
-	}
-
-	SLS_ERR("Unknown device name: %s\n", val);
-
-	return -EINVAL;
-}
-
-static int get_sls_device_type(char *buffer, const struct kernel_param *kp)
-{
-	const enum sls_device_type type = *((enum sls_device_type *)kp->arg);
-
-	switch (type) {
-	case SLS_AXDIMM:
-		return sysfs_emit(buffer, "AXDIMM\n");
-	case SLS_CXL:
-		return sysfs_emit(buffer, "CXL\n");
-	case SLS_UNDEFINED:
-	case SLS_MAX:
-		break;
-	}
-
-	SLS_ERR("Unknown device name: %d\n", type);
-
-	return -EINVAL;
-}
-
-static enum sls_device_type sls_device_type = CONFIG_DEV_SLS_BUS;
-static const struct kernel_param_ops sls_device_type_ops = {
-	.set = set_sls_device_type,
-	.get = get_sls_device_type,
-};
-module_param_cb(device, &sls_device_type_ops, &sls_device_type, 0444);
-
-int sls_release(struct inode *inode, struct file *filp)
+int sls_release(struct inode *node, struct file *filp)
 {
 	return release_sls_process(filp);
 }
@@ -177,36 +133,16 @@ static void sls_destroy_cdev(void)
 	cdev_del(&sls_resource_cdev);
 }
 
-static int init_mem_info(struct sls_mem_info *mem_info)
-{
-	mem_info->devtype = get_device_type(sls_device_name);
-	mem_info->num_of_cs = sls_param_num_of_chip_select;
-	mem_info->mem_offset = kcalloc(mem_info->num_of_cs * SLS_BLOCK_MAX,
-				       sizeof(uint64_t), GFP_KERNEL);
-	mem_info->mem_size = kcalloc(mem_info->num_of_cs * SLS_BLOCK_MAX,
-				     sizeof(uint64_t), GFP_KERNEL);
-
-	if (mem_info->mem_size == NULL || mem_info->mem_offset == NULL)
-		return -ENOMEM;
-
-	sls_set_mem_info(mem_info);
-
-	return 0;
-}
-
 int init_sls_device(void)
 {
 	int err;
 
 	SLS_INF("Initializing SLS device\n");
 
-	if (sls_device_type <= SLS_UNDEFINED || sls_device_type >= SLS_MAX) {
-		SLS_ERR("Invalid device type: %d\n", sls_device_type);
-		return -EINVAL;
-	}
+	err = init_topology();
 
-	if (sls_device_type == SLS_UNDEFINED)
-		goto resource_device_fail;
+	if (unlikely(err))
+		return err;
 
 	/* Alloc chrdev region */
 	err = sls_alloc_cdev_region();
@@ -234,13 +170,18 @@ int init_sls_device(void)
 	}
 
 	/* Initialize device mem_info */
-	err = init_mem_info(&mem_info);
-	if (err)
+	mem_info = sls_create_mem_info();
+	if (!mem_info)
 		goto mem_info_fail;
 
+	/* Initialize device mem_cunit_info */
+	mem_cunit_info = sls_create_mem_cunit_info(mem_info);
+	if (!mem_cunit_info)
+		goto mem_cunit_info_fail;
+
 	/* Initialize memory allocator */
-	err = init_sls_allocator(&mem_info, sls_device_type);
-	if (unlikely(err))
+	err = init_sls_allocator(mem_cunit_info);
+	if (err)
 		goto allocator_fail;
 
 	/* Reset ranks status and synchronization primitives */
@@ -249,7 +190,7 @@ int init_sls_device(void)
 		goto rank_scheduler_fail;
 
 	/* Create sysfs subsystem for the device */
-	err = build_sls_sysfs(&mem_info, sls_resource_device, sls_device_type);
+	err = build_sls_sysfs(mem_cunit_info, mem_info, sls_resource_device);
 	if (unlikely(err))
 		goto build_sysfs_fail;
 
@@ -262,10 +203,11 @@ int init_sls_device(void)
 rank_scheduler_fail:
 	cleanup_sls_allocator();
 allocator_fail:
-	sls_destroy_cdev();
+	sls_destroy_mem_cunit_info(mem_cunit_info);
+mem_cunit_info_fail:
+	sls_destroy_mem_info(mem_info);
 mem_info_fail:
-	kfree(mem_info.mem_offset);
-	kfree(mem_info.mem_size);
+	sls_destroy_cdev();
 init_cdev_fail:
 	pnm_destroy_resource_device(sls_resource_device);
 resource_device_fail:
@@ -282,8 +224,10 @@ void cleanup_sls_device(void)
 	cleanup_sls_allocator();
 
 	/* Free mem_info structure */
-	kfree(mem_info.mem_offset);
-	kfree(mem_info.mem_size);
+	sls_destroy_mem_info(mem_info);
+
+	/* Free cunit_mem_info*/
+	sls_destroy_mem_cunit_info(mem_cunit_info);
 
 	/* Free allocated memory if any user processes alive upon device remove*/
 	cleanup_process_manager();
diff --git a/drivers/pnm/sls_resource/sysfs.c b/drivers/pnm/sls_resource/sysfs.c
index 6a5d13c5f..ad96529d3 100644
--- a/drivers/pnm/sls_resource/sysfs.c
+++ b/drivers/pnm/sls_resource/sysfs.c
@@ -4,11 +4,11 @@
 #include "sysfs.h"
 #include "allocator.h"
 #include "log.h"
-#include "parameters.h"
 #include "private.h"
 #include "process_manager.h"
 #include "rank_scheduler.h"
-#include "topology_export.h"
+#include "topo/export.h"
+#include "topo/params.h"
 
 #include <linux/device.h>
 #include <linux/genalloc.h>
@@ -17,15 +17,18 @@
 #include <linux/string.h>
 #include <linux/types.h>
 
+/* [TODO: @p.bred] Refactor all sysfs inc. error handling within MCS23-1373 */
+
 #define RANK_ATTR_MAX 4
-#define RANK_SYSFS_ATTR_COUNT 4
-#define RANK_SYSFS_GROUPS_COUNT 1
-#define REGION_SYSFS_ATTR_COUNT 2
+#define SYSFS_GROUPS_COUNT 1
+#define REGION_SYSFS_ATTR_COUNT 4
+#define RAW_REGION_SYSFS_ATTR_COUNT 3
 #define WITH_NULL_TERM(var) (var + 1)
 
-static struct sls_mem_info *mem_info;
+static const struct sls_mem_cunit_info *mem_cunit_info;
+static const struct sls_mem_info *mem_info;
 static struct kobject *ranks_kobj;
-static enum sls_device_type sls_device_type = SLS_UNDEFINED;
+static struct kobject *mappings_kobj;
 
 static ssize_t leaked_show(struct device *device, struct device_attribute *attr,
 			   char *buf)
@@ -99,7 +102,7 @@ static ssize_t reset_store(struct device *device, struct device_attribute *attr,
 			SLS_ERR("Failed to reset device via sysfs.\n");
 	} else {
 		// Usual behavior is to silently ignore this, so there is no reason
-		// to make it an SLS_WRN.
+		// to make it as SLS_WRN.
 		SLS_DBG("Ignoring invalid value ('%s') written into sysfs 'reset' file\n",
 			buf);
 	}
@@ -155,16 +158,31 @@ struct regions_sysfs {
 };
 
 struct rank_sysfs {
-	struct rank_attribute attrs[RANK_SYSFS_ATTR_COUNT];
-	struct attribute *attributes[WITH_NULL_TERM(RANK_SYSFS_ATTR_COUNT)];
+	struct rank_attribute attrs[REGION_SYSFS_ATTR_COUNT];
+	struct attribute *attributes[WITH_NULL_TERM(REGION_SYSFS_ATTR_COUNT)];
 	struct attribute_group group;
-	const struct attribute_group
-		*groups[WITH_NULL_TERM(RANK_SYSFS_GROUPS_COUNT)];
+	const struct attribute_group *groups[WITH_NULL_TERM(SYSFS_GROUPS_COUNT)];
 	struct regions_sysfs regions_fs;
 	struct kobject rank_idx_kobj;
 };
 
+struct raw_region_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct raw_region_attribute *attr, char *buf);
+	uint8_t region;
+};
+
+struct raw_region_sysfs {
+	struct raw_region_attribute attrs[RAW_REGION_SYSFS_ATTR_COUNT];
+	struct attribute
+		*attributes[WITH_NULL_TERM(RAW_REGION_SYSFS_ATTR_COUNT)];
+	struct attribute_group group;
+	const struct attribute_group *groups[WITH_NULL_TERM(SYSFS_GROUPS_COUNT)];
+	struct kobject idx_kobj;
+};
+
 static struct rank_sysfs *ranks_fs;
+static struct raw_region_sysfs *raw_regions_fs;
 
 static const char *const rank_attr_name[] = {
 	"state",
@@ -220,30 +238,42 @@ static const char *const region_group_name[] = {
 static const char *const region_attr_name[] = {
 	"size",
 	"offset",
+	"map_size",
+	"map_offset",
 };
 
 static ssize_t region_show(struct region_attribute *attr, char *buf)
 {
-	uint64_t size;
-	uint64_t num_of_cs;
-	uint64_t num_of_rank;
-
-	num_of_cs = sls_param_num_of_chip_select;
-	num_of_rank = sls_param_num_of_rank;
+	const size_t nr_cunits = mem_cunit_info->nr_cunits;
+	const size_t nr_regions_per_cunit =
+		mem_cunit_info->nr_regions / nr_cunits;
+	const struct sls_mem_cunit_region *cunit_regions =
+		&mem_cunit_info->regions[attr->rank * nr_regions_per_cunit];
+	const struct sls_mem_cunit_region *region = NULL;
+	size_t idx;
+
+	for (idx = 0; idx < nr_regions_per_cunit; ++idx)
+		if (cunit_regions[idx].type == attr->region)
+			region = &cunit_regions[idx];
+
+	/* [TODO: @p.bred] Make logs here and in other places across the file */
+	if (!region)
+		return -EIO;
 
 	if (strcmp(attr->attr.name, region_attr_name[0]) == 0) {
-		size = mem_info->mem_size[attr->rank % num_of_cs][attr->region] /
-		       (num_of_rank / num_of_cs);
-
-		return sysfs_emit(buf, "%llu\n", size);
+		return sysfs_emit(buf, "%llu\n", range_len(&region->range));
 	}
 
 	if (strcmp(attr->attr.name, region_attr_name[1]) == 0)
-		return sysfs_emit(buf, "%llu\n",
-				  mem_info->mem_offset[attr->rank % num_of_cs]
-						      [attr->region]);
+		return sysfs_emit(buf, "%llu\n", region->range.start);
 
-	return 0;
+	if (strcmp(attr->attr.name, region_attr_name[2]) == 0)
+		return sysfs_emit(buf, "%llu\n", range_len(&region->map_range));
+
+	if (strcmp(attr->attr.name, region_attr_name[3]) == 0)
+		return sysfs_emit(buf, "%llu\n", region->map_range.start);
+
+	return -EIO;
 }
 
 static ssize_t region_attr_show(struct kobject *kobj, struct attribute *attr,
@@ -333,7 +363,7 @@ static void fill_rank_attrs(struct rank_sysfs *rank_fs, uint8_t rank)
 {
 	int attr_idx;
 
-	for (attr_idx = 0; attr_idx < RANK_SYSFS_ATTR_COUNT; ++attr_idx) {
+	for (attr_idx = 0; attr_idx < REGION_SYSFS_ATTR_COUNT; ++attr_idx) {
 		rank_fs->attrs[attr_idx].attr.name = rank_attr_name[attr_idx];
 		rank_fs->attrs[attr_idx].attr.mode = 0444;
 		rank_fs->attrs[attr_idx].show = rank_show;
@@ -342,7 +372,7 @@ static void fill_rank_attrs(struct rank_sysfs *rank_fs, uint8_t rank)
 		rank_fs->attributes[attr_idx] = &rank_fs->attrs[attr_idx].attr;
 	}
 
-	rank_fs->attributes[RANK_SYSFS_ATTR_COUNT] = NULL;
+	rank_fs->attributes[REGION_SYSFS_ATTR_COUNT] = NULL;
 }
 
 static void fill_rank_sysfs(struct rank_sysfs *rank_fs, uint8_t rank)
@@ -358,7 +388,7 @@ static const struct sysfs_ops rank_sysfs_ops = {
 };
 
 /* Operations on rank stats */
-static struct kobj_type rank_type = {
+static const struct kobj_type rank_type = {
 	.sysfs_ops = &rank_sysfs_ops,
 };
 
@@ -369,13 +399,6 @@ static int build_rank_sysfs(struct kobject *kobj, uint8_t rank)
 
 	SLS_DBG("Building SLS sysfs for rank %hhu\n", rank);
 
-	ranks_fs = kcalloc(sls_param_num_of_rank, sizeof(struct rank_sysfs),
-			   GFP_KERNEL);
-	if (!ranks_fs) {
-		SLS_ERR("No free memory for ranks direcotries\n");
-		return -ENOMEM;
-	}
-
 	kobject_init(&ranks_fs[rank].rank_idx_kobj, &rank_type);
 	sprintf(buf, "%hhu", rank);
 	err = kobject_add(&ranks_fs[rank].rank_idx_kobj, kobj, buf);
@@ -401,66 +424,287 @@ static int build_rank_sysfs(struct kobject *kobj, uint8_t rank)
 	return err;
 }
 
-int build_sls_sysfs(struct sls_mem_info *meminfo, struct device *resource_dev,
-		    enum sls_device_type devtype)
+static ssize_t nr_regions_show(struct device *device,
+			       struct device_attribute *attr, char *buf)
 {
-	int rank;
-	uint64_t num_of_rank;
+	return sysfs_emit(buf, "%llu\n", mem_info->nr_regions);
+}
+static DEVICE_ATTR_RO(nr_regions);
+
+static struct attribute *mappings_attrs[] = {
+	&dev_attr_nr_regions.attr,
+	NULL,
+};
+
+static struct attribute_group mappings_attr_group = {
+	.attrs = mappings_attrs,
+};
+
+static const struct attribute_group *mappings_attr_groups[] = {
+	&mappings_attr_group,
+	NULL,
+};
+
+static const char *const raw_region_attr_name[] = {
+	"offset",
+	"size",
+	"type",
+};
+
+static ssize_t raw_region_show(struct raw_region_attribute *attr, char *buf)
+{
+	uint64_t offset, size;
+	int type;
+
+	if (strcmp(attr->attr.name, raw_region_attr_name[0]) == 0) {
+		offset = mem_info->regions[attr->region].range.start;
+		return sysfs_emit(buf, "%llu\n", offset);
+	}
+
+	if (strcmp(attr->attr.name, raw_region_attr_name[1]) == 0) {
+		size = range_len(&mem_info->regions[attr->region].range);
+		return sysfs_emit(buf, "%llu\n", size);
+	}
+
+	if (strcmp(attr->attr.name, raw_region_attr_name[2]) == 0) {
+		type = mem_info->regions[attr->region].type;
+		return sysfs_emit(buf, "%d\n", type);
+	}
+
+	return 0;
+}
+
+static ssize_t raw_region_attr_show(struct kobject *kobj,
+				    struct attribute *attr, char *buf)
+{
+	struct raw_region_attribute *raw_region_attr =
+		container_of(attr, struct raw_region_attribute, attr);
+
+	if (!raw_region_attr->show)
+		return -EIO;
+
+	return raw_region_attr->show(raw_region_attr, buf);
+}
+
+static const struct sysfs_ops raw_region_sysfs_ops = {
+	.show = raw_region_attr_show,
+};
+
+static struct kobj_type raw_region_type = {
+	.sysfs_ops = &raw_region_sysfs_ops,
+};
+
+static void fill_raw_region_attrs(struct raw_region_sysfs *raw_region_fs,
+				  uint8_t region)
+{
+	int attr_idx;
+
+	for (attr_idx = 0; attr_idx < RAW_REGION_SYSFS_ATTR_COUNT; ++attr_idx) {
+		raw_region_fs->attrs[attr_idx].attr.name =
+			raw_region_attr_name[attr_idx];
+		raw_region_fs->attrs[attr_idx].attr.mode = 0444;
+		raw_region_fs->attrs[attr_idx].show = raw_region_show;
+		raw_region_fs->attrs[attr_idx].region = region;
+
+		raw_region_fs->attributes[attr_idx] =
+			&raw_region_fs->attrs[attr_idx].attr;
+	}
+
+	raw_region_fs->attributes[RAW_REGION_SYSFS_ATTR_COUNT] = NULL;
+}
+
+static void fill_raw_region_sysfs(struct raw_region_sysfs *raw_region_fs,
+				  uint8_t region)
+{
+	fill_raw_region_attrs(raw_region_fs, region);
+	raw_region_fs->group.attrs = raw_region_fs->attributes;
+	raw_region_fs->groups[0] = &raw_region_fs->group;
+	raw_region_fs->groups[1] = NULL;
+}
+
+static int build_raw_region_sysfs(struct kobject *kobj, uint8_t region)
+{
+	char buf[4];
+	int err;
+
+	SLS_DBG("Building SLS sysfs for mappings region %hhu\n", region);
+
+	kobject_init(&raw_regions_fs[region].idx_kobj, &raw_region_type);
+	sprintf(buf, "%hhu", region);
+	err = kobject_add(&raw_regions_fs[region].idx_kobj, kobj, buf);
+	if (err)
+		goto build_raw_region_kobject_out;
+
+	fill_raw_region_sysfs(&raw_regions_fs[region], region);
+
+	err = sysfs_create_groups(&raw_regions_fs[region].idx_kobj,
+				  raw_regions_fs[region].groups);
+	if (err)
+		goto build_raw_region_out;
+
+	return 0;
+
+build_raw_region_out:
+	kobject_del(&raw_regions_fs[region].idx_kobj);
+build_raw_region_kobject_out:
+	kobject_put(&raw_regions_fs[region].idx_kobj);
+	memset(&raw_regions_fs[region].idx_kobj, 0, sizeof(struct kobject));
+	return err;
+}
+
+static int sls_export_mappings(struct kobject *resource_kobj)
+{
+	uint8_t region;
 	int err = 0;
 
-	if (devtype == SLS_UNDEFINED)
-		return -EINVAL;
+	SLS_DBG("Building SLS memory mappings sysfs\n");
 
-	sls_device_type = devtype;
+	mappings_kobj =
+		kobject_create_and_add(DEVICE_MAPPINGS_PATH, resource_kobj);
 
-	mem_info = meminfo;
+	if (!mappings_kobj) {
+		SLS_ERR("Unable to create mappings sysfs kobject\n");
+		return -ENOMEM;
+	}
 
-	num_of_rank = sls_param_num_of_rank;
+	err = sysfs_create_groups(mappings_kobj, mappings_attr_groups);
+	if (err) {
+		SLS_ERR("Failed to create mappings sysfs groups\n");
+		goto mappings_kobj_free;
+	}
+
+	raw_regions_fs = kcalloc(mem_info->nr_regions,
+				 sizeof(struct raw_region_sysfs), GFP_KERNEL);
+	if (!raw_regions_fs) {
+		SLS_ERR("No free memory for raw regions directories\n");
+		goto mappings_groups_free;
+	}
+
+	for (region = 0; region < mem_info->nr_regions; ++region) {
+		err = build_raw_region_sysfs(mappings_kobj, region);
+		if (err) {
+			SLS_ERR("Failed to build sysfs for mappings region [%hhu]\n",
+				region);
+			while (--region >= 0) {
+				sysfs_remove_groups(
+					&raw_regions_fs[region].idx_kobj,
+					raw_regions_fs[region].groups);
+			}
+			goto mappings_fs_free;
+		}
+	}
+
+	SLS_DBG("Built SLS mappings sysfs\n");
+	return err;
+
+mappings_fs_free:
+	kfree(raw_regions_fs);
+mappings_groups_free:
+	sysfs_remove_groups(mappings_kobj, mappings_attr_groups);
+mappings_kobj_free:
+	kobject_del(mappings_kobj);
+	return err ? err : -ENOMEM;
+}
+
+static void sls_destroy_mappings(void)
+{
+	SLS_DBG("Destroying SLS memory mappings sysfs\n");
+
+	if (!mappings_kobj) {
+		SLS_ERR("Unexpected state of mappings sysfs kobject (%p).\n",
+			mappings_kobj);
+		return;
+	}
+
+	sysfs_remove_groups(mappings_kobj, mappings_attr_groups);
+	kobject_del(mappings_kobj);
+
+	SLS_DBG("Destroyed SLS memory mappings sysfs\n");
+}
+
+int build_sls_sysfs(const struct sls_mem_cunit_info *mem_cunitinfo,
+		    const struct sls_mem_info *meminfo,
+		    struct device *resource_dev)
+{
+	int rank;
+	int err = 0;
+
+	mem_cunit_info = mem_cunitinfo;
+	mem_info = meminfo;
 
 	SLS_DBG("Building SLS sysfs\n");
-	ranks_kobj = kobject_create_and_add("ranks", &resource_dev->kobj);
+	ranks_kobj =
+		kobject_create_and_add(DEVICE_RANKS_PATH, &resource_dev->kobj);
 
 	if (!ranks_kobj) {
-		err = -ENOMEM;
-		SLS_ERR("Failed to create ranks kobject\n");
-		goto sysfs_out;
+		SLS_ERR("Failed to create cunits kobject\n");
+		return -ENOMEM;
 	}
 
-	if (sysfs_create_groups(ranks_kobj, dev_attr_groups)) {
-		err = -ENOMEM;
-		goto sysfs_out;
+	err = sysfs_create_groups(ranks_kobj, dev_attr_groups);
+	if (err) {
+		SLS_ERR("Failed to create sysfs groups\n");
+		goto cunits_kobj_free;
+	}
+
+	err = sls_export_mappings(&resource_dev->kobj);
+	if (err) {
+		SLS_ERR("Failed to build memory topology sysfs");
+		goto groups_free;
 	}
 
 	err = sls_export_topology_constants(&resource_dev->kobj);
 	if (err) {
 		SLS_ERR("Failed to build memory topology sysfs");
-		goto sysfs_out;
+		goto mappings_free;
+	}
+
+	ranks_fs = kcalloc(sls_topo()->nr_cunits, sizeof(struct rank_sysfs),
+			   GFP_KERNEL);
+	if (!ranks_fs) {
+		SLS_ERR("No free memory for cunits directories\n");
+		goto topology_free;
 	}
 
-	for (rank = 0; rank < num_of_rank; ++rank) {
+	for (rank = 0; rank < sls_topo()->nr_cunits; ++rank) {
 		err = build_rank_sysfs(ranks_kobj, rank);
 		if (err) {
-			SLS_ERR("Failed to build sysfs for rank [%d]\n", rank);
-			goto sysfs_out;
+			SLS_ERR("Failed to build sysfs for cunit [%d]\n", rank);
+			while (--rank >= 0) {
+				sysfs_remove_groups(
+					&ranks_fs[rank].regions_fs.regions_kobj,
+					ranks_fs[rank].regions_fs.groups);
+				sysfs_remove_groups(
+					&ranks_fs[rank].rank_idx_kobj,
+					ranks_fs[rank].groups);
+			}
+			goto fs_free;
 		}
 	}
 
 	SLS_DBG("Built SLS sysfs\n");
-
-sysfs_out:
 	return err;
+
+fs_free:
+	kfree(ranks_fs);
+topology_free:
+	sls_destroy_topology_constants();
+mappings_free:
+	sls_destroy_mappings();
+groups_free:
+	sysfs_remove_groups(ranks_kobj, dev_attr_groups);
+cunits_kobj_free:
+	kobject_del(ranks_kobj);
+	return err ? err : -ENOMEM;
 }
 
 void destroy_sls_sysfs(void)
 {
 	int rank;
-	uint64_t num_of_rank;
 
 	SLS_DBG("Destroying SLS sysfs\n");
 
-	num_of_rank = sls_param_num_of_rank;
-
-	for (rank = 0; rank < num_of_rank; ++rank) {
+	for (rank = 0; rank < sls_topo()->nr_cunits; ++rank) {
 		sysfs_remove_groups(&ranks_fs[rank].regions_fs.regions_kobj,
 				    ranks_fs[rank].regions_fs.groups);
 		kobject_del(&ranks_fs[rank].regions_fs.regions_kobj);
diff --git a/drivers/pnm/sls_resource/sysfs.h b/drivers/pnm/sls_resource/sysfs.h
index 399264536..cf09ecc03 100644
--- a/drivers/pnm/sls_resource/sysfs.h
+++ b/drivers/pnm/sls_resource/sysfs.h
@@ -5,12 +5,11 @@
 #define __SLS_SYSFS__
 
 #include <linux/device.h>
+#include <linux/sls_common.h>
 
-struct sls_mem_info;
-enum sls_device_type;
-
-int build_sls_sysfs(struct sls_mem_info *meminfo, struct device *resource_dev,
-		    enum sls_device_type);
+int build_sls_sysfs(const struct sls_mem_cunit_info *mem_cunit_info,
+		    const struct sls_mem_info *mem_info,
+		    struct device *resource_dev);
 void destroy_sls_sysfs(void);
 
 #endif /* __SLS_SYSFS__ */
diff --git a/drivers/pnm/sls_resource/topo/axdimm.h b/drivers/pnm/sls_resource/topo/axdimm.h
new file mode 100644
index 000000000..ea22d8a2d
--- /dev/null
+++ b/drivers/pnm/sls_resource/topo/axdimm.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
+
+#ifndef __SLS_AXDIMM_PARAMETERS_H__
+#define __SLS_AXDIMM_PARAMETERS_H__
+
+#include "params.h"
+
+#include <linux/sizes.h>
+#include <linux/sls_common.h>
+
+static const struct sls_params axdimm_default_sls_params = {
+	.dev_type = SLS_AXDIMM,
+	.nr_ranks = 4,
+	.nr_cunits = 4, // nr_ranks
+	.nr_cs = 2,
+	.nr_ch = 2,
+	.cunit_interleaving_sz = SZ_128,
+	.ch_interleaving_sz = SZ_128K,
+	.interleaving_stride = SZ_128,
+	.aligned_tag_sz = SZ_64,
+	.inst_sz = 8,
+	.data_sz = 4,
+	.buf_sz = SZ_256K,
+	.nr_inst_buf = 1,
+	.nr_psum_buf = 2,
+	.nr_tag_buf = 2,
+	.reg_en = 0x0,
+	.reg_exec = 0x40,
+	.reg_poll = 0x840,
+	.alignment_sz = PAGE_SIZE,
+	.block_sz = {},
+};
+
+#endif // __SLS_AXDIMM_PARAMETERS_H__
diff --git a/drivers/pnm/sls_resource/topo/cxl.h b/drivers/pnm/sls_resource/topo/cxl.h
new file mode 100644
index 000000000..58cf81e99
--- /dev/null
+++ b/drivers/pnm/sls_resource/topo/cxl.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
+
+#ifndef __SLS_CXL_PARAMETERS_H__
+#define __SLS_CXL_PARAMETERS_H__
+
+#include "params.h"
+
+#include <linux/sizes.h>
+#include <linux/sls_common.h>
+
+#define HUGE_PAGE_SIZE (2 << 20)
+
+static const struct sls_params cxl_default_sls_params = {
+	.dev_type = SLS_CXL,
+	.nr_ranks = 4, // 2 inactive
+	.nr_cunits = 2, // nr_ch
+	.nr_cs = 2,
+	.nr_ch = 2,
+	.cunit_interleaving_sz = 0,
+	.ch_interleaving_sz = 0,
+	.interleaving_stride = 0,
+	.aligned_tag_sz = SZ_64,
+	.inst_sz = 8,
+	.data_sz = 4,
+	.buf_sz = SZ_256K - 64,
+	.nr_inst_buf = 1,
+	.nr_psum_buf = 1,
+	.nr_tag_buf = 0,
+	.reg_en = 0x0,
+	.reg_exec = 0x40,
+	.reg_poll = 0x440,
+	.alignment_sz = HUGE_PAGE_SIZE,
+	.block_sz = {},
+};
+
+#endif // __SLS_CXL_PARAMETERS_H__
diff --git a/drivers/pnm/sls_resource/topo/export.c b/drivers/pnm/sls_resource/topo/export.c
new file mode 100644
index 000000000..8386f5112
--- /dev/null
+++ b/drivers/pnm/sls_resource/topo/export.c
@@ -0,0 +1,116 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 2022-2023 Samsung LTD. All rights reserved. */
+
+#include "export.h"
+#include "log.h"
+#include "params.h"
+#include "private.h"
+
+#include <linux/sls_resources.h>
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+
+#define SINGLE_VALUE_ATTR(param, value)                                       \
+	static ssize_t param##_show(struct device *device,                    \
+				    struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		return sysfs_emit(buf, "%d\n", value);                        \
+	}                                                                     \
+	static DEVICE_ATTR_RO(param)
+
+#define EXPORT_PARAM(param) SINGLE_VALUE_ATTR(param, sls_topo()->param)
+#define DEV_ATTR_REF(param) (&dev_attr_##param.attr)
+
+EXPORT_PARAM(dev_type);
+EXPORT_PARAM(nr_ranks);
+EXPORT_PARAM(nr_cunits);
+EXPORT_PARAM(nr_cs);
+EXPORT_PARAM(nr_ch);
+EXPORT_PARAM(cunit_interleaving_sz);
+EXPORT_PARAM(ch_interleaving_sz);
+EXPORT_PARAM(interleaving_stride);
+EXPORT_PARAM(aligned_tag_sz);
+EXPORT_PARAM(inst_sz);
+EXPORT_PARAM(data_sz);
+EXPORT_PARAM(buf_sz);
+EXPORT_PARAM(nr_inst_buf);
+EXPORT_PARAM(nr_psum_buf);
+EXPORT_PARAM(nr_tag_buf);
+EXPORT_PARAM(reg_en);
+EXPORT_PARAM(reg_exec);
+EXPORT_PARAM(reg_poll);
+EXPORT_PARAM(alignment_sz);
+
+static struct kobject *mem_topo_kobj;
+
+static struct attribute *mem_topo_attrs[] = {
+	DEV_ATTR_REF(dev_type),
+	DEV_ATTR_REF(nr_ranks),
+	DEV_ATTR_REF(nr_cunits),
+	DEV_ATTR_REF(nr_cs),
+	DEV_ATTR_REF(nr_ch),
+	DEV_ATTR_REF(cunit_interleaving_sz),
+	DEV_ATTR_REF(ch_interleaving_sz),
+	DEV_ATTR_REF(interleaving_stride),
+	DEV_ATTR_REF(aligned_tag_sz),
+	DEV_ATTR_REF(inst_sz),
+	DEV_ATTR_REF(data_sz),
+	DEV_ATTR_REF(buf_sz),
+	DEV_ATTR_REF(nr_inst_buf),
+	DEV_ATTR_REF(nr_psum_buf),
+	DEV_ATTR_REF(nr_tag_buf),
+	DEV_ATTR_REF(reg_en),
+	DEV_ATTR_REF(reg_exec),
+	DEV_ATTR_REF(reg_poll),
+	DEV_ATTR_REF(alignment_sz),
+	NULL,
+};
+
+static struct attribute_group mem_topo_attr_group = {
+	.attrs = mem_topo_attrs,
+};
+
+static const struct attribute_group *mem_topo_attr_groups[] = {
+	&mem_topo_attr_group,
+	NULL,
+};
+
+int sls_export_topology_constants(struct kobject *resource_kobj)
+{
+	SLS_DBG("Building SLS memory topology sysfs\n");
+
+	mem_topo_kobj =
+		kobject_create_and_add(DEVICE_TOPOLOGY_PATH, resource_kobj);
+
+	if (!mem_topo_kobj) {
+		SLS_ERR("Unable to create topology sysfs kobject\n");
+		return -ENOMEM;
+	}
+
+	if (sysfs_create_groups(mem_topo_kobj, mem_topo_attr_groups)) {
+		SLS_ERR("Unable to create topology sysfs groups\n");
+		kobject_del(mem_topo_kobj);
+		return -ENOMEM;
+	}
+
+	SLS_DBG("Built SLS memory topology sysfs\n");
+
+	return 0;
+}
+
+void sls_destroy_topology_constants(void)
+{
+	SLS_DBG("Destroying SLS memory topology sysfs\n");
+
+	if (!mem_topo_kobj) {
+		SLS_ERR("Unexpected state of topology sysfs kobject (%p).\n",
+			mem_topo_kobj);
+		return;
+	}
+
+	sysfs_remove_groups(mem_topo_kobj, mem_topo_attr_groups);
+	kobject_del(mem_topo_kobj);
+
+	SLS_DBG("Destroyed SLS memory topology sysfs\n");
+}
diff --git a/drivers/pnm/sls_resource/topology_export.h b/drivers/pnm/sls_resource/topo/export.h
similarity index 92%
rename from drivers/pnm/sls_resource/topology_export.h
rename to drivers/pnm/sls_resource/topo/export.h
index e47ddafad..d79dfc2ae 100644
--- a/drivers/pnm/sls_resource/topology_export.h
+++ b/drivers/pnm/sls_resource/topo/export.h
@@ -4,7 +4,7 @@
 #ifndef __SLS_TOPOLOGY_EXPORT__
 #define __SLS_TOPOLOGY_EXPORT__
 
-struct kobject;
+#include <linux/kobject.h>
 
 int sls_export_topology_constants(struct kobject *resource_kobj);
 void sls_destroy_topology_constants(void);
diff --git a/drivers/pnm/sls_resource/topo/params.c b/drivers/pnm/sls_resource/topo/params.c
new file mode 100644
index 000000000..bf85c3738
--- /dev/null
+++ b/drivers/pnm/sls_resource/topo/params.c
@@ -0,0 +1,217 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
+
+#include "params.h"
+#include "axdimm.h"
+#include "cxl.h"
+#include "log.h"
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/sls_common.h>
+
+#if CONFIG_DEV_SLS_BUS == DEV_TYPE_SLS_AXDIMM
+static struct sls_params sls_params = axdimm_default_sls_params;
+#elif CONFIG_DEV_SLS_BUS == DEV_TYPE_SLS_CXL
+static struct sls_params sls_params = cxl_default_sls_params;
+#else /* CONFIG_DEV_SLS_BUS == DEV_TYPE_SLS_CXL */
+#error "SLS bus/interface should be selected!"
+#endif /* CONFIG_DEV_SLS_BUS == DEV_TYPE_SLS_AXDIMM */
+
+/* Base offset for each CS */
+#define EMBT_BASE_CS0_OFFSET 0ULL
+#define EMBT_BASE_CS1_OFFSET (0x800000000ULL >> SLS_MEMORY_SCALE)
+#define SLS_CH_ID 0
+
+//[TODO: MCS23-1373] replace this function onto constants
+static uint64_t sls_make_address(int channel, int rank, int bankgroup, int bank,
+				 int row, int column)
+{
+	uint64_t addr = 0;
+	uint64_t tmp_x = 0, tmp = 0, row_t = (uint64_t)row;
+
+	addr += ((uint64_t)column & 0x7) << 3;
+
+	tmp_x = (row_t >> 3) & 0x1;
+	tmp = bankgroup & 0x1;
+	/* BG0 bit[6], always 0 */
+	addr += ((tmp_x == 0 ? tmp : tmp == 0 ? 1 : 0) << 6);
+
+	tmp_x = (row_t >> 2) & 0x1;
+	tmp = (channel >> 1) & 0x1;
+	/* HA bit[7], always 0 */
+	addr += ((tmp_x == 0 ? tmp : tmp == 0 ? 1 : 0) << 7);
+
+	/* Column bits[8:14], all 0 */
+	addr += ((((uint64_t)column >> 3) & 0x7f) << 8);
+
+	/* Row R0-R2 bits[15:17], all 0 */
+	addr += (((uint64_t)row_t & 0x7) << 15);
+
+	tmp_x = (row_t >> 5) & 0x1;
+	tmp = (bankgroup >> 1) & 0x1;
+	/* BG1 bit[18], always 0 */
+	addr += ((tmp_x == 0 ? tmp : tmp == 0 ? 1 : 0) << 18);
+
+	tmp_x = (row_t >> 6) & 0x1;
+	tmp = bank & 0x1;
+	/* BA0 bit[19], always 0 */
+	addr += ((tmp_x == 0 ? tmp : tmp == 0 ? 1 : 0) << 19);
+
+	tmp_x = (row_t >> 7) & 0x1;
+	tmp = (bank >> 1) & 0x1;
+	/* BA1 bit[20], always 0 */
+	addr += ((tmp_x == 0 ? tmp : tmp == 0 ? 1 : 0) << 20);
+
+	/* Row R3 bit[21], always 0 */
+	addr += (((row_t >> 3) & 0x1) << 21);
+	/*
+	 * Row R5-R10 bit[22:27], different for INST/CFGR/PSUM,
+	 * it's a shift of INST/CFGR/PSUM blocks relative to the end of BASE,
+	 * this defines the start and indirectly the size of INST/CFGR/PSUM.
+	 * We don't scale these blocks, because it contains specific fixed
+	 * size buffers and registers.
+	 * Now total (INST + CFGR + PSUM) blocks size = 1 GB.
+	 */
+	addr += (((row_t >> 5) & 0x7f) << 22);
+	/* Row R4 bit[29], always 0 */
+	addr += (((row_t >> 4) & 0x1) << 29);
+	/*
+	 * Row R12-R16 bit[30:34], same non-zero for INST/CFGR/PSUM,
+	 * it's a common shift for INST/CONF/PSUM relative to the start of BASE,
+	 * in other words it's a BASE block size.
+	 */
+	addr += ((row_t >> 12) & 0x1f) >> SLS_MEMORY_SCALE << 30;
+
+	/*
+	 * CS bit[35], Chip Select bit, it also scales to proper switch
+	 * between CS when using scale on a simulator.
+	 */
+	addr += ((uint64_t)rank << 35) >> SLS_MEMORY_SCALE;
+	/* CH bit[36], always 0 */
+	addr += (((uint64_t)channel & 0x1) << 36) >> SLS_MEMORY_SCALE;
+
+	return addr;
+}
+
+static void set_mem_blocks_sizes(u64 *block_sz)
+{
+	int cs = 0;
+	int block;
+	size_t offsets[SLS_BLOCK_MAX] = {};
+
+	offsets[SLS_BLOCK_BASE] = EMBT_BASE_CS0_OFFSET;
+	offsets[SLS_BLOCK_INST] =
+		sls_make_address(SLS_CH_ID, cs, 0, 0, 0x1F000, 0);
+	offsets[SLS_BLOCK_CFGR] =
+		sls_make_address(SLS_CH_ID, cs, 0, 0, 0x1F100, 0);
+	offsets[SLS_BLOCK_TAGS] =
+		sls_make_address(SLS_CH_ID, cs, 0, 0, 0x1F200, 0);
+	offsets[SLS_BLOCK_PSUM] =
+		sls_make_address(SLS_CH_ID, cs, 0, 0, 0x1F400, 0);
+
+	/* init register size for each cs */
+	block_sz[SLS_BLOCK_BASE] =
+		offsets[SLS_BLOCK_INST] - offsets[SLS_BLOCK_BASE];
+	block_sz[SLS_BLOCK_INST] =
+		offsets[SLS_BLOCK_CFGR] - offsets[SLS_BLOCK_INST];
+	block_sz[SLS_BLOCK_CFGR] =
+		offsets[SLS_BLOCK_TAGS] - offsets[SLS_BLOCK_CFGR];
+	block_sz[SLS_BLOCK_TAGS] =
+		offsets[SLS_BLOCK_PSUM] - offsets[SLS_BLOCK_TAGS];
+	block_sz[SLS_BLOCK_PSUM] =
+		EMBT_BASE_CS1_OFFSET -
+		offsets[SLS_BLOCK_PSUM]; // Assume that all psum sizes are the same
+
+	if (CONFIG_DEV_SLS_BUS == DEV_TYPE_SLS_AXDIMM)
+		return;
+
+	/* one rank per CS, CXL type, need to adjust offsets and size */
+	for (block = 0; block < SLS_BLOCK_MAX; ++block) {
+		/* [TODO: MCS23-1373] get rid of magic '2' once mem_info
+		 * initialization will be refactored by above task
+		 */
+		block_sz[block] /= 2;
+	}
+}
+
+int init_topology(void)
+{
+	set_mem_blocks_sizes(sls_params.block_sz);
+	return 0;
+}
+
+const struct sls_params *sls_topo(void)
+{
+	return &sls_params;
+}
+
+static int set_dev_type(const char *val, const struct kernel_param *kp)
+{
+	enum sls_device_type *dev_type = (enum sls_device_type *)kp->arg;
+
+	if (strcmp("AXDIMM", val) == 0) {
+		*dev_type = SLS_AXDIMM;
+		sls_params = axdimm_default_sls_params;
+		return 0;
+	}
+	if (strcmp("CXL", val) == 0) {
+		*dev_type = SLS_CXL;
+		sls_params = cxl_default_sls_params;
+		return 0;
+	}
+
+	SLS_ERR("Unknown device name: %s\n", val);
+
+	return -EINVAL;
+}
+
+static int get_dev_type(char *buffer, const struct kernel_param *kp)
+{
+	const enum sls_device_type type = *((enum sls_device_type *)kp->arg);
+
+	switch (type) {
+	case SLS_AXDIMM:
+		return sysfs_emit(buffer, "AXDIMM\n");
+	case SLS_CXL:
+		return sysfs_emit(buffer, "CXL\n");
+	case SLS_UNDEFINED:
+	case SLS_MAX:
+		break;
+	}
+
+	SLS_ERR("Unknown device name: %d\n", type);
+
+	return -EINVAL;
+}
+
+static const struct kernel_param_ops dev_type_ops = {
+	.set = set_dev_type,
+	.get = get_dev_type,
+};
+
+// [TODO: @p.bred] Make validation and unified cb for all parameters
+module_param_cb(dev_type, &dev_type_ops, &sls_params.dev_type, 0444);
+
+// [TODO: y-lavrinenko] Add the parameters validation
+#define NAMED_PARAM(param) \
+	module_param_named(param, sls_params.param, int, 0444)
+
+NAMED_PARAM(nr_ranks);
+NAMED_PARAM(nr_cunits);
+NAMED_PARAM(nr_cs);
+NAMED_PARAM(nr_ch);
+NAMED_PARAM(cunit_interleaving_sz);
+NAMED_PARAM(ch_interleaving_sz);
+NAMED_PARAM(interleaving_stride);
+NAMED_PARAM(aligned_tag_sz);
+NAMED_PARAM(inst_sz);
+NAMED_PARAM(data_sz);
+NAMED_PARAM(buf_sz);
+NAMED_PARAM(nr_inst_buf);
+NAMED_PARAM(nr_psum_buf);
+NAMED_PARAM(nr_tag_buf);
+NAMED_PARAM(reg_en);
+NAMED_PARAM(reg_exec);
+NAMED_PARAM(reg_poll);
+NAMED_PARAM(alignment_sz);
diff --git a/drivers/pnm/sls_resource/topo/params.h b/drivers/pnm/sls_resource/topo/params.h
new file mode 100644
index 000000000..6141111cb
--- /dev/null
+++ b/drivers/pnm/sls_resource/topo/params.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
+
+#ifndef __SLS_PARAMETERS_H__
+#define __SLS_PARAMETERS_H__
+
+#include <linux/sls_common.h>
+#include <linux/types.h>
+
+struct sls_params {
+	int dev_type;
+	int nr_ranks; /* nr_cunits used instead, for info only */
+	int nr_cunits; /* unifying ranks as actual compute units */
+	int nr_cs;
+	int nr_ch;
+	int cunit_interleaving_sz;
+	int ch_interleaving_sz;
+	int interleaving_stride;
+	int aligned_tag_sz; /* Single TAG size (Bytes) */
+	int inst_sz;
+	int data_sz;
+	int buf_sz; /* Instruction, Psum & Tags Buffers Size (Bytes) */
+	int nr_inst_buf;
+	int nr_psum_buf;
+	int nr_tag_buf;
+	int reg_en;
+	int reg_exec;
+	int reg_poll;
+	int alignment_sz;
+	/* [TODO: @p.bred] make it generic and flexible, then export */
+	uint64_t block_sz[SLS_BLOCK_MAX];
+};
+
+const struct sls_params *sls_topo(void);
+
+int init_topology(void);
+
+#endif // __SLS_PARAMETERS_H__
diff --git a/drivers/pnm/sls_resource/topology_export.c b/drivers/pnm/sls_resource/topology_export.c
deleted file mode 100644
index d7b4d4a67..000000000
--- a/drivers/pnm/sls_resource/topology_export.c
+++ /dev/null
@@ -1,151 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 2022-2023 Samsung LTD. All rights reserved. */
-
-#include "topology_export.h"
-#include "log.h"
-#include "parameters.h"
-#include "private.h"
-
-#include <linux/pnm_sls_mem_topology.h>
-#include <linux/sls_resources.h>
-
-#include <linux/device.h>
-#include <linux/kernel.h>
-
-//[TODO: p.bred] Fix within MCS23-1081
-#if CONFIG_DEV_SLS_BUS == SLS_TYPE_AXDIMM
-#define REG_POLLING 0x840
-/* Instruction, Psum & Tags Buffers Size (Bytes) */
-#define HW_BUF_SIZE (256 * 1024)
-#elif CONFIG_DEV_SLS_BUS == SLS_TYPE_CXL
-#define REG_POLLING 0x440
-#define HW_BUF_SIZE (256 * 1024 - 64)
-#else /* CONFIG_DEV_SLS_BUS == SLS_TYPE_CXL */
-#error "SLS bus/interface should be selected!"
-#endif
-
-#define INST_BUF_SIZE HW_BUF_SIZE
-#define PSUM_BUF_SIZE HW_BUF_SIZE
-#define TAGS_BUF_SIZE HW_BUF_SIZE
-
-#define SINGLE_VALUE_ATTR(name, value)                                       \
-	static ssize_t name##_show(struct device *device,                    \
-				   struct device_attribute *attr, char *buf) \
-	{                                                                    \
-		return sysfs_emit(buf, "%d\n", value);                       \
-	}                                                                    \
-	static DEVICE_ATTR_RO(name)
-
-#define DOUBLE_VALUE_ATTR(name, value1, value2)                              \
-	static ssize_t name##_show(struct device *device,                    \
-				   struct device_attribute *attr, char *buf) \
-	{                                                                    \
-		return sysfs_emit(buf, "%d %d\n", value1, value2);           \
-	}                                                                    \
-	static DEVICE_ATTR_RO(name)
-
-static int actual_buffer_num(int buf[MAX_NUM_OF_BUF])
-{
-	int i;
-
-	for (i = 0; i < MAX_NUM_OF_BUF && buf[i] != 0; ++i)
-		;
-
-	return i;
-}
-
-SINGLE_VALUE_ATTR(num_of_ranks, sls_param_num_of_rank);
-SINGLE_VALUE_ATTR(num_of_cs, sls_param_num_of_chip_select);
-SINGLE_VALUE_ATTR(num_of_channel, sls_param_num_of_channel);
-
-SINGLE_VALUE_ATTR(instruction_size, sls_param_instruction_size);
-SINGLE_VALUE_ATTR(data_size, sls_param_data_size);
-SINGLE_VALUE_ATTR(aligned_tag_size, sls_param_aligned_tag_size);
-
-SINGLE_VALUE_ATTR(rank_interleaving_size, sls_param_rank_interleaving_size);
-SINGLE_VALUE_ATTR(channel_interleaving_size,
-		  sls_param_channel_interleaving_size);
-SINGLE_VALUE_ATTR(interleaving_stride, sls_param_interleaving_stride_len);
-
-SINGLE_VALUE_ATTR(polling_reg_offset, sls_param_register_polling);
-SINGLE_VALUE_ATTR(sls_exec_value, sls_param_register_exec);
-SINGLE_VALUE_ATTR(enable_sls_reg_offset, sls_param_register_enable);
-
-DOUBLE_VALUE_ATTR(psum_buffer, actual_buffer_num(sls_param_psum_buf_size),
-		  sls_param_psum_buf_size[0]);
-
-DOUBLE_VALUE_ATTR(tags_buffer, actual_buffer_num(sls_param_tags_buf_size),
-		  sls_param_tags_buf_size[0]);
-
-DOUBLE_VALUE_ATTR(inst_buffer, actual_buffer_num(sls_param_inst_buf_size),
-		  sls_param_inst_buf_size[0]);
-
-static struct kobject *mem_topo_kobj;
-
-static struct attribute *mem_topo_attrs[] = {
-	&dev_attr_num_of_ranks.attr,
-	&dev_attr_num_of_cs.attr,
-	&dev_attr_num_of_channel.attr,
-
-	&dev_attr_instruction_size.attr,
-	&dev_attr_data_size.attr,
-	&dev_attr_aligned_tag_size.attr,
-
-	&dev_attr_rank_interleaving_size.attr,
-	&dev_attr_channel_interleaving_size.attr,
-	&dev_attr_interleaving_stride.attr,
-
-	&dev_attr_polling_reg_offset.attr,
-	&dev_attr_sls_exec_value.attr,
-	&dev_attr_enable_sls_reg_offset.attr,
-
-	&dev_attr_psum_buffer.attr,
-	&dev_attr_tags_buffer.attr,
-	&dev_attr_inst_buffer.attr,
-	NULL,
-};
-
-static struct attribute_group mem_topo_attr_group = {
-	.attrs = mem_topo_attrs,
-};
-
-static const struct attribute_group *mem_topo_attr_groups[] = {
-	&mem_topo_attr_group,
-	NULL,
-};
-
-int sls_export_topology_constants(struct kobject *resource_kobj)
-{
-	SLS_DBG("Building SLS memory topology sysfs\n");
-
-	mem_topo_kobj =
-		kobject_create_and_add(DEVICE_TOPOLOGY_PATH, resource_kobj);
-
-	if (!mem_topo_kobj) {
-		SLS_ERR("Unable to create topology sysfs kobject.");
-		return -ENOMEM;
-	}
-
-	if (sysfs_create_groups(mem_topo_kobj, mem_topo_attr_groups))
-		return -ENOMEM;
-
-	SLS_DBG("Built SLS memory topology sysfs\n");
-
-	return 0;
-}
-
-void sls_destroy_topology_constants(void)
-{
-	SLS_DBG("Destroying SLS memory topology sysfs\n");
-
-	if (!mem_topo_kobj) {
-		SLS_ERR("Unexpected state of topology sysfs kobject (%p).\n",
-			mem_topo_kobj);
-		return;
-	}
-
-	sysfs_remove_groups(mem_topo_kobj, mem_topo_attr_groups);
-	kobject_del(mem_topo_kobj);
-
-	SLS_DBG("Destroyed SLS memory topology sysfs\n");
-}
diff --git a/include/linux/pnm_sls_set_mem_info.h b/include/linux/pnm_sls_set_mem_info.h
deleted file mode 100644
index 51bd8fa89..000000000
--- a/include/linux/pnm_sls_set_mem_info.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 2023 Samsung LTD. All rights reserved. */
-
-/*
- * This file contains struct mem_info filling code common for DAX and
- * sls_resource. These functions have been factored out to this
- * file to avoid "Function defined but not used" warnings for code that
- * only uses definitions from sls_common.h.
- */
-
-#ifndef __SLS_SET_MEM_INFO_H__
-#define __SLS_SET_MEM_INFO_H__
-
-#include <linux/sls_common.h>
-#include <linux/types.h>
-
-//[TODO: MCS23-1373] replace this function onto constants
-static uint64_t sls_make_address(int channel, int rank, int bankgroup, int bank,
-				 int row, int column)
-{
-	uint64_t addr = 0;
-	uint64_t tmp_x = 0, tmp = 0, row_t = (uint64_t)row;
-
-	addr += ((uint64_t)column & 0x7) << 3;
-
-	tmp_x = (row_t >> 3) & 0x1;
-	tmp = bankgroup & 0x1;
-	/* BG0 bit[6], always 0 */
-	addr += ((tmp_x == 0 ? tmp : tmp == 0 ? 1 : 0) << 6);
-
-	tmp_x = (row_t >> 2) & 0x1;
-	tmp = (channel >> 1) & 0x1;
-	/* HA bit[7], always 0 */
-	addr += ((tmp_x == 0 ? tmp : tmp == 0 ? 1 : 0) << 7);
-
-	/* Column bits[8:14], all 0 */
-	addr += ((((uint64_t)column >> 3) & 0x7f) << 8);
-
-	/* Row R0-R2 bits[15:17], all 0 */
-	addr += (((uint64_t)row_t & 0x7) << 15);
-
-	tmp_x = (row_t >> 5) & 0x1;
-	tmp = (bankgroup >> 1) & 0x1;
-	/* BG1 bit[18], always 0 */
-	addr += ((tmp_x == 0 ? tmp : tmp == 0 ? 1 : 0) << 18);
-
-	tmp_x = (row_t >> 6) & 0x1;
-	tmp = bank & 0x1;
-	/* BA0 bit[19], always 0 */
-	addr += ((tmp_x == 0 ? tmp : tmp == 0 ? 1 : 0) << 19);
-
-	tmp_x = (row_t >> 7) & 0x1;
-	tmp = (bank >> 1) & 0x1;
-	/* BA1 bit[20], always 0 */
-	addr += ((tmp_x == 0 ? tmp : tmp == 0 ? 1 : 0) << 20);
-
-	/* Row R3 bit[21], always 0 */
-	addr += (((row_t >> 3) & 0x1) << 21);
-	/*
-	 * Row R5-R10 bit[22:27], different for INST/CFGR/PSUM,
-	 * it's a shift of INST/CFGR/PSUM blocks relative to the end of BASE,
-	 * this defines the start and indirectly the size of INST/CFGR/PSUM.
-	 * We don't scale these blocks, because it contains specific fixed
-	 * size buffers and registers.
-	 * Now total (INST + CFGR + PSUM) blocks size = 1 GB.
-	 */
-	addr += (((row_t >> 5) & 0x7f) << 22);
-	/* Row R4 bit[29], always 0 */
-	addr += (((row_t >> 4) & 0x1) << 29);
-	/*
-	 * Row R12-R16 bit[30:34], same non-zero for INST/CFGR/PSUM,
-	 * it's a common shift for INST/CONF/PSUM relative to the start of BASE,
-	 * in other words it's a BASE block size.
-	 */
-	addr += ((row_t >> 12) & 0x1f) >> SLS_MEMORY_SCALE << 30;
-
-	/*
-	 * CS bit[35], Chip Select bit, it also scales to proper switch
-	 * between CS when using scale on a simulator.
-	 */
-	addr += ((uint64_t)rank << 35) >> SLS_MEMORY_SCALE;
-	/* CH bit[36], always 0 */
-	addr += (((uint64_t)channel & 0x1) << 36) >> SLS_MEMORY_SCALE;
-
-	return addr;
-}
-
-static void sls_set_mem_info(struct sls_mem_info *mem_info)
-{
-	int cs;
-	int block;
-
-	/* Calculate system addr & size */
-	for (cs = 0; cs < mem_info->num_of_cs; cs++) {
-		/* init register address for each cs */
-		mem_info->mem_offset[cs][SLS_BLOCK_BASE] =
-			(cs & 1) ?
-				EMBT_BASE_CS1_OFFSET :
-				EMBT_BASE_CS0_OFFSET; // CS0: rank 0,2	CS1: rank 1,3
-		mem_info->mem_offset[cs][SLS_BLOCK_INST] =
-			sls_make_address(SLS_CH_ID, cs, 0, 0, 0x1F000, 0);
-		mem_info->mem_offset[cs][SLS_BLOCK_CFGR] =
-			sls_make_address(SLS_CH_ID, cs, 0, 0, 0x1F100, 0);
-		mem_info->mem_offset[cs][SLS_BLOCK_TAGS] =
-			sls_make_address(SLS_CH_ID, cs, 0, 0, 0x1F200, 0);
-		mem_info->mem_offset[cs][SLS_BLOCK_PSUM] =
-			sls_make_address(SLS_CH_ID, cs, 0, 0, 0x1F400, 0);
-
-		/* init register size for each cs */
-		mem_info->mem_size[cs][SLS_BLOCK_BASE] =
-			mem_info->mem_offset[cs][SLS_BLOCK_INST] -
-			mem_info->mem_offset[cs][SLS_BLOCK_BASE];
-		mem_info->mem_size[cs][SLS_BLOCK_INST] =
-			mem_info->mem_offset[cs][SLS_BLOCK_CFGR] -
-			mem_info->mem_offset[cs][SLS_BLOCK_INST];
-		mem_info->mem_size[cs][SLS_BLOCK_CFGR] =
-			mem_info->mem_offset[cs][SLS_BLOCK_TAGS] -
-			mem_info->mem_offset[cs][SLS_BLOCK_CFGR];
-		mem_info->mem_size[cs][SLS_BLOCK_TAGS] =
-			mem_info->mem_offset[cs][SLS_BLOCK_PSUM] -
-			mem_info->mem_offset[cs][SLS_BLOCK_TAGS];
-		mem_info->mem_size[cs][SLS_BLOCK_PSUM] =
-			EMBT_BASE_CS1_OFFSET -
-			mem_info->mem_offset
-				[0]
-				[SLS_BLOCK_PSUM]; // Assume that all psum sizes are the same
-	}
-
-	/* if more than one rank per CS, then it is AXDIMM type */
-	if (mem_info->devtype != SLS_CXL)
-		return;
-
-	/* one rank per CS, CXL type, need to adjust offsets and size */
-	for (cs = 0; cs < mem_info->num_of_cs; cs++) {
-		for (block = 0; block < SLS_BLOCK_MAX; ++block) {
-			/* [TODO: MCS23-1373] get rid of magic '2' once mem_info
-			 * initialization will be refactored by above task
-			 */
-			mem_info->mem_offset[cs][block] /= 2;
-			mem_info->mem_size[cs][block] /= 2;
-		}
-	}
-}
-
-#endif /* __SLS_SET_MEM_INFO_H__ */
diff --git a/include/linux/sls_common.h b/include/linux/sls_common.h
index 489153552..99e154824 100644
--- a/include/linux/sls_common.h
+++ b/include/linux/sls_common.h
@@ -9,63 +9,51 @@
 #ifndef __SLS_COMMON_H__
 #define __SLS_COMMON_H__
 
-#include <linux/pnm_sls_mem_topology.h>
 #include <linux/sls_resources.h>
 #include <linux/io.h>
+#include <linux/range.h>
 #include <linux/types.h>
 
-#define SLS_TYPE_UNDEFINED 0
-#define SLS_TYPE_AXDIMM 1
-#define SLS_TYPE_CXL 2
-#define SLS_TYPE_MAX 3
+/* [TODO: @p.bred] Get rid of whole file, export necessary for DAX API */
+
+#define DEV_TYPE_SLS_AXDIMM 1
+#define DEV_TYPE_SLS_CXL 2
 
 enum sls_device_type {
-	SLS_UNDEFINED = SLS_TYPE_UNDEFINED,
-	SLS_AXDIMM = SLS_TYPE_AXDIMM,
-	SLS_CXL = SLS_TYPE_CXL,
-	SLS_MAX = SLS_TYPE_MAX,
+	SLS_UNDEFINED = 0,
+	SLS_AXDIMM = DEV_TYPE_SLS_AXDIMM,
+	SLS_CXL = DEV_TYPE_SLS_CXL,
+	SLS_MAX,
 };
 
-struct sls_mem_info {
-	enum sls_device_type devtype;
-	uint64_t num_of_cs;
-	uint64_t (*mem_offset)[SLS_BLOCK_MAX];
-	uint64_t (*mem_size)[SLS_BLOCK_MAX];
+struct sls_mem_region {
+	enum sls_mem_blocks_e type;
+	struct range range;
 };
 
-static inline enum sls_device_type get_device_type(char *device_name)
-{
-	if (strcmp("AXDIMM", device_name) == 0)
-		return SLS_AXDIMM;
+struct sls_mem_info {
+	uint64_t nr_regions;
+	struct sls_mem_region regions[];
+};
 
-	if (strcmp("CXL", device_name) == 0)
-		return SLS_CXL;
+struct sls_mem_cunit_region {
+	enum sls_mem_blocks_e type;
+	struct range range;
+	struct range map_range;
+};
 
-	return SLS_UNDEFINED;
-}
+struct sls_mem_cunit_info {
+	uint64_t nr_cunits;
+	uint64_t nr_regions;
+	struct sls_mem_cunit_region regions[];
+};
 
+/* [TODO: @p.bred] Move these constants to the topology and make them dynamic */
 /* A scale of SLS memory range */
 #define SLS_MEMORY_SCALE ((uint64_t)CONFIG_DEV_SLS_MEMORY_SCALE)
-
 /* Total Memory size for SLS */
 #define SLS_MEMORY_SIZE (0x1000000000ULL >> SLS_MEMORY_SCALE)
-
 /* Start address of SLS */
 #define SLS_BASE_ADDR ((uint64_t)CONFIG_DEV_SLS_BASE_ADDR << 30)
 
-/* Base offset for each CS */
-#define EMBT_BASE_CS0_OFFSET 0ULL
-#define EMBT_BASE_CS1_OFFSET (0x800000000ULL >> SLS_MEMORY_SCALE)
-
-/* The enumeration of sls memory addresses */
-enum sls_mem_regions_e {
-	SLS_BASE_CS0 = 0,
-	SLS_TAGS_CS0 = 1,
-	SLS_PSUM_CS0 = 2,
-	SLS_BASE_CS1 = 3,
-	SLS_TAGS_CS1 = 4,
-	SLS_PSUM_CS1 = 5,
-	NUM_OF_MEM_REGION = 6 /* Number of index for memory mapping region */
-};
-
 #endif /* __SLS_COMMON_H__ */
diff --git a/include/uapi/linux/pnm_sls_mem_topology.h b/include/uapi/linux/pnm_sls_mem_topology.h
deleted file mode 100644
index a9791bef3..000000000
--- a/include/uapi/linux/pnm_sls_mem_topology.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-/*
- * Copyright (C) 2021 Samsung Electronics Co. LTD
- *
- * This software is proprietary of Samsung Electronics.
- * No part of this software, either material or conceptual may be copied or
- * distributed, transmitted, transcribed, stored in a retrieval system or
- * translated into any human or computer language in any form by any means,
- * electronic, mechanical, manual or otherwise, or disclosed to third parties
- * without the express written permission of Samsung Electronics.
- */
-#ifndef __PNM_SLS_MEM_TOPOLOGY_H__
-#define __PNM_SLS_MEM_TOPOLOGY_H__
-
-//[TODO: MCS23-1373] move to kernelspace includes
-
-#ifdef __KERNEL__
-#include <linux/types.h>
-#else
-#include <stdint.h> // for uint64_t
-#endif
-
-/* channel ID used by SLS accelerator */
-/* [TODO: MCS23-1373] remove once 'sls_set_mem_info' will be refactored */
-#define SLS_CH_ID 0
-
-#endif
-
-/* __PNM_SLS_MEM_TOPOLOGY_H__ */
diff --git a/include/uapi/linux/sls_resources.h b/include/uapi/linux/sls_resources.h
index 6104d0477..85c5a2554 100644
--- a/include/uapi/linux/sls_resources.h
+++ b/include/uapi/linux/sls_resources.h
@@ -20,8 +20,6 @@
 #include <stdint.h> // for uint64_t
 #endif
 
-#include <linux/pnm_sls_mem_topology.h>
-
 #define SLS_RESOURCE_DEVICE_NAME "sls_resource"
 
 /* Path to SLS resource manager device within /dev */
@@ -33,8 +31,7 @@
 	"/dev/" PNM_RESOURCE_CLASS_NAME "/" SLS_RESOURCE_DEVICE_NAME
 
 /* Path to SLS memory device */
-#define SLS_MEMDEV_PATH \
-	"/dev/" PNM_RESOURCE_CLASS_NAME "/" SLS_RESOURCE_DEVICE_NAME
+#define SLS_MEMDEV_PATH "/dev/sls_device"
 
 /* Path to DAX device */
 #define DAX_PATH "/dev/dax0.0"
@@ -42,6 +39,15 @@
 /* Path to sls_resource sysfs root */
 #define SLS_SYSFS_ROOT "/sys/class/" SLS_RESOURCE_PATH_INTERNAL
 
+/* Path for cunits info */
+#define DEVICE_RANKS_PATH "ranks"
+/* Path for mappings info */
+#define DEVICE_MAPPINGS_PATH "mappings"
+
+// Block of sysfs paths for device manipulation and statistics
+// SLS_RESOURCE_PATH/cunits/
+// [TODO: MCS23-1498] Move this paths to upper directory
+
 /* O_WRONLY Path to reset device, write "1" for reset */
 #define DEVICE_RESET_PATH "reset"
 /* O_RDWR Path to acquisition timeout, measured in ns */
@@ -57,76 +63,93 @@
  */
 #define DEVICE_LEAKED_PATH "leaked"
 
+// Block of sysfs paths for topology info, all O_RDONLY
+// SLS_RESOURCE_PATH/topology
+
+/* Macro for constructing topology paths */
 #define DEVICE_TOPOLOGY_PATH "topology"
+#define DEVICE_TOPOLOGY_CONSTANT_PATH(constant) \
+	DEVICE_TOPOLOGY_PATH "/" #constant
 
-// Block of sysfs paths for topology info, all O_RDONLY
-/* Number of ranks */
-#define ATTR_NUM_OF_RANKS_PATH DEVICE_TOPOLOGY_PATH "/num_of_ranks"
-/* Number of chip selects */
-#define ATTR_NUM_OF_CS_PATH DEVICE_TOPOLOGY_PATH "/num_of_cs"
-/* Number of channels */
-#define ATTR_NUM_OF_CHANNEL_PATH DEVICE_TOPOLOGY_PATH "/num_of_channel"
+/* Number of cunits */
+#define ATTR_NUM_OF_CUNITS_PATH DEVICE_TOPOLOGY_CONSTANT_PATH(nr_cunits)
+/* Number of picks */
+#define ATTR_NUM_OF_CS_PATH DEVICE_TOPOLOGY_CONSTANT_PATH(nr_cs)
 
 /* Size of single instruction in bytes*/
-#define ATTR_INSTRUCTION_SIZE_PATH DEVICE_TOPOLOGY_PATH "/instruction_size"
+#define ATTR_INSTRUCTION_SIZE_PATH DEVICE_TOPOLOGY_CONSTANT_PATH(inst_sz)
 /* Size of single element in sparse vector in bytes */
-#define ATTR_DATA_SIZE_PATH DEVICE_TOPOLOGY_PATH "/data_size"
+#define ATTR_DATA_SIZE_PATH DEVICE_TOPOLOGY_CONSTANT_PATH(data_sz)
 /* Size of TAG for sparse vector in bytes */
-#define ATTR_ALIGNED_TAG_SIZE_PATH DEVICE_TOPOLOGY_PATH "/aligned_tag_size"
+#define ATTR_ALIGNED_TAG_SIZE_PATH DEVICE_TOPOLOGY_CONSTANT_PATH(aligned_tag_sz)
 
-/* Rank interleaving size in bytes */
-#define ATTR_RANK_INTERLEAVING_SIZE_PATH \
-	DEVICE_TOPOLOGY_PATH "/rank_interleaving_size"
+/* Cunit interleaving size in bytes */
+#define ATTR_CUNIT_INTERLEAVING_SIZE_PATH \
+	DEVICE_TOPOLOGY_CONSTANT_PATH(cunit_interleaving_sz)
 /* Channel interleaving size in bytes */
 #define ATTR_CHANNEL_INTERLEAVING_SIZE_PATH \
-	DEVICE_TOPOLOGY_PATH "/channel_interleaving_size"
+	DEVICE_TOPOLOGY_CONSTANT_PATH(ch_interleaving_sz)
 /* Interleaving stride in bytes */
 #define ATTR_INTERLEAVING_STRIDE_PATH \
-	DEVICE_TOPOLOGY_PATH "/interleaving_stride"
+	DEVICE_TOPOLOGY_CONSTANT_PATH(interleaving_stride)
 
 /* Offset for polling register */
 #define ATTR_POLLING_REGISTER_OFFSET_PATH \
-	DEVICE_TOPOLOGY_PATH "/polling_reg_offset"
+	DEVICE_TOPOLOGY_CONSTANT_PATH(reg_poll)
 /* Value to execute SLS operation */
-#define ATTR_SLS_EXEC_VALUE_PATH DEVICE_TOPOLOGY_PATH "/sls_exec_value"
+#define ATTR_SLS_EXEC_VALUE_PATH DEVICE_TOPOLOGY_CONSTANT_PATH(reg_exec)
 /* Offset for SLS-enable register */
-#define ATTR_REG_SLS_EN_PATH DEVICE_TOPOLOGY_PATH "/enable_sls_reg_offset"
+#define ATTR_REG_SLS_EN_PATH DEVICE_TOPOLOGY_CONSTANT_PATH(reg_en)
 
-/* The number and the size (in bytes) of psum buffers in order (number size) */
-#define ATTR_PSUM_BUFFER_PATH DEVICE_TOPOLOGY_PATH "/psum_buffer"
+/* Instruction, Psum & Tags Buffers Size (Bytes) */
+#define ATTR_BUFFER_SIZE_PATH DEVICE_TOPOLOGY_CONSTANT_PATH(buf_sz)
+/* The number of psum buffers */
+#define ATTR_PSUM_BUFFER_PATH DEVICE_TOPOLOGY_CONSTANT_PATH(nr_psum_buf)
 /* The number and the size (in bytes) of tags buffers in order (number size) */
-#define ATTR_TAGS_BUFFER_PATH DEVICE_TOPOLOGY_PATH "/tags_buffer"
+#define ATTR_TAGS_BUFFER_PATH DEVICE_TOPOLOGY_CONSTANT_PATH(nr_tag_buf)
 /* The number and the size (in bytes) of instruction buffers in order (number size) */
-#define ATTR_INST_BUFFER_PATH DEVICE_TOPOLOGY_PATH "/inst_buffer"
+#define ATTR_INST_BUFFER_PATH DEVICE_TOPOLOGY_CONSTANT_PATH(nr_inst_buf)
 
-// Block of sysfs paths for ranks info, all O_RDONLY
-// DAX_SYSFS_ROOT"/dax%d.%d/ranks/%d
+// Block of sysfs paths for cunits info, all O_RDONLY
+// SLS_RESOURCE_PATH/ranks/%d
 
-/* Rank state, 0 = free, 1 = busy */
+/* O_RDONLY Rank state, 0 = free, 1 = busy */
 #define RANK_STATE_PATH "state"
-/* Rank acquisitions count */
+/* O_RDWR Rank acquisitions count */
 #define RANK_ACQUISITION_COUNT_PATH "acquisition_count"
-/* Get free size in bytes */
+/* O_RDONLY Get free size in bytes */
 #define RANK_FREE_SIZE_PATH "free_size"
 
 #define RANK_REGION_SIZE_PATH(region) "regions/" #region "/size"
 #define RANK_REGION_OFFSET_PATH(region) "regions/" #region "/offset"
+#define RANK_REGION_MAP_SIZE_PATH(region) "regions/" #region "/map_size"
+#define RANK_REGION_MAP_OFFSET_PATH(region) "regions/" #region "/map_offset"
 
 /* BASE region's size and offset */
 #define RANK_REGION_BASE_SIZE_PATH RANK_REGION_SIZE_PATH(base)
 #define RANK_REGION_BASE_OFFSET_PATH RANK_REGION_OFFSET_PATH(base)
+#define RANK_REGION_BASE_MAP_SIZE_PATH RANK_REGION_MAP_SIZE_PATH(base)
+#define RANK_REGION_BASE_MAP_OFFSET_PATH RANK_REGION_MAP_OFFSET_PATH(base)
 /* INST region's size and offset */
 #define RANK_REGION_INST_SIZE_PATH RANK_REGION_SIZE_PATH(inst)
 #define RANK_REGION_INST_OFFSET_PATH RANK_REGION_OFFSET_PATH(inst)
+#define RANK_REGION_INST_MAP_SIZE_PATH RANK_REGION_MAP_SIZE_PATH(inst)
+#define RANK_REGION_INST_MAP_OFFSET_PATH RANK_REGION_MAP_OFFSET_PATH(inst)
 /* CFGR region's size and offset */
 #define RANK_REGION_CFGR_SIZE_PATH RANK_REGION_SIZE_PATH(cfgr)
 #define RANK_REGION_CFGR_OFFSET_PATH RANK_REGION_OFFSET_PATH(cfgr)
+#define RANK_REGION_CFGR_MAP_SIZE_PATH RANK_REGION_MAP_SIZE_PATH(cfgr)
+#define RANK_REGION_CFGR_MAP_OFFSET_PATH RANK_REGION_MAP_OFFSET_PATH(cfgr)
 /* TAGS region's size and offset */
 #define RANK_REGION_TAGS_SIZE_PATH RANK_REGION_SIZE_PATH(tags)
 #define RANK_REGION_TAGS_OFFSET_PATH RANK_REGION_OFFSET_PATH(tags)
+#define RANK_REGION_TAGS_MAP_SIZE_PATH RANK_REGION_MAP_SIZE_PATH(tags)
+#define RANK_REGION_TAGS_MAP_OFFSET_PATH RANK_REGION_MAP_OFFSET_PATH(tags)
 /* PSUM region's size and offset */
 #define RANK_REGION_PSUM_SIZE_PATH RANK_REGION_SIZE_PATH(psum)
 #define RANK_REGION_PSUM_OFFSET_PATH RANK_REGION_OFFSET_PATH(psum)
+#define RANK_REGION_PSUM_MAP_SIZE_PATH RANK_REGION_MAP_SIZE_PATH(psum)
+#define RANK_REGION_PSUM_MAP_OFFSET_PATH RANK_REGION_MAP_OFFSET_PATH(psum)
 
 /* The enumeration of sls blocks addresses */
 enum sls_mem_blocks_e {
diff --git a/install_sls_headers.sh b/install_sls_headers.sh
index 1da3fc5dc..2e43cb1f6 100755
--- a/install_sls_headers.sh
+++ b/install_sls_headers.sh
@@ -4,10 +4,6 @@
 
 set -e
 
-sudo cp -v include/uapi/linux/pnm_sls_mem_topology.h /usr/include/linux
-sudo cp -v include/uapi/linux/pnm_sls_mem_topology.h \
- /usr/src/linux-headers-`uname -r`/include/uapi/linux/pnm_sls_mem_topology.h
-
 sudo cp -v include/uapi/linux/sls_resources.h /usr/include/linux
 sudo cp -v include/uapi/linux/sls_resources.h \
  /usr/src/linux-headers-`uname -r`/include/uapi/linux/sls_resources.h
-- 
2.34.1

