From bfb2df581e7cff8430e119d6622588d6cf40ea75 Mon Sep 17 00:00:00 2001
From: Maxim Ostapenko <maxim.o@samsung.com>
Date: Thu, 31 Aug 2023 00:27:40 +0000
Subject: [PATCH 1/4] [OneMCC] Perform PNM SLS performance simulator release
 for v2.0

This is a patch bomb for all changes made in DRAMsim3 for PNM SLS
operation. It includes:

* support CXL SLS in DRAMsim3.
* a trace generator tool for testing.
* a trace converter tool to convert QEMU memory trace dump to format
  suitable for performance simulator.
* various useful scripts.

Signed-off-by: Maxim Ostapenko <maxim.o@samsung.com>
---
 .gitmodules                                   |   4 -
 .vscode/.cmaketools.json                      |  10 -
 .vscode/launch.json                           |  70 ---
 .vscode/settings-backup.json                  |   6 -
 .vscode/tasks.json                            |  12 -
 README.md                                     | 293 ++++++-----
 README_REAL_APP_MODE.md                       | 256 ++++++++++
 configs/real_app_mode.ini                     |  67 +++
 ext/SuperLU_MT_3.1                            |   1 -
 .clang-format => pnm_sim/.clang-format        |   0
 .travis.yml => pnm_sim/.travis.yml            |   0
 CMakeLists.txt => pnm_sim/CMakeLists.txt      |  50 +-
 LICENSE => pnm_sim/LICENSE                    |   0
 Makefile => pnm_sim/Makefile                  |   0
 pnm_sim/README_DRAMsim3.md                    | 158 ++++++
 .../configs}/DDR3_1Gb_x8_1333.ini             |   0
 .../configs}/DDR3_4Gb_x16_1600.ini            |   0
 .../configs}/DDR3_4Gb_x16_1866.ini            |   0
 .../configs}/DDR3_4Gb_x4_1600.ini             |   0
 .../configs}/DDR3_4Gb_x4_1866.ini             |   0
 .../configs}/DDR3_4Gb_x8_1600.ini             |   0
 .../configs}/DDR3_4Gb_x8_1866.ini             |   0
 .../configs}/DDR3_8Gb_x16_1600.ini            |   0
 .../configs}/DDR3_8Gb_x16_1866.ini            |   0
 .../configs}/DDR3_8Gb_x4_1600.ini             |   0
 .../configs}/DDR3_8Gb_x4_1866.ini             |   0
 .../configs}/DDR3_8Gb_x8_1600.ini             |   0
 .../configs}/DDR3_8Gb_x8_1866.ini             |   0
 .../configs}/DDR4_4Gb_x16_1866.ini            |   0
 .../configs}/DDR4_4Gb_x16_2133.ini            |   0
 .../configs}/DDR4_4Gb_x16_2133_2.ini          |   0
 .../configs}/DDR4_4Gb_x16_2400.ini            |   0
 .../configs}/DDR4_4Gb_x16_2400_2.ini          |   0
 .../configs}/DDR4_4Gb_x16_2666.ini            |   0
 .../configs}/DDR4_4Gb_x16_2666_2.ini          |   0
 .../configs}/DDR4_4Gb_x4_1866.ini             |   0
 .../configs}/DDR4_4Gb_x4_2133.ini             |   0
 .../configs}/DDR4_4Gb_x4_2133_2.ini           |   0
 .../configs}/DDR4_4Gb_x4_2400.ini             |   0
 .../configs}/DDR4_4Gb_x4_2400_2.ini           |   0
 .../configs}/DDR4_4Gb_x4_2666.ini             |   0
 .../configs}/DDR4_4Gb_x4_2666_2.ini           |   0
 .../configs}/DDR4_4Gb_x8_1866.ini             |   0
 .../configs}/DDR4_4Gb_x8_2133.ini             |   0
 .../configs}/DDR4_4Gb_x8_2133_2.ini           |   0
 .../configs}/DDR4_4Gb_x8_2400.ini             |   0
 .../configs}/DDR4_4Gb_x8_2400_2.ini           |   0
 .../configs}/DDR4_4Gb_x8_2666.ini             |   0
 .../configs}/DDR4_4Gb_x8_2666_2.ini           |   0
 pnm_sim/configs/DDR4_8Gb_x16_1866.ini         |  67 +++
 pnm_sim/configs/DDR4_8Gb_x16_2133.ini         |  67 +++
 pnm_sim/configs/DDR4_8Gb_x16_2133_2.ini       |  67 +++
 pnm_sim/configs/DDR4_8Gb_x16_2400.ini         |  67 +++
 pnm_sim/configs/DDR4_8Gb_x16_2400_2.ini       |  67 +++
 pnm_sim/configs/DDR4_8Gb_x16_2666.ini         |  67 +++
 pnm_sim/configs/DDR4_8Gb_x16_2666_2.ini       |  67 +++
 pnm_sim/configs/DDR4_8Gb_x16_2933.ini         |  67 +++
 pnm_sim/configs/DDR4_8Gb_x16_2933_2.ini       |  67 +++
 pnm_sim/configs/DDR4_8Gb_x16_3200.ini         |  67 +++
 .../configs}/DDR4_8Gb_x4_1866.ini             |   0
 .../configs}/DDR4_8Gb_x4_2133.ini             |   0
 .../configs}/DDR4_8Gb_x4_2133_2.ini           |   0
 .../configs}/DDR4_8Gb_x4_2400.ini             |   0
 .../configs}/DDR4_8Gb_x4_2400_2.ini           |   0
 .../configs}/DDR4_8Gb_x4_2666.ini             |   0
 .../configs}/DDR4_8Gb_x4_2666_2.ini           |   0
 .../configs}/DDR4_8Gb_x4_2933.ini             |   0
 .../configs}/DDR4_8Gb_x4_2933_2.ini           |   0
 .../configs}/DDR4_8Gb_x4_3200.ini             |   0
 .../configs}/DDR4_8Gb_x8_1866.ini             |   0
 .../configs}/DDR4_8Gb_x8_2133.ini             |   0
 .../configs}/DDR4_8Gb_x8_2133_2.ini           |   0
 .../configs}/DDR4_8Gb_x8_2400.ini             |   0
 .../configs}/DDR4_8Gb_x8_2400_2.ini           |   0
 .../configs}/DDR4_8Gb_x8_2666.ini             |   0
 .../configs}/DDR4_8Gb_x8_2666_2.ini           |   0
 .../configs}/DDR4_8Gb_x8_2933.ini             |   0
 .../configs}/DDR4_8Gb_x8_2933_2.ini           |   0
 .../configs}/DDR4_8Gb_x8_3200.ini             |   0
 .../configs}/GDDR5X_8Gb_x32.ini               |   0
 .../configs}/GDDR5_1Gb_x32.ini                |   0
 .../configs}/GDDR5_8Gb_x32.ini                |   0
 .../configs}/GDDR6_8Gb_x16.ini                |   0
 .../configs}/HBM1_4Gb_x128.ini                |   0
 .../configs}/HBM2_4Gb_x128.ini                |   0
 .../configs}/HBM2_8Gb_x128.ini                |   0
 {configs => pnm_sim/configs}/HBM_4Gb_x128.ini |   0
 .../configs}/HMC2_8GB_4Lx16.ini               |   0
 .../configs}/HMC_2GB_4Lx16.ini                |   0
 .../configs}/HMC_2GB_4Lx16_dummy.ini          |   0
 .../configs}/HMC_4GB_4Lx16.ini                |   0
 .../configs}/LPDDR3_8Gb_x32_1333.ini          |   0
 .../configs}/LPDDR3_8Gb_x32_1600.ini          |   0
 .../configs}/LPDDR3_8Gb_x32_1866.ini          |   0
 .../configs}/LPDDR4_8Gb_x16_2400.ini          |   0
 {configs => pnm_sim/configs}/ST-1.2x.ini      |   0
 {configs => pnm_sim/configs}/ST-1.5x.ini      |   0
 {configs => pnm_sim/configs}/ST-2.0x.ini      |   0
 {configs => pnm_sim/configs}/ddr3_debug.ini   |   0
 {configs => pnm_sim/configs}/ddr4_debug.ini   |   0
 .../configs}/lpddr_2Gb_x16.ini                |   0
 {ext => pnm_sim/ext}/fmt/LICENSE.rst          |   0
 {ext => pnm_sim/ext}/fmt/include/fmt/core.h   |   0
 .../ext}/fmt/include/fmt/format-inl.h         |   0
 {ext => pnm_sim/ext}/fmt/include/fmt/format.h |   0
 {ext => pnm_sim/ext}/headers/INIHLICENSE.txt  |   0
 {ext => pnm_sim/ext}/headers/INIReader.h      |   0
 {ext => pnm_sim/ext}/headers/args.hxx         |   0
 {ext => pnm_sim/ext}/headers/catch.hpp        |   0
 {ext => pnm_sim/ext}/headers/json.hpp         |   0
 {scripts => pnm_sim/scripts}/batch_run.py     |   0
 .../scripts}/final_PowerTemperature_map.py    |   0
 {scripts => pnm_sim/scripts}/heatmap.py       |   0
 {scripts => pnm_sim/scripts}/parse_config.py  |   0
 {scripts => pnm_sim/scripts}/plot_stats.py    |   0
 {scripts => pnm_sim/scripts}/trace_gen.py     |   0
 {scripts => pnm_sim/scripts}/validation.py    |   0
 pnm_sim/src/address_decoder.cc                | 169 +++++++
 pnm_sim/src/address_decoder.h                 |  52 ++
 {src => pnm_sim/src}/bankstate.cc             |   0
 {src => pnm_sim/src}/bankstate.h              |   0
 {src => pnm_sim/src}/channel_state.cc         |   6 +-
 {src => pnm_sim/src}/channel_state.h          |   0
 {src => pnm_sim/src}/command_queue.cc         |   0
 {src => pnm_sim/src}/command_queue.h          |   0
 pnm_sim/src/common.cc                         | 289 +++++++++++
 {src => pnm_sim/src}/common.h                 |  97 +++-
 {src => pnm_sim/src}/configuration.cc         |  27 +-
 {src => pnm_sim/src}/configuration.h          |  17 +
 {src => pnm_sim/src}/controller.cc            |  34 +-
 {src => pnm_sim/src}/controller.h             |   9 +-
 src/cpu.cc => pnm_sim/src/cxl.cc              |  45 +-
 src/cpu.h => pnm_sim/src/cxl.h                |  36 +-
 {src => pnm_sim/src}/dram_system.cc           |  87 +++-
 {src => pnm_sim/src}/dram_system.h            |  33 +-
 {src => pnm_sim/src}/dramsim3.h               |   0
 {src => pnm_sim/src}/hmc.cc                   |  17 +-
 {src => pnm_sim/src}/hmc.h                    |   8 +-
 {src => pnm_sim/src}/main.cc                  |  36 +-
 {src => pnm_sim/src}/memory_system.cc         |  16 +-
 {src => pnm_sim/src}/memory_system.h          |   8 +-
 pnm_sim/src/pnm.cc                            | 455 ++++++++++++++++++
 pnm_sim/src/pnm.h                             | 188 ++++++++
 {src => pnm_sim/src}/refresh.cc               |   0
 {src => pnm_sim/src}/refresh.h                |   0
 {src => pnm_sim/src}/simple_stats.cc          |   0
 {src => pnm_sim/src}/simple_stats.h           |   0
 {src => pnm_sim/src}/sp_ienv.c                |   0
 {src => pnm_sim/src}/thermal.cc               |   2 +-
 {src => pnm_sim/src}/thermal.h                |   0
 {src => pnm_sim/src}/thermal_config.h         |   0
 {src => pnm_sim/src}/thermal_replay.cc        |   0
 {src => pnm_sim/src}/thermal_replay.h         |   0
 {src => pnm_sim/src}/thermal_solver.c         |   0
 {src => pnm_sim/src}/timing.cc                |   0
 {src => pnm_sim/src}/timing.h                 |   0
 {tests => pnm_sim/tests}/example.trace        |   0
 {tests => pnm_sim/tests}/test_config.cc       |   0
 {tests => pnm_sim/tests}/test_dramsys.cc      |   0
 {tests => pnm_sim/tests}/test_hmcsys.cc       |   0
 scripts/parse_configs_for_trace_gen.py        | 110 +++++
 scripts/run_pnm_sim.sh                        |  31 ++
 scripts/run_trace_gen.sh                      |  32 ++
 .../run_pnm_sim_real_app_mode.sh              |  22 +
 scripts_real_app_mode/run_qemu.sh             |  39 ++
 scripts_real_app_mode/ssh_qemu.sh             |   8 +
 scripts_real_app_mode/trace_conv.py           | 286 +++++++++++
 scripts_real_app_mode/vnc_qemu.sh             |   5 +
 src/common.cc                                 |  94 ----
 trace_gen/Sconstruct                          |  37 ++
 trace_gen/common.h                            | 220 +++++++++
 trace_gen/config.cpp                          | 231 +++++++++
 trace_gen/config.h                            |  85 ++++
 trace_gen/instruction.cpp                     | 133 +++++
 trace_gen/instruction.h                       |  47 ++
 trace_gen/main.cpp                            | 160 ++++++
 176 files changed, 4324 insertions(+), 444 deletions(-)
 delete mode 100644 .vscode/.cmaketools.json
 delete mode 100644 .vscode/launch.json
 delete mode 100644 .vscode/settings-backup.json
 delete mode 100644 .vscode/tasks.json
 create mode 100644 README_REAL_APP_MODE.md
 create mode 100644 configs/real_app_mode.ini
 delete mode 160000 ext/SuperLU_MT_3.1
 rename .clang-format => pnm_sim/.clang-format (100%)
 rename .travis.yml => pnm_sim/.travis.yml (100%)
 rename CMakeLists.txt => pnm_sim/CMakeLists.txt (71%)
 rename LICENSE => pnm_sim/LICENSE (100%)
 rename Makefile => pnm_sim/Makefile (100%)
 create mode 100644 pnm_sim/README_DRAMsim3.md
 rename {configs => pnm_sim/configs}/DDR3_1Gb_x8_1333.ini (100%)
 rename {configs => pnm_sim/configs}/DDR3_4Gb_x16_1600.ini (100%)
 rename {configs => pnm_sim/configs}/DDR3_4Gb_x16_1866.ini (100%)
 rename {configs => pnm_sim/configs}/DDR3_4Gb_x4_1600.ini (100%)
 rename {configs => pnm_sim/configs}/DDR3_4Gb_x4_1866.ini (100%)
 rename {configs => pnm_sim/configs}/DDR3_4Gb_x8_1600.ini (100%)
 rename {configs => pnm_sim/configs}/DDR3_4Gb_x8_1866.ini (100%)
 rename {configs => pnm_sim/configs}/DDR3_8Gb_x16_1600.ini (100%)
 rename {configs => pnm_sim/configs}/DDR3_8Gb_x16_1866.ini (100%)
 rename {configs => pnm_sim/configs}/DDR3_8Gb_x4_1600.ini (100%)
 rename {configs => pnm_sim/configs}/DDR3_8Gb_x4_1866.ini (100%)
 rename {configs => pnm_sim/configs}/DDR3_8Gb_x8_1600.ini (100%)
 rename {configs => pnm_sim/configs}/DDR3_8Gb_x8_1866.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x16_1866.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x16_2133.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x16_2133_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x16_2400.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x16_2400_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x16_2666.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x16_2666_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x4_1866.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x4_2133.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x4_2133_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x4_2400.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x4_2400_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x4_2666.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x4_2666_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x8_1866.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x8_2133.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x8_2133_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x8_2400.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x8_2400_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x8_2666.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_4Gb_x8_2666_2.ini (100%)
 create mode 100644 pnm_sim/configs/DDR4_8Gb_x16_1866.ini
 create mode 100644 pnm_sim/configs/DDR4_8Gb_x16_2133.ini
 create mode 100644 pnm_sim/configs/DDR4_8Gb_x16_2133_2.ini
 create mode 100644 pnm_sim/configs/DDR4_8Gb_x16_2400.ini
 create mode 100644 pnm_sim/configs/DDR4_8Gb_x16_2400_2.ini
 create mode 100644 pnm_sim/configs/DDR4_8Gb_x16_2666.ini
 create mode 100644 pnm_sim/configs/DDR4_8Gb_x16_2666_2.ini
 create mode 100644 pnm_sim/configs/DDR4_8Gb_x16_2933.ini
 create mode 100644 pnm_sim/configs/DDR4_8Gb_x16_2933_2.ini
 create mode 100644 pnm_sim/configs/DDR4_8Gb_x16_3200.ini
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x4_1866.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x4_2133.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x4_2133_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x4_2400.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x4_2400_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x4_2666.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x4_2666_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x4_2933.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x4_2933_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x4_3200.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x8_1866.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x8_2133.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x8_2133_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x8_2400.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x8_2400_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x8_2666.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x8_2666_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x8_2933.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x8_2933_2.ini (100%)
 rename {configs => pnm_sim/configs}/DDR4_8Gb_x8_3200.ini (100%)
 rename {configs => pnm_sim/configs}/GDDR5X_8Gb_x32.ini (100%)
 rename {configs => pnm_sim/configs}/GDDR5_1Gb_x32.ini (100%)
 rename {configs => pnm_sim/configs}/GDDR5_8Gb_x32.ini (100%)
 rename {configs => pnm_sim/configs}/GDDR6_8Gb_x16.ini (100%)
 rename {configs => pnm_sim/configs}/HBM1_4Gb_x128.ini (100%)
 rename {configs => pnm_sim/configs}/HBM2_4Gb_x128.ini (100%)
 rename {configs => pnm_sim/configs}/HBM2_8Gb_x128.ini (100%)
 rename {configs => pnm_sim/configs}/HBM_4Gb_x128.ini (100%)
 rename {configs => pnm_sim/configs}/HMC2_8GB_4Lx16.ini (100%)
 rename {configs => pnm_sim/configs}/HMC_2GB_4Lx16.ini (100%)
 rename {configs => pnm_sim/configs}/HMC_2GB_4Lx16_dummy.ini (100%)
 rename {configs => pnm_sim/configs}/HMC_4GB_4Lx16.ini (100%)
 rename {configs => pnm_sim/configs}/LPDDR3_8Gb_x32_1333.ini (100%)
 rename {configs => pnm_sim/configs}/LPDDR3_8Gb_x32_1600.ini (100%)
 rename {configs => pnm_sim/configs}/LPDDR3_8Gb_x32_1866.ini (100%)
 rename {configs => pnm_sim/configs}/LPDDR4_8Gb_x16_2400.ini (100%)
 rename {configs => pnm_sim/configs}/ST-1.2x.ini (100%)
 rename {configs => pnm_sim/configs}/ST-1.5x.ini (100%)
 rename {configs => pnm_sim/configs}/ST-2.0x.ini (100%)
 rename {configs => pnm_sim/configs}/ddr3_debug.ini (100%)
 rename {configs => pnm_sim/configs}/ddr4_debug.ini (100%)
 rename {configs => pnm_sim/configs}/lpddr_2Gb_x16.ini (100%)
 rename {ext => pnm_sim/ext}/fmt/LICENSE.rst (100%)
 rename {ext => pnm_sim/ext}/fmt/include/fmt/core.h (100%)
 rename {ext => pnm_sim/ext}/fmt/include/fmt/format-inl.h (100%)
 rename {ext => pnm_sim/ext}/fmt/include/fmt/format.h (100%)
 rename {ext => pnm_sim/ext}/headers/INIHLICENSE.txt (100%)
 rename {ext => pnm_sim/ext}/headers/INIReader.h (100%)
 rename {ext => pnm_sim/ext}/headers/args.hxx (100%)
 rename {ext => pnm_sim/ext}/headers/catch.hpp (100%)
 rename {ext => pnm_sim/ext}/headers/json.hpp (100%)
 rename {scripts => pnm_sim/scripts}/batch_run.py (100%)
 rename {scripts => pnm_sim/scripts}/final_PowerTemperature_map.py (100%)
 rename {scripts => pnm_sim/scripts}/heatmap.py (100%)
 rename {scripts => pnm_sim/scripts}/parse_config.py (100%)
 rename {scripts => pnm_sim/scripts}/plot_stats.py (100%)
 rename {scripts => pnm_sim/scripts}/trace_gen.py (100%)
 rename {scripts => pnm_sim/scripts}/validation.py (100%)
 create mode 100644 pnm_sim/src/address_decoder.cc
 create mode 100644 pnm_sim/src/address_decoder.h
 rename {src => pnm_sim/src}/bankstate.cc (100%)
 rename {src => pnm_sim/src}/bankstate.h (100%)
 rename {src => pnm_sim/src}/channel_state.cc (99%)
 rename {src => pnm_sim/src}/channel_state.h (100%)
 rename {src => pnm_sim/src}/command_queue.cc (100%)
 rename {src => pnm_sim/src}/command_queue.h (100%)
 create mode 100644 pnm_sim/src/common.cc
 rename {src => pnm_sim/src}/common.h (55%)
 rename {src => pnm_sim/src}/configuration.cc (93%)
 rename {src => pnm_sim/src}/configuration.h (92%)
 rename {src => pnm_sim/src}/controller.cc (93%)
 rename {src => pnm_sim/src}/controller.h (94%)
 rename src/cpu.cc => pnm_sim/src/cxl.cc (67%)
 rename src/cpu.h => pnm_sim/src/cxl.h (62%)
 rename {src => pnm_sim/src}/dram_system.cc (68%)
 rename {src => pnm_sim/src}/dram_system.h (65%)
 rename {src => pnm_sim/src}/dramsim3.h (100%)
 rename {src => pnm_sim/src}/hmc.cc (97%)
 rename {src => pnm_sim/src}/hmc.h (92%)
 rename {src => pnm_sim/src}/main.cc (65%)
 rename {src => pnm_sim/src}/memory_system.cc (80%)
 rename {src => pnm_sim/src}/memory_system.h (80%)
 create mode 100644 pnm_sim/src/pnm.cc
 create mode 100644 pnm_sim/src/pnm.h
 rename {src => pnm_sim/src}/refresh.cc (100%)
 rename {src => pnm_sim/src}/refresh.h (100%)
 rename {src => pnm_sim/src}/simple_stats.cc (100%)
 rename {src => pnm_sim/src}/simple_stats.h (100%)
 rename {src => pnm_sim/src}/sp_ienv.c (100%)
 rename {src => pnm_sim/src}/thermal.cc (99%)
 rename {src => pnm_sim/src}/thermal.h (100%)
 rename {src => pnm_sim/src}/thermal_config.h (100%)
 rename {src => pnm_sim/src}/thermal_replay.cc (100%)
 rename {src => pnm_sim/src}/thermal_replay.h (100%)
 rename {src => pnm_sim/src}/thermal_solver.c (100%)
 rename {src => pnm_sim/src}/timing.cc (100%)
 rename {src => pnm_sim/src}/timing.h (100%)
 rename {tests => pnm_sim/tests}/example.trace (100%)
 rename {tests => pnm_sim/tests}/test_config.cc (100%)
 rename {tests => pnm_sim/tests}/test_dramsys.cc (100%)
 rename {tests => pnm_sim/tests}/test_hmcsys.cc (100%)
 create mode 100644 scripts/parse_configs_for_trace_gen.py
 create mode 100644 scripts/run_pnm_sim.sh
 create mode 100644 scripts/run_trace_gen.sh
 create mode 100644 scripts_real_app_mode/run_pnm_sim_real_app_mode.sh
 create mode 100644 scripts_real_app_mode/run_qemu.sh
 create mode 100644 scripts_real_app_mode/ssh_qemu.sh
 create mode 100644 scripts_real_app_mode/trace_conv.py
 create mode 100644 scripts_real_app_mode/vnc_qemu.sh
 delete mode 100644 src/common.cc
 create mode 100644 trace_gen/Sconstruct
 create mode 100644 trace_gen/common.h
 create mode 100644 trace_gen/config.cpp
 create mode 100644 trace_gen/config.h
 create mode 100644 trace_gen/instruction.cpp
 create mode 100644 trace_gen/instruction.h
 create mode 100644 trace_gen/main.cpp

diff --git a/.gitmodules b/.gitmodules
index 3316355..e69de29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,4 +0,0 @@
-[submodule "ext/SuperLU_MT_3.1"]
-	path = ext/SuperLU_MT_3.1
-	url = https://github.com/umd-memsys/SuperLU_MT_3.1.git
-	ignore = dirty
diff --git a/.vscode/.cmaketools.json b/.vscode/.cmaketools.json
deleted file mode 100644
index 0a3d8ea..0000000
--- a/.vscode/.cmaketools.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-  "variant": {
-    "label": "Debug",
-    "keywordSettings": {
-      "buildType": "debug"
-    },
-    "description": "Emit debug information without performing optimizations"
-  },
-  "activeEnvironments": []
-}
\ No newline at end of file
diff --git a/.vscode/launch.json b/.vscode/launch.json
deleted file mode 100644
index 333904f..0000000
--- a/.vscode/launch.json
+++ /dev/null
@@ -1,70 +0,0 @@
-{
-    "version": "0.2.0",
-    "configurations": [
-        
-        {
-            "name": "C++ Launch",
-            "type": "cppdbg",
-            "request": "launch",
-            "program": "${workspaceRoot}/build/dramcoremain",
-            "args": ["-c", "./../configs/ddr4_8G_x8_config.ini", "-n", "100000", "--trace-cpu", "--trace-file", "./../sample_trace.txt"],
-            "stopAtEntry": true,
-            "cwd": "${workspaceRoot}/build",
-            "environment": [],
-            "externalConsole": true,
-            "linux": {
-                "MIMode": "gdb",
-                "setupCommands": [
-                    {
-                        "description": "Enable pretty-printing for gdb",
-                        "text": "-enable-pretty-printing",
-                        "ignoreFailures": true
-                    }
-                ]
-            },
-            "osx": {
-                "MIMode": "lldb"
-            },
-            "windows": {
-                "MIMode": "gdb",
-                "setupCommands": [
-                    {
-                        "description": "Enable pretty-printing for gdb",
-                        "text": "-enable-pretty-printing",
-                        "ignoreFailures": true
-                    }
-                ]
-            }
-        },
-        {
-            "name": "C++ Attach",
-            "type": "cppdbg",
-            "request": "attach",
-            "program": "enter program name, for example ${workspaceRoot}/a.out",
-            "processId": "${command.pickProcess}",
-            "linux": {
-                "MIMode": "gdb",
-                "setupCommands": [
-                    {
-                        "description": "Enable pretty-printing for gdb",
-                        "text": "-enable-pretty-printing",
-                        "ignoreFailures": true
-                    }
-                ]
-            },
-            "osx": {
-                "MIMode": "lldb"
-            },
-            "windows": {
-                "MIMode": "gdb",
-                "setupCommands": [
-                    {
-                        "description": "Enable pretty-printing for gdb",
-                        "text": "-enable-pretty-printing",
-                        "ignoreFailures": true
-                    }
-                ]
-            }
-        }
-    ]
-}
\ No newline at end of file
diff --git a/.vscode/settings-backup.json b/.vscode/settings-backup.json
deleted file mode 100644
index 31fd83b..0000000
--- a/.vscode/settings-backup.json
+++ /dev/null
@@ -1,6 +0,0 @@
-{
-    "files.associations": {
-        "array": "cpp",
-        "initializer_list": "cpp"
-    }
-}
\ No newline at end of file
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
deleted file mode 100644
index d750152..0000000
--- a/.vscode/tasks.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-    // See https://go.microsoft.com/fwlink/?LinkId=733558
-    // for the documentation about the tasks.json format
-    "version": "0.1.0",
-    "command": "make",
-    "isShellCommand": true,
-    "args": ["-j5"],
-    "showOutput": "always",
-    "options": {
-        "cwd": "${workspaceRoot}/build"
-    }
-}
\ No newline at end of file
diff --git a/README.md b/README.md
index d47707f..5a1f0ff 100644
--- a/README.md
+++ b/README.md
@@ -1,158 +1,211 @@
-[![Build Status](https://travis-ci.com/umd-memsys/DRAMsim3.svg?branch=master)](https://travis-ci.com/umd-memsys/DRAMsim3)
+# PNMSimulator
+
+## Table of Contents
+
+- [1. Overview](#1-overview)
+- [2. CXL-PNM Architecture](#2-cxl-pnm-architecture)
+- [3. Synthetic Trace Mode](#3-synthetic-trace-mode)
+- [4. Real Application Trace Mode](#4-real-application-trace-mode)
+- [5. How to Build](#5-how-to-build)
+- [6. How to Run with Synthetic Trace Generator](#6-how-to-run-with-synthetic-trace-generator)
+- [7. Code Structure](#7-code-structure)
+
+## 1. Overview
+
+PNMSimulator is a cycle-accurate performance simulator that models the behavior
+and timing of CXL-based processing-near-memory (PNM) system. PNMSimulator
+currently supports modeling execution of SparseLengthSum (SLS) operations in
+PNM block.  PNMSimulator provides two trace modes &mdash; (1) **synthetic trace
+mode** with which PNMSimulator executes memory traffic trace generated by
+synthetic trace generator and (2) **real application trace mode** with which
+PNMSimulator executes memory traffic trace of real application executed on
+QEMU-based system. PNMSimulator is developed based on
+[DRAMsim3](https://github.com/umd-memsys/DRAMsim3) [1].
+
+## 2. CXL-PNM Architecture
+
+CXL-PNM architecture includes one address decoder and one PNM block for each
+channel.
+
+```C
+                                        |----------|
+                                        |          |
+|----------|       |------------|  (B)  |   PNM    |  (D)  |----------|
+|          |  (A)  |            |-------|          |-------|          |
+|   HOST   |-------|Addr.decoder|       |----------|       |Controller|
+|          |       |            |--------------------------|          |
+|----------|       |------------|           (C)            |----------|
+```
+* (A): CXL interface. Memory request from host.
+* (B): PNM R/W
+* (C): Normal memory R/W transaction
+* (D): PNM memory R/W transaction
+
+### 2.1. Address Decoder
 
-# About DRAMsim3
+Address Decoder determines whether the memory requests are for PNM or not. The 
+memory region for PNM is allocated.
 
-DRAMsim3 models the timing paramaters and memory controller behavior for several DRAM protocols such as DDR3, DDR4, LPDDR3, LPDDR4, GDDR5, GDDR6, HBM, HMC, STT-MRAM. It is implemented in C++ as an objected oriented model that includes a parameterized DRAM bank model, DRAM controllers, command queues and system-level interfaces to interact with a CPU simulator (GEM5, ZSim) or trace workloads. It is designed to be accurate, portable and parallel.
-    
-If you use this simulator in your work, please consider cite:
+### 2.2. PNM Block
 
-[1] S. Li, Z. Yang, D. Reddy, A. Srivastava and B. Jacob, "DRAMsim3: a Cycle-accurate, Thermal-Capable DRAM Simulator," in IEEE Computer Architecture Letters. [Link](https://ieeexplore.ieee.org/document/8999595)
+PNM block performs embedding lookup in memory and the elementwise summation.
+After finishing SLS execution, the final result is transfered back to the host
+via CXL interface. Please refer to [Section 3](#3-synthetic-trace-generator)
+for more information about PNM read/write transactions.
 
-See [Related Work](#related-work) for more work done with this simulator.
+## 3. Synthetic Trace Mode
 
+With sunthetic trace mode, PNMSimulator executes memory traffic trace generated
+by synthetic trace generator. Synthetic trace generator generates memory
+traffic and instruction traces of SLS operations for CXL-PNM performance
+simulator. It generates two types of traces &mdash; (1) CXL-PNM trace which
+assumes that SLS operations are executed on CXL-PNM device and (2) baseline
+trace which assumes that SLS operations are executed on host CPU.
 
-## Building and running the simulator
+The format of CXL-PNM trace is as follows:
+```
+# Write instruction to instruction buffer in PNM block
+<addr> WRITE <time> <inst0> <inst1> ... <inst7>
+<addr> WRITE <time> <inst0> <inst1> ... <inst7>
+...
+<addr> WRITE <time> <inst0> <inst1> ... <inst7>
+
+# Wait until finishing instruction writing and execute SLS on PNM block.
+<addr> SFENCE <time>
+<addr> WRITE <time> 0xcafe
+
+# Wait until finishing SLS execution and read PSUM buffer
+<addr> DONE
+<addr> READ <time>
+<addr> READ <time>
+...
+<addr> READ <time>
+```
 
-This simulator by default uses a CMake based build system.
-The advantage in using a CMake based build system is portability and dependency management.
-We require CMake 3.0+ to build this simulator.
-If `cmake-3.0` is not available,
-we also supply a Makefile to build the most basic version of the simulator.
+The baseline trace consists of read transactions needed for embedding table
+lookups.
+
+Users can configure characteristics of SLS operations by using the following
+command line parameters.
+
+|Parameter|Description|Example|
+|---|---|---|
+|`opcode`|Code for operation. Currently, `trace-gen` support SLS operation (`opcode 0`).|`--opcode 0`|
+|`nepochs`|Number of epochs (i.e., number of inferences with batch size of `batch_size`).|`--nepochs 2`|
+|`batch_size`|Batch size.|`--batch_size 64`|
+|`embedding_table`|List of embedding tables with sizes.|`--embedding_table "1000000-1000000"`|
+|`num_tables`|Number of tables. If this parameter is set to a positive integer value `n`, `trace_gen` assumes that there are `n` tables and the size of each table is same with the size of the first table in `embedding_table` list.|`--num_tables 0`|
+|`sparse_feature_size`|Feature size of embedding table.|`--sparse_feature_size 16`|
+|`data_type_size`|Data type size of embedding table. Total size of a table is (# of indices) * (`sparse_feature_size`) * (`data_type_size`).|`--data_type_size 4`|
+|`max_indices_per_lookup`|Maximum pooling size of a lookup.|`--max_indices_per_lookup 50`|
+|`pooling_type`|FIXED (0): pooling size of each lookup is fixed to `max_indices_per_lookup`. <br /> RANDOM (1): pooling size of each lookup is randomly determined. <br/> PROD (2): pooling size of each lookup is determined by iterating `pooling_prod_list`.|`--pooling_type 0`|
+|`pooling_prod_list`|List of pooling size when `pooling_type` is set to PROD (2).|`--pooling_prod_list "48-122-25-50"`|
+|`default_interval`|Clock tick interval between memory transactions.|`--default_interval 4`|
+|`miss_ratio`|Cache miss ratio for baseline memory trace.|`--miss_ratio 100`|
+|`base_only`|If this option is set to `true`, `trace_gen` only generates baseline memory trace.|`--base_only false`|
+|`channel`|List of CXL-PNM memory channels and channel IDs.|`--channel "0-1"`|
+|`rank`|List of ranks and rank IDs per channel.|`--rank "0-1"`|
+|`bg_size`|Number of bank groups per rank.|`--bg_size 4`|
+|`ba_size`|Number of banks per bank group.|`--ba_size 4`|
+|`ro_size`|Number of rows.|`--ro_size 65536`|
+|`co_size`|Number of columns.|`--co_size 1024`|
+|`bus_width`|Bus width.|`--bus_width 64`|
+|`BL`|Burst length.|`--BL 8`|
+|`address_mapping`|Address mapping (same format with DRAMsim3).|`--address_mapping "rochrababgco"`|
+|`file_name`|Prefix of trace file name.|`--file_name "test"`|
+
+## 4. Real Application Trace Mode
+
+PNMSimulator also supports simulation for memory traffic trace of real
+application. For more detailed information, please refer
+`README_REAL_APP_MODE.md`.
+
+## 5. How to Build
+
+### 5.1. Prerequisites
+
+- CMake 3.0+
+- SCons
+
+### 5.2. Build pnm_sim
+
+1. Download DRAMsim3 and apply patch for CXL-PNM.
 
-### Building
+```
+cd <PNMSimulator_path>/scripts
+bash get_pnm_sim.sh
+```
 
-Doing out of source builds with CMake is recommended to avoid the build files cluttering the main directory.
+2. Build `pnm_sim`.
 
-```bash
-# cmake out of source build
+```
+cd <PNMSimulator_path>/pnm_sim
 mkdir build
 cd build
-cmake ..
-
-# Build dramsim3 library and executables
-make -j4
-
-# Alternatively, build with thermal module enabled
-cmake .. -DTHERMAL=1
+cmake .. -DCMD_TRACE=1
+# Enable address trace: cmake .. -DCMD_TRACE=1 -DADDR_TRACE=1
 
+make -j
 ```
 
-The build process creates `dramsim3main` and executables in the `build` directory.
-By default, it also creates `libdramsim3.so` shared library in the project root directory.
-
-### Running
-
-```bash
-# help
-./build/dramsim3main -h
-
-# Running random stream with a config file
-./build/dramsim3main configs/DDR4_8Gb_x8_3200.ini --stream random -c 100000 
-
-# Running a trace file
-./build/dramsim3main configs/DDR4_8Gb_x8_3200.ini -c 100000 -t sample_trace.txt
-
-# Running with gem5
---mem-type=dramsim3 --dramsim3-ini=configs/DDR4_4Gb_x4_2133.ini
+### 5.3. Build trace_gen
 
 ```
+cd <PNMSimulator_path>/trace_gen
 
-The output can be directed to another directory by `-o` option
-or can be configured in the config file.
-You can control the verbosity in the config file as well.
-
-### Output Visualization
-
-`scripts/plot_stats.py` can visualize some of the output (requires `matplotlib`):
-
-```bash
-# generate histograms from overall output
-python3 scripts/plot_stats dramsim3.json
-
-# or
-# generate time series for a variety stats from epoch outputs
-python3 scripts/plot_stats dramsim3epoch.json
+scons
 ```
 
-Currently stats from all channels are squashed together for cleaner plotting.
+## 6. How to Run with Synthetic Trace Generator
 
-### Integration with other simulators
+### 6.1. Choose configuration file for memory.
 
-**Gem5** integration: works with a forked Gem5 version, see https://github.com/umd-memsys/gem5 at `dramsim3` branch for reference.
+Edit configuration file path (`config_file`) in `run_trace_gen.sh` and
+`run_pnm_sim.sh` in `script` directory.
 
-**SST** integration: see http://git.ece.umd.edu/shangli/sst-elements/tree/dramsim3 for reference. We will try to merge to official SST repo.
+Note: use the same configuation file for both scripts.
 
-**ZSim** integration: see http://git.ece.umd.edu/shangli/zsim/tree/master for reference.
+### 6.2. Run `trace_gen` to generate traces.
 
-## Simulator Design
+Before running the script, edit paramters for the trace genrator in the script.
 
-### Code Structure
+Refer [Section 3](#3-synthetic-trace-generator) for the detailed information
+about parameters.
 
 ```
-├── configs                 # Configs of various protocols that describe timing constraints and power consumption.
-├── ext                     # 
-├── scripts                 # Tools and utilities
-├── src                     # DRAMsim3 source files
-├── tests                   # Tests of each model, includes a short example trace
-├── CMakeLists.txt
-├── Makefile
-├── LICENSE
-└── README.md
-
-├── src  
-    bankstate.cc: Records and manages DRAM bank timings and states which is modeled as a state machine.
-    channelstate.cc: Records and manages channel timings and states.
-    command_queue.cc: Maintains per-bank or per-rank FIFO queueing structures, determine which commands in the queues can be issued in this cycle.
-    configuration.cc: Initiates, manages system and DRAM parameters, including protocol, DRAM timings, address mapping policy and power parameters.
-    controller.cc: Maintains the per-channel controller, which manages a queue of pending memory transactions and issues corresponding DRAM commands, 
-                   follows FR-FCFS policy.
-    cpu.cc: Implements 3 types of simple CPU: 
-            1. Random, can handle random CPU requests at full speed, the entire parallelism of DRAM protocol can be exploited without limits from address mapping and scheduling pocilies. 
-            2. Stream, provides a streaming prototype that is able to provide enough buffer hits.
-            3. Trace-based, consumes traces of workloads, feed the fetched transactions into the memory system.
-    dram_system.cc:  Initiates JEDEC or ideal DRAM system, registers the supplied callback function to let the front end driver know that the request is finished. 
-    hmc.cc: Implements HMC system and interface, HMC requests are translates to DRAM requests here and a crossbar interconnect between the high-speed links and the memory controllers is modeled.
-    main.cc: Handles the main program loop that reads in simulation arguments, DRAM configurations and tick cycle forward.
-    memory_system.cc: A wrapper of dram_system and hmc.
-    refresh.cc: Raises refresh request based on per-rank refresh or per-bank refresh.
-    timing.cc: Initiate timing constraints.
+cd <PNMSimulator_path>/scripts
+bash run_trace_gen.sh
 ```
 
-## Experiments
-
-### Verilog Validation
+Then, trace files will be saved on `scripts/traces` directory.
 
-First we generate a DRAM command trace.
-There is a `CMD_TRACE` macro and by default it's disabled.
-Use `cmake .. -DCMD_TRACE=1` to enable the command trace output build and then
-whenever a simulation is performed the command trace file will be generated.
+### 6.3. Run `pnm_sim`.
 
-Next, `scripts/validation.py` helps generate a Verilog workbench for Micron's Verilog model
-from the command trace file.
-Currently DDR3, DDR4, and LPDDR configs are supported by this script.
-
-Run
-
-```bash
-./script/validataion.py DDR4.ini cmd.trace
+```
+cd <PNMSimulator_path>/scripts
+bash run_pnm_sim.sh
 ```
 
-To generage Verilog workbench.
-Our workbench format is compatible with ModelSim Verilog simulator,
-other Verilog simulators may require a slightly different format.
-
-
-## Related Work
-
-[1] Li, S., Yang, Z., Reddy D., Srivastava, A. and Jacob, B., (2020) DRAMsim3: a Cycle-accurate, Thermal-Capable DRAM Simulator, IEEE Computer Architecture Letters.
-
-[2] Jagasivamani, M., Walden, C., Singh, D., Kang, L., Li, S., Asnaashari, M., ... & Yeung, D. (2019). Analyzing the Monolithic Integration of a ReRAM-Based Main Memory Into a CPU's Die. IEEE Micro, 39(6), 64-72.
-
-[3] Li, S., Reddy, D., & Jacob, B. (2018, October). A performance & power comparison of modern high-speed DRAM architectures. In Proceedings of the International Symposium on Memory Systems (pp. 341-353).
+The script will run the performance simulator with the traces in
+`scripts/traces` directory and save the results on `results/res_<timestamp>`
+directory.
 
-[4] Li, S., Verdejo, R. S., Radojković, P., & Jacob, B. (2019, September). Rethinking cycle accurate DRAM simulation. In Proceedings of the International Symposium on Memory Systems (pp. 184-191).
+## 7. Code Structure
 
-[5] Li, S., & Jacob, B. (2019, September). Statistical DRAM modeling. In Proceedings of the International Symposium on Memory Systems (pp. 521-530).
+```
+PNMSimulator/               # Root directory of PNMSimulator
+├─ pnm_sim/                 # Source code for the performance simulator
+├─ trace_gen/               # Source code for the synthetic trace generator
+├─ trace_conv/              # Source code for the trace converter
+├─ scripts/                 # Scripts for building and running
+├─ scripts_real_app_mode/   # Scripts for the real application trace mode
+├─ configs/                 # Configuration files for memory
+├─ results/                 # Created after running pnm_sim
+├─ README.md                # This file
+└─ README_REAL_APP_MODE.md  # README for the real application trace mode
 
-[6] Li, S. (2019). Scalable and Accurate Memory System Simulation (Doctoral dissertation).
+```
 
+[1] S. Li, Z. Yang, D. Reddy, A. Srivastava and B. Jacob, "DRAMsim3: a
+Cycle-accurate, Thermal-Capable DRAM Simulator," in IEEE Computer Architecture
+Letters. [Link](https://ieeexplore.ieee.org/document/8999595)
diff --git a/README_REAL_APP_MODE.md b/README_REAL_APP_MODE.md
new file mode 100644
index 0000000..602c8a6
--- /dev/null
+++ b/README_REAL_APP_MODE.md
@@ -0,0 +1,256 @@
+# Real Application Trace Mode
+
+## Repositories
+
+- [PNM QEMU](https://github.samsungds.net/SAITPublic/PNMqemu)
+- [PNM Linux](https://github.samsungds.net/SAITPublic/PNMlinux)
+- [PNM Library](https://github.samsungds.net/SAITPublic/PNMLibrary)
+- [PNM PyTorch](https://github.samsungds.net/SAITPublic/PNMpytorch)
+- [PNM DLRM](https://github.samsungds.net/SAITPublic/PNMdlrm)
+
+## PNM QEMU
+
+### Install Prerequisites
+
+```
+sudo apt install libglib2.0-dev libpng-dev
+sudo apt install libslirp-dev
+```
+
+### Build PNM QEMU
+
+```
+cd <PNMqemu_path>
+mkdir build
+cd build
+../configure --enable-trace-backends=simple --enable-avx2 --enable-avx512f
+make
+```
+
+### Create QEMU Image
+
+```
+cd <PNMqemu_path>/build
+./qemu-img create ./pnm-qemu.img 100G
+```
+
+### Get OS Image
+
+Download Ubuntu 22.04 server image.
+- https://ubuntu.com/
+
+### Run PNM QEMU
+
+```
+cd <PNMSimulator_path>/scripts_real_app_mode
+bash run_qemu.sh
+```
+
+Set `INSTALL="1"` for the first run (OS installation).
+Change `CPU_PARAM`.
+
+### Install Ubuntu by Using VNC
+
+```
+cd <PNMSimulator_path>/scripts_real_app_mode
+bash vnc_qemu.sh
+```
+
+### Access QEMU with SSH
+
+```
+cd <PNMSimulator_path>/scripts_real_app_mode
+bash ssh_qemu.sh
+```
+
+Change `HOST_IP` and `USER`.
+
+### Install Packages on QEMU
+
+```
+sudo apt update
+sudo apt upgrade
+sudo apt install build-essential
+```
+
+## Prerequisites for PNM
+
+Run the following commands on QEMU.
+
+```
+# PNM library dependencies
+$ sudo apt install ndctl libndctl-dev daxctl libdaxctl-dev numactl
+ 
+# Linux kernel build dependencies
+$ sudo apt install fakeroot ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison rsync kmod cpio dpkg-dev ccache
+ 
+# Pytorch build dependencies
+$ sudo apt install python3-pip libopenblas-dev
+ 
+# Pytorch python dependencies
+$ pip3 install -U protobuf==3.13 future yappi numpy==1.23.5 pydot typing_extensions ninja onnx scikit-learn tqdm tensorboard
+```
+
+## PNM Linux
+
+Install PNM Linux kernel on QEMU.
+
+```
+cd <PNMlinux_path>
+rm -f .config; cp -v config-pnm .config
+rm -fr debian/ vmlinux-gdb.py
+make -j `getconf _NPROCESSORS_ONLN` bindeb-pkg
+```
+
+```
+...
+*
+* Restart config...
+*
+*
+* DAX: direct access to differentiated memory
+*
+DAX: direct access to differentiated memory (DAX) [Y/?] y
+  Device DAX: direct access mapping device (DEV_DAX) [M/n/y/?] m
+    PMEM DAX: direct access to persistent memory (DEV_DAX_PMEM) [M/n/?] m
+  HMEM DAX: direct access to 'specific purpose' memory (DEV_DAX_HMEM) [M/n/y/?] m
+  DEV_SLS support (DEV_SLS) [Y/n/?] y
+  KMEM DAX: volatile-use of persistent memory (DEV_DAX_KMEM) [M/n/?] m
+  A base address of SLS range (DEV_SLS_BASE_ADDR) [4] (NEW) 4
+  A scale of SLS memory range (DEV_SLS_MEMORY_SCALE) [1] (NEW) 0
+  Choose PNM SLS type
+  > 1. AXDIMM (DEV_SLS_AXDIMM) (NEW)
+    2. CXL (DEV_SLS_CXL) (NEW)
+  choice[1-2?]: 2
+*
+* Device Drivers
+*
+Parallel port LCD/Keypad Panel support (OLD OPTION) (PANEL) [M/n/?] m
+Data acquisition support (comedi) (COMEDI) [M/n/y/?] m
+  Comedi debugging (COMEDI_DEBUG) [N/y/?] n
+  Comedi default initial asynchronous buffer size in KiB (COMEDI_DEFAULT_BUF_SIZE_KB) [2048] 2048
+  Comedi default maximum asynchronous buffer size in KiB (COMEDI_DEFAULT_BUF_MAXSIZE_KB) [20480] 20480
+  Standalone 8255 support (COMEDI_8255_SA) [M/n/?] m
+  Comedi kcomedilib (COMEDI_KCOMEDILIB) [M/?] m
+  Comedi unit tests (COMEDI_TESTS) [N/m/?] n
+Primary to Sideband (P2SB) bridge access support (P2SB) [Y/?] y
+Database Accelerator (IMDB) [Y/n/?] y
+SLS Resource Manager (SLS_RESOURCE) [M/n/y/?] m
+CXL-zSwap Devices Support (PNM_ZSWAP) [N/y/?] (NEW) N
+*
+* IMDB Resource Manager
+*
+IMDB Resource Manager (IMDB_RESOURCE) [M/n/y/?] m
+  A scale of IMDB memory range (IMDB_MEMORY_SCALE) [0] (NEW) 0
+...
+```
+
+```
+./install_debs.sh
+sudo reboot
+```
+
+```
+sudo vi /etc/default/grub
+====
+GRUB_CMDLINE_LINUX="memmap=64G!4G"
+====
+ 
+sudo update-grub
+sudo reboot
+```
+
+## PNM Library
+
+Install PNM library on QEMU.
+
+```
+sudo apt install clang cmake ninja-build
+```
+
+```
+cd <PNMLibrary_path>
+./scripts/build.sh -r -cb --psim -j 32
+```
+
+``` 
+sudo modprobe sls_resource device=CXL
+sudo ./build/tools/pnm_ctl setup-dax
+```
+
+## PNM PyTorch
+
+Install PNM PyTorch on QEMU.
+
+```
+cd <PNMpytorch_path>
+git submodule init
+git submodule update --init --recursive
+rm -fr build
+CMAKE_C_COMPILER_LAUNCHER=ccache CMAKE_CXX_COMPILER_LAUNCHER=ccache CFLAGS="-g -fno-omit-frame-pointer" BLAS=OpenBLAS BUILD_TEST=0 BUILD_CAFFE2=1 USE_CUDA=0 USE_PNM=1 PNM_INSTALL_DIR=<PNMLibrary_path>/build/ python3 ./setup.py install --user
+```
+
+## PNM DLRM
+
+Run DLRM on QEMU.
+
+### Install Python Packages
+
+```
+pip3 install -U sympy filelock networkx
+```
+
+### Generate Tables
+
+```
+cd <PNMLibrary_path>/build/tools
+export PATH=$PATH:`pwd`
+cd ../../
+./scripts/create_test_dataset.sh --dlrm --root test_tables/
+```
+
+### Run
+
+```
+sudo modprobe sls_resource device=CXL
+sudo <PNMLibrary_path>/build/tools/pnm_ctl setup-dax
+```
+
+#### Console #1 (QEMU Guest)
+
+```
+export GLIBC_TUNABLES=glibc.cpu.hwcaps=-AVX2_Usable,-AVX_Fast_Unaligned_Load # to make memcpy trace stable
+./run_test.sh --weights-path <path_to_table>/DLRM_FLOAT/embedded.bin --use-pnm simple --sls_device_interface CXL --num_batches 1 --user-triggers-inference
+... wait until DLRM prompts "Waiting for users trigger, please press Enter to start inference..."
+... enable tracing in Console #2
+... press "Enter"
+```
+
+#### Console #2 (Host)
+
+```
+sudo socat - unix-connect:qemu-monitor-sock
+(qemu) pnm-trace-file set pnm_trace-1.txt
+... wait until DLRM prompts "Waiting for users trigger, please press Enter to start inference..." in Console #1
+(qemu) pnm-trace-file on
+pnm-trace-file on
+        [PNM] trace_start
+... wait until DLRM completes execution
+(qemu) pnm-trace-file off
+pnm-trace-file off
+        [PNM] trace_end (pnm_trace-1.txt file is generated!)
+```
+
+## Trace Converter
+
+```
+cd <PNMSimulator_path>/scripts_real_app_mode
+python3 trace_conv.py pnm_trace-1.txt > converted.trc
+```
+
+## Run with Real Application Trace
+
+```
+cd <PNMSimulator_path>/scripts_real_app_mode
+bash run_pnm_sim_real_app_mode.sh
+```
diff --git a/configs/real_app_mode.ini b/configs/real_app_mode.ini
new file mode 100644
index 0000000..b9b16b9
--- /dev/null
+++ b/configs/real_app_mode.ini
@@ -0,0 +1,67 @@
+[dram_structure]
+protocol = DDR4
+bankgroups = 4
+banks_per_group = 4
+rows = 131072
+columns = 1024
+device_width = 16
+BL = 8
+
+[timing]
+tCK = 0.63
+AL = 0
+CL = 22
+CWL = 16
+tRCD = 22
+tRP = 22
+tRAS = 52
+tRFC = 560
+tRFC2 = 416
+tRFC4 = 256
+tREFI = 12480
+tRPRE = 1
+tWPRE = 1
+tRRD_S = 9
+tRRD_L = 11
+tWTR_S = 4
+tWTR_L = 12
+tFAW = 48
+tWR = 24
+tWR2 = 25
+tRTP = 12
+tCCD_S = 4
+tCCD_L = 8
+tCKE = 8
+tCKESR = 9
+tXS = 576
+tXP = 10
+tRTRS = 1
+
+[power]
+VDD = 1.2
+IDD0 = 95
+IPP0 = 4.0
+IDD2P = 25
+IDD2N = 37
+IDD3P = 47
+IDD3N = 56
+IDD4W = 278
+IDD4R = 302
+IDD5AB = 280
+IDD6x = 30
+
+[system]
+channel_size = 32768
+channels = 2
+bus_width = 64
+address_mapping = rochrababgco
+queue_structure = PER_BANK
+refresh_policy = RANK_LEVEL_STAGGERED
+row_buf_policy = OPEN_PAGE
+cmd_queue_size = 8
+trans_queue_size = 32
+
+[other]
+epoch_period = 1587301
+output_level = 1
+
diff --git a/ext/SuperLU_MT_3.1 b/ext/SuperLU_MT_3.1
deleted file mode 160000
index 68739c5..0000000
--- a/ext/SuperLU_MT_3.1
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 68739c5a23cc48c9a13d28793834e4fee95d33ee
diff --git a/.clang-format b/pnm_sim/.clang-format
similarity index 100%
rename from .clang-format
rename to pnm_sim/.clang-format
diff --git a/.travis.yml b/pnm_sim/.travis.yml
similarity index 100%
rename from .travis.yml
rename to pnm_sim/.travis.yml
diff --git a/CMakeLists.txt b/pnm_sim/CMakeLists.txt
similarity index 71%
rename from CMakeLists.txt
rename to pnm_sim/CMakeLists.txt
index eaa40bf..3a55260 100644
--- a/CMakeLists.txt
+++ b/pnm_sim/CMakeLists.txt
@@ -1,5 +1,5 @@
 cmake_minimum_required(VERSION 3.0.0)
-project(dramsim3)
+project(pnm_sim)
 
 set(default_build_type "Release")
 if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
@@ -26,13 +26,15 @@ add_library(json INTERFACE)
 target_include_directories(json INTERFACE ext/headers)
 
 # Main DRAMSim Lib
-add_library(dramsim3 SHARED
+add_library(pnm_sim SHARED
     src/bankstate.cc
     src/channel_state.cc
     src/command_queue.cc
     src/common.cc
     src/configuration.cc
     src/controller.cc
+    src/pnm.cc
+    src/address_decoder.cc
     src/dram_system.cc
     src/hmc.cc
     src/refresh.cc
@@ -54,43 +56,43 @@ if (THERMAL)
         HINTS ${PROJECT_SOURCE_DIR}/ext/SuperLU_MT_3.1/lib/
     )
 
-    target_link_libraries(dramsim3
+    target_link_libraries(pnm_sim
         PRIVATE ${SUPERLU} f77blas atlas m ${OpenMP_C_FLAGS}
     )
-    target_sources(dramsim3
+    target_sources(pnm_sim
         PRIVATE src/thermal.cc src/sp_ienv.c src/thermal_solver.c
     )
-    target_compile_options(dramsim3 PRIVATE -DTHERMAL -D_LONGINT -DAdd_ ${OpenMP_C_FLAGS})
+    target_compile_options(pnm_sim PRIVATE -DTHERMAL -D_LONGINT -DAdd_ ${OpenMP_C_FLAGS})
 
     add_executable(thermalreplay src/thermal_replay.cc)
-    target_link_libraries(thermalreplay dramsim3 inih)
+    target_link_libraries(thermalreplay pnm_sim inih)
     target_compile_options(thermalreplay PRIVATE -DTHERMAL -D_LONGINT -DAdd_ ${OpenMP_C_FLAGS})
 endif (THERMAL)
 
 if (CMD_TRACE)
-    target_compile_options(dramsim3 PRIVATE -DCMD_TRACE)
+    target_compile_options(pnm_sim PRIVATE -DCMD_TRACE)
 endif (CMD_TRACE)
 
 if (ADDR_TRACE)
-    target_compile_options(dramsim3 PRIVATE -DADDR_TRACE)
+    target_compile_options(pnm_sim PRIVATE -DADDR_TRACE)
 endif (ADDR_TRACE)
 
 
-target_include_directories(dramsim3 INTERFACE src)
-target_compile_options(dramsim3 PRIVATE -Wall)
-target_link_libraries(dramsim3 PRIVATE inih format)
-set_target_properties(dramsim3 PROPERTIES
+target_include_directories(pnm_sim INTERFACE src)
+target_compile_options(pnm_sim PRIVATE -Wall)
+target_link_libraries(pnm_sim PRIVATE inih format)
+set_target_properties(pnm_sim PROPERTIES
     LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}
     CXX_STANDARD 11
     CXX_STANDARD_REQUIRED YES
     CXX_EXTENSIONS NO
 )
 
-# trace CPU, .etc
-add_executable(dramsim3main src/main.cc src/cpu.cc)
-target_link_libraries(dramsim3main PRIVATE dramsim3 args)
-target_compile_options(dramsim3main PRIVATE)
-set_target_properties(dramsim3main PROPERTIES
+# trace CXL, .etc
+add_executable(pnmsim src/main.cc src/cxl.cc)
+target_link_libraries(pnmsim PRIVATE pnm_sim args)
+target_compile_options(pnmsim PRIVATE)
+set_target_properties(pnmsim PROPERTIES
     CXX_STANDARD 11
     CXX_STANDARD_REQUIRED YES
     CXX_EXTENSIONS NO
@@ -100,20 +102,20 @@ set_target_properties(dramsim3main PROPERTIES
 add_library(Catch INTERFACE)
 target_include_directories(Catch INTERFACE ext/headers)
 
-add_executable(dramsim3test EXCLUDE_FROM_ALL
+add_executable(pnm_simtest EXCLUDE_FROM_ALL
     tests/test_config.cc
     tests/test_dramsys.cc
     tests/test_hmcsys.cc # IDK somehow this can literally crush your computer
 )
-target_link_libraries(dramsim3test Catch dramsim3)
-target_include_directories(dramsim3test PRIVATE src/)
+target_link_libraries(pnm_simtest Catch pnm_sim)
+target_include_directories(pnm_simtest PRIVATE src/)
 
 # We have to use this custome command because there's a bug in cmake
 # that if you do `make test` it doesn't build your updated test files
-# so we're stucking with `make dramsim3test` for now
+# so we're stucking with `make pnm_simtest` for now
 add_custom_command(
-    TARGET dramsim3test POST_BUILD
-    COMMAND dramsim3test
+    TARGET pnm_simtest POST_BUILD
+    COMMAND pnm_simtest
     WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
-    DEPENDS dramsim3test dramsim3
+    DEPENDS pnm_simtest pnm_sim
 )
diff --git a/LICENSE b/pnm_sim/LICENSE
similarity index 100%
rename from LICENSE
rename to pnm_sim/LICENSE
diff --git a/Makefile b/pnm_sim/Makefile
similarity index 100%
rename from Makefile
rename to pnm_sim/Makefile
diff --git a/pnm_sim/README_DRAMsim3.md b/pnm_sim/README_DRAMsim3.md
new file mode 100644
index 0000000..d47707f
--- /dev/null
+++ b/pnm_sim/README_DRAMsim3.md
@@ -0,0 +1,158 @@
+[![Build Status](https://travis-ci.com/umd-memsys/DRAMsim3.svg?branch=master)](https://travis-ci.com/umd-memsys/DRAMsim3)
+
+# About DRAMsim3
+
+DRAMsim3 models the timing paramaters and memory controller behavior for several DRAM protocols such as DDR3, DDR4, LPDDR3, LPDDR4, GDDR5, GDDR6, HBM, HMC, STT-MRAM. It is implemented in C++ as an objected oriented model that includes a parameterized DRAM bank model, DRAM controllers, command queues and system-level interfaces to interact with a CPU simulator (GEM5, ZSim) or trace workloads. It is designed to be accurate, portable and parallel.
+    
+If you use this simulator in your work, please consider cite:
+
+[1] S. Li, Z. Yang, D. Reddy, A. Srivastava and B. Jacob, "DRAMsim3: a Cycle-accurate, Thermal-Capable DRAM Simulator," in IEEE Computer Architecture Letters. [Link](https://ieeexplore.ieee.org/document/8999595)
+
+See [Related Work](#related-work) for more work done with this simulator.
+
+
+## Building and running the simulator
+
+This simulator by default uses a CMake based build system.
+The advantage in using a CMake based build system is portability and dependency management.
+We require CMake 3.0+ to build this simulator.
+If `cmake-3.0` is not available,
+we also supply a Makefile to build the most basic version of the simulator.
+
+### Building
+
+Doing out of source builds with CMake is recommended to avoid the build files cluttering the main directory.
+
+```bash
+# cmake out of source build
+mkdir build
+cd build
+cmake ..
+
+# Build dramsim3 library and executables
+make -j4
+
+# Alternatively, build with thermal module enabled
+cmake .. -DTHERMAL=1
+
+```
+
+The build process creates `dramsim3main` and executables in the `build` directory.
+By default, it also creates `libdramsim3.so` shared library in the project root directory.
+
+### Running
+
+```bash
+# help
+./build/dramsim3main -h
+
+# Running random stream with a config file
+./build/dramsim3main configs/DDR4_8Gb_x8_3200.ini --stream random -c 100000 
+
+# Running a trace file
+./build/dramsim3main configs/DDR4_8Gb_x8_3200.ini -c 100000 -t sample_trace.txt
+
+# Running with gem5
+--mem-type=dramsim3 --dramsim3-ini=configs/DDR4_4Gb_x4_2133.ini
+
+```
+
+The output can be directed to another directory by `-o` option
+or can be configured in the config file.
+You can control the verbosity in the config file as well.
+
+### Output Visualization
+
+`scripts/plot_stats.py` can visualize some of the output (requires `matplotlib`):
+
+```bash
+# generate histograms from overall output
+python3 scripts/plot_stats dramsim3.json
+
+# or
+# generate time series for a variety stats from epoch outputs
+python3 scripts/plot_stats dramsim3epoch.json
+```
+
+Currently stats from all channels are squashed together for cleaner plotting.
+
+### Integration with other simulators
+
+**Gem5** integration: works with a forked Gem5 version, see https://github.com/umd-memsys/gem5 at `dramsim3` branch for reference.
+
+**SST** integration: see http://git.ece.umd.edu/shangli/sst-elements/tree/dramsim3 for reference. We will try to merge to official SST repo.
+
+**ZSim** integration: see http://git.ece.umd.edu/shangli/zsim/tree/master for reference.
+
+## Simulator Design
+
+### Code Structure
+
+```
+├── configs                 # Configs of various protocols that describe timing constraints and power consumption.
+├── ext                     # 
+├── scripts                 # Tools and utilities
+├── src                     # DRAMsim3 source files
+├── tests                   # Tests of each model, includes a short example trace
+├── CMakeLists.txt
+├── Makefile
+├── LICENSE
+└── README.md
+
+├── src  
+    bankstate.cc: Records and manages DRAM bank timings and states which is modeled as a state machine.
+    channelstate.cc: Records and manages channel timings and states.
+    command_queue.cc: Maintains per-bank or per-rank FIFO queueing structures, determine which commands in the queues can be issued in this cycle.
+    configuration.cc: Initiates, manages system and DRAM parameters, including protocol, DRAM timings, address mapping policy and power parameters.
+    controller.cc: Maintains the per-channel controller, which manages a queue of pending memory transactions and issues corresponding DRAM commands, 
+                   follows FR-FCFS policy.
+    cpu.cc: Implements 3 types of simple CPU: 
+            1. Random, can handle random CPU requests at full speed, the entire parallelism of DRAM protocol can be exploited without limits from address mapping and scheduling pocilies. 
+            2. Stream, provides a streaming prototype that is able to provide enough buffer hits.
+            3. Trace-based, consumes traces of workloads, feed the fetched transactions into the memory system.
+    dram_system.cc:  Initiates JEDEC or ideal DRAM system, registers the supplied callback function to let the front end driver know that the request is finished. 
+    hmc.cc: Implements HMC system and interface, HMC requests are translates to DRAM requests here and a crossbar interconnect between the high-speed links and the memory controllers is modeled.
+    main.cc: Handles the main program loop that reads in simulation arguments, DRAM configurations and tick cycle forward.
+    memory_system.cc: A wrapper of dram_system and hmc.
+    refresh.cc: Raises refresh request based on per-rank refresh or per-bank refresh.
+    timing.cc: Initiate timing constraints.
+```
+
+## Experiments
+
+### Verilog Validation
+
+First we generate a DRAM command trace.
+There is a `CMD_TRACE` macro and by default it's disabled.
+Use `cmake .. -DCMD_TRACE=1` to enable the command trace output build and then
+whenever a simulation is performed the command trace file will be generated.
+
+Next, `scripts/validation.py` helps generate a Verilog workbench for Micron's Verilog model
+from the command trace file.
+Currently DDR3, DDR4, and LPDDR configs are supported by this script.
+
+Run
+
+```bash
+./script/validataion.py DDR4.ini cmd.trace
+```
+
+To generage Verilog workbench.
+Our workbench format is compatible with ModelSim Verilog simulator,
+other Verilog simulators may require a slightly different format.
+
+
+## Related Work
+
+[1] Li, S., Yang, Z., Reddy D., Srivastava, A. and Jacob, B., (2020) DRAMsim3: a Cycle-accurate, Thermal-Capable DRAM Simulator, IEEE Computer Architecture Letters.
+
+[2] Jagasivamani, M., Walden, C., Singh, D., Kang, L., Li, S., Asnaashari, M., ... & Yeung, D. (2019). Analyzing the Monolithic Integration of a ReRAM-Based Main Memory Into a CPU's Die. IEEE Micro, 39(6), 64-72.
+
+[3] Li, S., Reddy, D., & Jacob, B. (2018, October). A performance & power comparison of modern high-speed DRAM architectures. In Proceedings of the International Symposium on Memory Systems (pp. 341-353).
+
+[4] Li, S., Verdejo, R. S., Radojković, P., & Jacob, B. (2019, September). Rethinking cycle accurate DRAM simulation. In Proceedings of the International Symposium on Memory Systems (pp. 184-191).
+
+[5] Li, S., & Jacob, B. (2019, September). Statistical DRAM modeling. In Proceedings of the International Symposium on Memory Systems (pp. 521-530).
+
+[6] Li, S. (2019). Scalable and Accurate Memory System Simulation (Doctoral dissertation).
+
diff --git a/configs/DDR3_1Gb_x8_1333.ini b/pnm_sim/configs/DDR3_1Gb_x8_1333.ini
similarity index 100%
rename from configs/DDR3_1Gb_x8_1333.ini
rename to pnm_sim/configs/DDR3_1Gb_x8_1333.ini
diff --git a/configs/DDR3_4Gb_x16_1600.ini b/pnm_sim/configs/DDR3_4Gb_x16_1600.ini
similarity index 100%
rename from configs/DDR3_4Gb_x16_1600.ini
rename to pnm_sim/configs/DDR3_4Gb_x16_1600.ini
diff --git a/configs/DDR3_4Gb_x16_1866.ini b/pnm_sim/configs/DDR3_4Gb_x16_1866.ini
similarity index 100%
rename from configs/DDR3_4Gb_x16_1866.ini
rename to pnm_sim/configs/DDR3_4Gb_x16_1866.ini
diff --git a/configs/DDR3_4Gb_x4_1600.ini b/pnm_sim/configs/DDR3_4Gb_x4_1600.ini
similarity index 100%
rename from configs/DDR3_4Gb_x4_1600.ini
rename to pnm_sim/configs/DDR3_4Gb_x4_1600.ini
diff --git a/configs/DDR3_4Gb_x4_1866.ini b/pnm_sim/configs/DDR3_4Gb_x4_1866.ini
similarity index 100%
rename from configs/DDR3_4Gb_x4_1866.ini
rename to pnm_sim/configs/DDR3_4Gb_x4_1866.ini
diff --git a/configs/DDR3_4Gb_x8_1600.ini b/pnm_sim/configs/DDR3_4Gb_x8_1600.ini
similarity index 100%
rename from configs/DDR3_4Gb_x8_1600.ini
rename to pnm_sim/configs/DDR3_4Gb_x8_1600.ini
diff --git a/configs/DDR3_4Gb_x8_1866.ini b/pnm_sim/configs/DDR3_4Gb_x8_1866.ini
similarity index 100%
rename from configs/DDR3_4Gb_x8_1866.ini
rename to pnm_sim/configs/DDR3_4Gb_x8_1866.ini
diff --git a/configs/DDR3_8Gb_x16_1600.ini b/pnm_sim/configs/DDR3_8Gb_x16_1600.ini
similarity index 100%
rename from configs/DDR3_8Gb_x16_1600.ini
rename to pnm_sim/configs/DDR3_8Gb_x16_1600.ini
diff --git a/configs/DDR3_8Gb_x16_1866.ini b/pnm_sim/configs/DDR3_8Gb_x16_1866.ini
similarity index 100%
rename from configs/DDR3_8Gb_x16_1866.ini
rename to pnm_sim/configs/DDR3_8Gb_x16_1866.ini
diff --git a/configs/DDR3_8Gb_x4_1600.ini b/pnm_sim/configs/DDR3_8Gb_x4_1600.ini
similarity index 100%
rename from configs/DDR3_8Gb_x4_1600.ini
rename to pnm_sim/configs/DDR3_8Gb_x4_1600.ini
diff --git a/configs/DDR3_8Gb_x4_1866.ini b/pnm_sim/configs/DDR3_8Gb_x4_1866.ini
similarity index 100%
rename from configs/DDR3_8Gb_x4_1866.ini
rename to pnm_sim/configs/DDR3_8Gb_x4_1866.ini
diff --git a/configs/DDR3_8Gb_x8_1600.ini b/pnm_sim/configs/DDR3_8Gb_x8_1600.ini
similarity index 100%
rename from configs/DDR3_8Gb_x8_1600.ini
rename to pnm_sim/configs/DDR3_8Gb_x8_1600.ini
diff --git a/configs/DDR3_8Gb_x8_1866.ini b/pnm_sim/configs/DDR3_8Gb_x8_1866.ini
similarity index 100%
rename from configs/DDR3_8Gb_x8_1866.ini
rename to pnm_sim/configs/DDR3_8Gb_x8_1866.ini
diff --git a/configs/DDR4_4Gb_x16_1866.ini b/pnm_sim/configs/DDR4_4Gb_x16_1866.ini
similarity index 100%
rename from configs/DDR4_4Gb_x16_1866.ini
rename to pnm_sim/configs/DDR4_4Gb_x16_1866.ini
diff --git a/configs/DDR4_4Gb_x16_2133.ini b/pnm_sim/configs/DDR4_4Gb_x16_2133.ini
similarity index 100%
rename from configs/DDR4_4Gb_x16_2133.ini
rename to pnm_sim/configs/DDR4_4Gb_x16_2133.ini
diff --git a/configs/DDR4_4Gb_x16_2133_2.ini b/pnm_sim/configs/DDR4_4Gb_x16_2133_2.ini
similarity index 100%
rename from configs/DDR4_4Gb_x16_2133_2.ini
rename to pnm_sim/configs/DDR4_4Gb_x16_2133_2.ini
diff --git a/configs/DDR4_4Gb_x16_2400.ini b/pnm_sim/configs/DDR4_4Gb_x16_2400.ini
similarity index 100%
rename from configs/DDR4_4Gb_x16_2400.ini
rename to pnm_sim/configs/DDR4_4Gb_x16_2400.ini
diff --git a/configs/DDR4_4Gb_x16_2400_2.ini b/pnm_sim/configs/DDR4_4Gb_x16_2400_2.ini
similarity index 100%
rename from configs/DDR4_4Gb_x16_2400_2.ini
rename to pnm_sim/configs/DDR4_4Gb_x16_2400_2.ini
diff --git a/configs/DDR4_4Gb_x16_2666.ini b/pnm_sim/configs/DDR4_4Gb_x16_2666.ini
similarity index 100%
rename from configs/DDR4_4Gb_x16_2666.ini
rename to pnm_sim/configs/DDR4_4Gb_x16_2666.ini
diff --git a/configs/DDR4_4Gb_x16_2666_2.ini b/pnm_sim/configs/DDR4_4Gb_x16_2666_2.ini
similarity index 100%
rename from configs/DDR4_4Gb_x16_2666_2.ini
rename to pnm_sim/configs/DDR4_4Gb_x16_2666_2.ini
diff --git a/configs/DDR4_4Gb_x4_1866.ini b/pnm_sim/configs/DDR4_4Gb_x4_1866.ini
similarity index 100%
rename from configs/DDR4_4Gb_x4_1866.ini
rename to pnm_sim/configs/DDR4_4Gb_x4_1866.ini
diff --git a/configs/DDR4_4Gb_x4_2133.ini b/pnm_sim/configs/DDR4_4Gb_x4_2133.ini
similarity index 100%
rename from configs/DDR4_4Gb_x4_2133.ini
rename to pnm_sim/configs/DDR4_4Gb_x4_2133.ini
diff --git a/configs/DDR4_4Gb_x4_2133_2.ini b/pnm_sim/configs/DDR4_4Gb_x4_2133_2.ini
similarity index 100%
rename from configs/DDR4_4Gb_x4_2133_2.ini
rename to pnm_sim/configs/DDR4_4Gb_x4_2133_2.ini
diff --git a/configs/DDR4_4Gb_x4_2400.ini b/pnm_sim/configs/DDR4_4Gb_x4_2400.ini
similarity index 100%
rename from configs/DDR4_4Gb_x4_2400.ini
rename to pnm_sim/configs/DDR4_4Gb_x4_2400.ini
diff --git a/configs/DDR4_4Gb_x4_2400_2.ini b/pnm_sim/configs/DDR4_4Gb_x4_2400_2.ini
similarity index 100%
rename from configs/DDR4_4Gb_x4_2400_2.ini
rename to pnm_sim/configs/DDR4_4Gb_x4_2400_2.ini
diff --git a/configs/DDR4_4Gb_x4_2666.ini b/pnm_sim/configs/DDR4_4Gb_x4_2666.ini
similarity index 100%
rename from configs/DDR4_4Gb_x4_2666.ini
rename to pnm_sim/configs/DDR4_4Gb_x4_2666.ini
diff --git a/configs/DDR4_4Gb_x4_2666_2.ini b/pnm_sim/configs/DDR4_4Gb_x4_2666_2.ini
similarity index 100%
rename from configs/DDR4_4Gb_x4_2666_2.ini
rename to pnm_sim/configs/DDR4_4Gb_x4_2666_2.ini
diff --git a/configs/DDR4_4Gb_x8_1866.ini b/pnm_sim/configs/DDR4_4Gb_x8_1866.ini
similarity index 100%
rename from configs/DDR4_4Gb_x8_1866.ini
rename to pnm_sim/configs/DDR4_4Gb_x8_1866.ini
diff --git a/configs/DDR4_4Gb_x8_2133.ini b/pnm_sim/configs/DDR4_4Gb_x8_2133.ini
similarity index 100%
rename from configs/DDR4_4Gb_x8_2133.ini
rename to pnm_sim/configs/DDR4_4Gb_x8_2133.ini
diff --git a/configs/DDR4_4Gb_x8_2133_2.ini b/pnm_sim/configs/DDR4_4Gb_x8_2133_2.ini
similarity index 100%
rename from configs/DDR4_4Gb_x8_2133_2.ini
rename to pnm_sim/configs/DDR4_4Gb_x8_2133_2.ini
diff --git a/configs/DDR4_4Gb_x8_2400.ini b/pnm_sim/configs/DDR4_4Gb_x8_2400.ini
similarity index 100%
rename from configs/DDR4_4Gb_x8_2400.ini
rename to pnm_sim/configs/DDR4_4Gb_x8_2400.ini
diff --git a/configs/DDR4_4Gb_x8_2400_2.ini b/pnm_sim/configs/DDR4_4Gb_x8_2400_2.ini
similarity index 100%
rename from configs/DDR4_4Gb_x8_2400_2.ini
rename to pnm_sim/configs/DDR4_4Gb_x8_2400_2.ini
diff --git a/configs/DDR4_4Gb_x8_2666.ini b/pnm_sim/configs/DDR4_4Gb_x8_2666.ini
similarity index 100%
rename from configs/DDR4_4Gb_x8_2666.ini
rename to pnm_sim/configs/DDR4_4Gb_x8_2666.ini
diff --git a/configs/DDR4_4Gb_x8_2666_2.ini b/pnm_sim/configs/DDR4_4Gb_x8_2666_2.ini
similarity index 100%
rename from configs/DDR4_4Gb_x8_2666_2.ini
rename to pnm_sim/configs/DDR4_4Gb_x8_2666_2.ini
diff --git a/pnm_sim/configs/DDR4_8Gb_x16_1866.ini b/pnm_sim/configs/DDR4_8Gb_x16_1866.ini
new file mode 100644
index 0000000..adb923b
--- /dev/null
+++ b/pnm_sim/configs/DDR4_8Gb_x16_1866.ini
@@ -0,0 +1,67 @@
+[dram_structure]
+protocol = DDR4
+bankgroups = 2
+banks_per_group = 4
+rows = 65536
+columns = 1024
+device_width = 16
+BL = 8
+
+[timing]
+tCK = 1.07
+AL = 0
+CL = 13
+CWL = 10
+tRCD = 13
+tRP = 13
+tRAS = 32
+tRFC = 327
+tRFC2 = 243
+tRFC4 = 150
+tREFI = 7285
+tRPRE = 1
+tWPRE = 1
+tRRD_S = 5
+tRRD_L = 6
+tWTR_S = 3
+tWTR_L = 7
+tFAW = 28
+tWR = 14
+tWR2 = 15
+tRTP = 7
+tCCD_S = 4
+tCCD_L = 5
+tCKE = 5
+tCKESR = 6
+tXS = 337
+tXP = 6
+tRTRS = 1
+
+[power]
+VDD = 1.2
+IDD0 = 75
+IPP0 = 4.0
+IDD2P = 25
+IDD2N = 33
+IDD3P = 39
+IDD3N = 44
+IDD4W = 225
+IDD4R = 225
+IDD5AB = 280
+IDD6x = 30
+
+[system]
+channel_size = 8192
+channels = 1
+bus_width = 64
+address_mapping = rochrababgco
+queue_structure = PER_BANK
+refresh_policy = RANK_LEVEL_STAGGERED
+row_buf_policy = OPEN_PAGE
+cmd_queue_size = 8
+trans_queue_size = 32
+
+[other]
+epoch_period = 934579
+output_level = 1
+
diff --git a/pnm_sim/configs/DDR4_8Gb_x16_2133.ini b/pnm_sim/configs/DDR4_8Gb_x16_2133.ini
new file mode 100644
index 0000000..23842bf
--- /dev/null
+++ b/pnm_sim/configs/DDR4_8Gb_x16_2133.ini
@@ -0,0 +1,67 @@
+[dram_structure]
+protocol = DDR4
+bankgroups = 2
+banks_per_group = 4
+rows = 65536
+columns = 1024
+device_width = 16
+BL = 8
+
+[timing]
+tCK = 0.94
+AL = 0
+CL = 16
+CWL = 11
+tRCD = 16
+tRP = 16
+tRAS = 36
+tRFC = 374
+tRFC2 = 278
+tRFC4 = 171
+tREFI = 8328
+tRPRE = 1
+tWPRE = 1
+tRRD_S = 6
+tRRD_L = 7
+tWTR_S = 3
+tWTR_L = 8
+tFAW = 32
+tWR = 16
+tWR2 = 17
+tRTP = 8
+tCCD_S = 4
+tCCD_L = 6
+tCKE = 6
+tCKESR = 7
+tXS = 385
+tXP = 7
+tRTRS = 1
+
+[power]
+VDD = 1.2
+IDD0 = 75
+IPP0 = 4.0
+IDD2P = 25
+IDD2N = 33
+IDD3P = 39
+IDD3N = 44
+IDD4W = 225
+IDD4R = 225
+IDD5AB = 280
+IDD6x = 30
+
+[system]
+channel_size = 8192
+channels = 1
+bus_width = 64
+address_mapping = rochrababgco
+queue_structure = PER_BANK
+refresh_policy = RANK_LEVEL_STAGGERED
+row_buf_policy = OPEN_PAGE
+cmd_queue_size = 8
+trans_queue_size = 32
+
+[other]
+epoch_period = 1063829
+output_level = 1
+
diff --git a/pnm_sim/configs/DDR4_8Gb_x16_2133_2.ini b/pnm_sim/configs/DDR4_8Gb_x16_2133_2.ini
new file mode 100644
index 0000000..586662e
--- /dev/null
+++ b/pnm_sim/configs/DDR4_8Gb_x16_2133_2.ini
@@ -0,0 +1,67 @@
+[dram_structure]
+protocol = DDR4
+bankgroups = 2
+banks_per_group = 4
+rows = 65536
+columns = 1024
+device_width = 16
+BL = 8
+
+[timing]
+tCK = 0.94
+AL = 0
+CL = 15
+CWL = 11
+tRCD = 15
+tRP = 15
+tRAS = 36
+tRFC = 374
+tRFC2 = 278
+tRFC4 = 171
+tREFI = 8328
+tRPRE = 1
+tWPRE = 1
+tRRD_S = 6
+tRRD_L = 7
+tWTR_S = 3
+tWTR_L = 8
+tFAW = 32
+tWR = 16
+tWR2 = 17
+tRTP = 8
+tCCD_S = 4
+tCCD_L = 6
+tCKE = 6
+tCKESR = 7
+tXS = 385
+tXP = 7
+tRTRS = 1
+
+[power]
+VDD = 1.2
+IDD0 = 75
+IPP0 = 4.0
+IDD2P = 25
+IDD2N = 33
+IDD3P = 39
+IDD3N = 44
+IDD4W = 225
+IDD4R = 225
+IDD5AB = 280
+IDD6x = 30
+
+[system]
+channel_size = 8192
+channels = 1
+bus_width = 64
+address_mapping = rochrababgco
+queue_structure = PER_BANK
+refresh_policy = RANK_LEVEL_STAGGERED
+row_buf_policy = OPEN_PAGE
+cmd_queue_size = 8
+trans_queue_size = 32
+
+[other]
+epoch_period = 1063829
+output_level = 1
+
diff --git a/pnm_sim/configs/DDR4_8Gb_x16_2400.ini b/pnm_sim/configs/DDR4_8Gb_x16_2400.ini
new file mode 100644
index 0000000..eaa521d
--- /dev/null
+++ b/pnm_sim/configs/DDR4_8Gb_x16_2400.ini
@@ -0,0 +1,67 @@
+[dram_structure]
+protocol = DDR4
+bankgroups = 2
+banks_per_group = 4
+rows = 65536
+columns = 1024
+device_width = 16
+BL = 8
+
+[timing]
+tCK = 0.83
+AL = 0
+CL = 17
+CWL = 12
+tRCD = 17
+tRP = 17
+tRAS = 39
+tRFC = 420
+tRFC2 = 312
+tRFC4 = 192
+tREFI = 9360
+tRPRE = 1
+tWPRE = 1
+tRRD_S = 7
+tRRD_L = 8
+tWTR_S = 3
+tWTR_L = 9
+tFAW = 36
+tWR = 18
+tWR2 = 19
+tRTP = 9
+tCCD_S = 4
+tCCD_L = 6
+tCKE = 6
+tCKESR = 7
+tXS = 432
+tXP = 8
+tRTRS = 1
+
+[power]
+VDD = 1.2
+IDD0 = 80
+IPP0 = 4.0
+IDD2P = 25
+IDD2N = 34
+IDD3P = 41
+IDD3N = 47
+IDD4W = 228
+IDD4R = 243
+IDD5AB = 280
+IDD6x = 30
+
+[system]
+channel_size = 8192
+channels = 1
+bus_width = 64
+address_mapping = rochrababgco
+queue_structure = PER_BANK
+refresh_policy = RANK_LEVEL_STAGGERED
+row_buf_policy = OPEN_PAGE
+cmd_queue_size = 8
+trans_queue_size = 32
+
+[other]
+epoch_period = 1204819
+output_level = 1
+
diff --git a/pnm_sim/configs/DDR4_8Gb_x16_2400_2.ini b/pnm_sim/configs/DDR4_8Gb_x16_2400_2.ini
new file mode 100644
index 0000000..4d9ae93
--- /dev/null
+++ b/pnm_sim/configs/DDR4_8Gb_x16_2400_2.ini
@@ -0,0 +1,67 @@
+[dram_structure]
+protocol = DDR4
+bankgroups = 2
+banks_per_group = 4
+rows = 65536
+columns = 1024
+device_width = 16
+BL = 8
+
+[timing]
+tCK = 0.83
+AL = 0
+CL = 16
+CWL = 12
+tRCD = 16
+tRP = 16
+tRAS = 39
+tRFC = 420
+tRFC2 = 312
+tRFC4 = 192
+tREFI = 9360
+tRPRE = 1
+tWPRE = 1
+tRRD_S = 7
+tRRD_L = 8
+tWTR_S = 3
+tWTR_L = 9
+tFAW = 36
+tWR = 18
+tWR2 = 19
+tRTP = 9
+tCCD_S = 4
+tCCD_L = 6
+tCKE = 6
+tCKESR = 7
+tXS = 432
+tXP = 8
+tRTRS = 1
+
+[power]
+VDD = 1.2
+IDD0 = 80
+IPP0 = 4.0
+IDD2P = 25
+IDD2N = 34
+IDD3P = 41
+IDD3N = 47
+IDD4W = 228
+IDD4R = 243
+IDD5AB = 280
+IDD6x = 30
+
+[system]
+channel_size = 8192
+channels = 1
+bus_width = 64
+address_mapping = rochrababgco
+queue_structure = PER_BANK
+refresh_policy = RANK_LEVEL_STAGGERED
+row_buf_policy = OPEN_PAGE
+cmd_queue_size = 8
+trans_queue_size = 32
+
+[other]
+epoch_period = 1204819
+output_level = 1
+
diff --git a/pnm_sim/configs/DDR4_8Gb_x16_2666.ini b/pnm_sim/configs/DDR4_8Gb_x16_2666.ini
new file mode 100644
index 0000000..21b8a91
--- /dev/null
+++ b/pnm_sim/configs/DDR4_8Gb_x16_2666.ini
@@ -0,0 +1,67 @@
+[dram_structure]
+protocol = DDR4
+bankgroups = 2
+banks_per_group = 4
+rows = 65536
+columns = 1024
+device_width = 16
+BL = 8
+
+[timing]
+tCK = 0.75
+AL = 0
+CL = 19
+CWL = 14
+tRCD = 19
+tRP = 19
+tRAS = 43
+tRFC = 467
+tRFC2 = 347
+tRFC4 = 214
+tREFI = 10398
+tRPRE = 1
+tWPRE = 1
+tRRD_S = 7
+tRRD_L = 9
+tWTR_S = 4
+tWTR_L = 10
+tFAW = 40
+tWR = 20
+tWR2 = 21
+tRTP = 10
+tCCD_S = 4
+tCCD_L = 7
+tCKE = 7
+tCKESR = 8
+tXS = 480
+tXP = 8
+tRTRS = 1
+
+[power]
+VDD = 1.2
+IDD0 = 85
+IPP0 = 4.0
+IDD2P = 25
+IDD2N = 35
+IDD3P = 43
+IDD3N = 50
+IDD4W = 244
+IDD4R = 263
+IDD5AB = 280
+IDD6x = 30
+
+[system]
+channel_size = 8192
+channels = 1
+bus_width = 64
+address_mapping = rochrababgco
+queue_structure = PER_BANK
+refresh_policy = RANK_LEVEL_STAGGERED
+row_buf_policy = OPEN_PAGE
+cmd_queue_size = 8
+trans_queue_size = 32
+
+[other]
+epoch_period = 1333333
+output_level = 1
+
diff --git a/pnm_sim/configs/DDR4_8Gb_x16_2666_2.ini b/pnm_sim/configs/DDR4_8Gb_x16_2666_2.ini
new file mode 100644
index 0000000..4043984
--- /dev/null
+++ b/pnm_sim/configs/DDR4_8Gb_x16_2666_2.ini
@@ -0,0 +1,67 @@
+[dram_structure]
+protocol = DDR4
+bankgroups = 2
+banks_per_group = 4
+rows = 65536
+columns = 1024
+device_width = 16
+BL = 8
+
+[timing]
+tCK = 0.75
+AL = 0
+CL = 18
+CWL = 14
+tRCD = 18
+tRP = 18
+tRAS = 43
+tRFC = 467
+tRFC2 = 347
+tRFC4 = 214
+tREFI = 10398
+tRPRE = 1
+tWPRE = 1
+tRRD_S = 7
+tRRD_L = 9
+tWTR_S = 4
+tWTR_L = 10
+tFAW = 40
+tWR = 20
+tWR2 = 21
+tRTP = 10
+tCCD_S = 4
+tCCD_L = 7
+tCKE = 7
+tCKESR = 8
+tXS = 480
+tXP = 8
+tRTRS = 1
+
+[power]
+VDD = 1.2
+IDD0 = 85
+IPP0 = 4.0
+IDD2P = 25
+IDD2N = 35
+IDD3P = 43
+IDD3N = 50
+IDD4W = 244
+IDD4R = 263
+IDD5AB = 280
+IDD6x = 30
+
+[system]
+channel_size = 8192
+channels = 1
+bus_width = 64
+address_mapping = rochrababgco
+queue_structure = PER_BANK
+refresh_policy = RANK_LEVEL_STAGGERED
+row_buf_policy = OPEN_PAGE
+cmd_queue_size = 8
+trans_queue_size = 32
+
+[other]
+epoch_period = 1333333
+output_level = 1
+
diff --git a/pnm_sim/configs/DDR4_8Gb_x16_2933.ini b/pnm_sim/configs/DDR4_8Gb_x16_2933.ini
new file mode 100644
index 0000000..f632d54
--- /dev/null
+++ b/pnm_sim/configs/DDR4_8Gb_x16_2933.ini
@@ -0,0 +1,67 @@
+[dram_structure]
+protocol = DDR4
+bankgroups = 2
+banks_per_group = 4
+rows = 65536
+columns = 1024
+device_width = 16
+BL = 8
+
+[timing]
+tCK = 0.68
+AL = 0
+CL = 21
+CWL = 16
+tRCD = 21
+tRP = 21
+tRAS = 47
+tRFC = 514
+tRFC2 = 382
+tRFC4 = 235
+tREFI = 11439
+tRPRE = 1
+tWPRE = 1
+tRRD_S = 8
+tRRD_L = 10
+tWTR_S = 4
+tWTR_L = 11
+tFAW = 44
+tWR = 22
+tWR2 = 23
+tRTP = 11
+tCCD_S = 4
+tCCD_L = 8
+tCKE = 8
+tCKESR = 9
+tXS = 528
+tXP = 9
+tRTRS = 1
+
+[power]
+VDD = 1.2
+IDD0 = 90
+IPP0 = 4.0
+IDD2P = 25
+IDD2N = 36
+IDD3P = 45
+IDD3N = 53
+IDD4W = 261
+IDD4R = 283
+IDD5AB = 280
+IDD6x = 30
+
+[system]
+channel_size = 8192
+channels = 1
+bus_width = 64
+address_mapping = rochrababgco
+queue_structure = PER_BANK
+refresh_policy = RANK_LEVEL_STAGGERED
+row_buf_policy = OPEN_PAGE
+cmd_queue_size = 8
+trans_queue_size = 32
+
+[other]
+epoch_period = 1470588
+output_level = 1
+
diff --git a/pnm_sim/configs/DDR4_8Gb_x16_2933_2.ini b/pnm_sim/configs/DDR4_8Gb_x16_2933_2.ini
new file mode 100644
index 0000000..bf90ba9
--- /dev/null
+++ b/pnm_sim/configs/DDR4_8Gb_x16_2933_2.ini
@@ -0,0 +1,67 @@
+[dram_structure]
+protocol = DDR4
+bankgroups = 2
+banks_per_group = 4
+rows = 65536
+columns = 1024
+device_width = 16
+BL = 8
+
+[timing]
+tCK = 0.68
+AL = 0
+CL = 20
+CWL = 16
+tRCD = 20
+tRP = 20
+tRAS = 47
+tRFC = 514
+tRFC2 = 382
+tRFC4 = 235
+tREFI = 11439
+tRPRE = 1
+tWPRE = 1
+tRRD_S = 8
+tRRD_L = 10
+tWTR_S = 4
+tWTR_L = 11
+tFAW = 44
+tWR = 22
+tWR2 = 23
+tRTP = 11
+tCCD_S = 4
+tCCD_L = 8
+tCKE = 8
+tCKESR = 9
+tXS = 528
+tXP = 9
+tRTRS = 1
+
+[power]
+VDD = 1.2
+IDD0 = 90
+IPP0 = 4.0
+IDD2P = 25
+IDD2N = 36
+IDD3P = 45
+IDD3N = 53
+IDD4W = 261
+IDD4R = 283
+IDD5AB = 280
+IDD6x = 30
+
+[system]
+channel_size = 8192
+channels = 1
+bus_width = 64
+address_mapping = rochrababgco
+queue_structure = PER_BANK
+refresh_policy = RANK_LEVEL_STAGGERED
+row_buf_policy = OPEN_PAGE
+cmd_queue_size = 8
+trans_queue_size = 32
+
+[other]
+epoch_period = 1470588
+output_level = 1
+
diff --git a/pnm_sim/configs/DDR4_8Gb_x16_3200.ini b/pnm_sim/configs/DDR4_8Gb_x16_3200.ini
new file mode 100644
index 0000000..751ed01
--- /dev/null
+++ b/pnm_sim/configs/DDR4_8Gb_x16_3200.ini
@@ -0,0 +1,67 @@
+[dram_structure]
+protocol = DDR4
+bankgroups = 2
+banks_per_group = 4
+rows = 65536
+columns = 1024
+device_width = 16
+BL = 8
+
+[timing]
+tCK = 0.63
+AL = 0
+CL = 22
+CWL = 16
+tRCD = 22
+tRP = 22
+tRAS = 52
+tRFC = 560
+tRFC2 = 416
+tRFC4 = 256
+tREFI = 12480
+tRPRE = 1
+tWPRE = 1
+tRRD_S = 9
+tRRD_L = 11
+tWTR_S = 4
+tWTR_L = 12
+tFAW = 48
+tWR = 24
+tWR2 = 25
+tRTP = 12
+tCCD_S = 4
+tCCD_L = 8
+tCKE = 8
+tCKESR = 9
+tXS = 576
+tXP = 10
+tRTRS = 1
+
+[power]
+VDD = 1.2
+IDD0 = 95
+IPP0 = 4.0
+IDD2P = 25
+IDD2N = 37
+IDD3P = 47
+IDD3N = 56
+IDD4W = 278
+IDD4R = 302
+IDD5AB = 280
+IDD6x = 30
+
+[system]
+channel_size = 8192
+channels = 1
+bus_width = 64
+address_mapping = rochrababgco
+queue_structure = PER_BANK
+refresh_policy = RANK_LEVEL_STAGGERED
+row_buf_policy = OPEN_PAGE
+cmd_queue_size = 8
+trans_queue_size = 32
+
+[other]
+epoch_period = 1587301
+output_level = 1
+
diff --git a/configs/DDR4_8Gb_x4_1866.ini b/pnm_sim/configs/DDR4_8Gb_x4_1866.ini
similarity index 100%
rename from configs/DDR4_8Gb_x4_1866.ini
rename to pnm_sim/configs/DDR4_8Gb_x4_1866.ini
diff --git a/configs/DDR4_8Gb_x4_2133.ini b/pnm_sim/configs/DDR4_8Gb_x4_2133.ini
similarity index 100%
rename from configs/DDR4_8Gb_x4_2133.ini
rename to pnm_sim/configs/DDR4_8Gb_x4_2133.ini
diff --git a/configs/DDR4_8Gb_x4_2133_2.ini b/pnm_sim/configs/DDR4_8Gb_x4_2133_2.ini
similarity index 100%
rename from configs/DDR4_8Gb_x4_2133_2.ini
rename to pnm_sim/configs/DDR4_8Gb_x4_2133_2.ini
diff --git a/configs/DDR4_8Gb_x4_2400.ini b/pnm_sim/configs/DDR4_8Gb_x4_2400.ini
similarity index 100%
rename from configs/DDR4_8Gb_x4_2400.ini
rename to pnm_sim/configs/DDR4_8Gb_x4_2400.ini
diff --git a/configs/DDR4_8Gb_x4_2400_2.ini b/pnm_sim/configs/DDR4_8Gb_x4_2400_2.ini
similarity index 100%
rename from configs/DDR4_8Gb_x4_2400_2.ini
rename to pnm_sim/configs/DDR4_8Gb_x4_2400_2.ini
diff --git a/configs/DDR4_8Gb_x4_2666.ini b/pnm_sim/configs/DDR4_8Gb_x4_2666.ini
similarity index 100%
rename from configs/DDR4_8Gb_x4_2666.ini
rename to pnm_sim/configs/DDR4_8Gb_x4_2666.ini
diff --git a/configs/DDR4_8Gb_x4_2666_2.ini b/pnm_sim/configs/DDR4_8Gb_x4_2666_2.ini
similarity index 100%
rename from configs/DDR4_8Gb_x4_2666_2.ini
rename to pnm_sim/configs/DDR4_8Gb_x4_2666_2.ini
diff --git a/configs/DDR4_8Gb_x4_2933.ini b/pnm_sim/configs/DDR4_8Gb_x4_2933.ini
similarity index 100%
rename from configs/DDR4_8Gb_x4_2933.ini
rename to pnm_sim/configs/DDR4_8Gb_x4_2933.ini
diff --git a/configs/DDR4_8Gb_x4_2933_2.ini b/pnm_sim/configs/DDR4_8Gb_x4_2933_2.ini
similarity index 100%
rename from configs/DDR4_8Gb_x4_2933_2.ini
rename to pnm_sim/configs/DDR4_8Gb_x4_2933_2.ini
diff --git a/configs/DDR4_8Gb_x4_3200.ini b/pnm_sim/configs/DDR4_8Gb_x4_3200.ini
similarity index 100%
rename from configs/DDR4_8Gb_x4_3200.ini
rename to pnm_sim/configs/DDR4_8Gb_x4_3200.ini
diff --git a/configs/DDR4_8Gb_x8_1866.ini b/pnm_sim/configs/DDR4_8Gb_x8_1866.ini
similarity index 100%
rename from configs/DDR4_8Gb_x8_1866.ini
rename to pnm_sim/configs/DDR4_8Gb_x8_1866.ini
diff --git a/configs/DDR4_8Gb_x8_2133.ini b/pnm_sim/configs/DDR4_8Gb_x8_2133.ini
similarity index 100%
rename from configs/DDR4_8Gb_x8_2133.ini
rename to pnm_sim/configs/DDR4_8Gb_x8_2133.ini
diff --git a/configs/DDR4_8Gb_x8_2133_2.ini b/pnm_sim/configs/DDR4_8Gb_x8_2133_2.ini
similarity index 100%
rename from configs/DDR4_8Gb_x8_2133_2.ini
rename to pnm_sim/configs/DDR4_8Gb_x8_2133_2.ini
diff --git a/configs/DDR4_8Gb_x8_2400.ini b/pnm_sim/configs/DDR4_8Gb_x8_2400.ini
similarity index 100%
rename from configs/DDR4_8Gb_x8_2400.ini
rename to pnm_sim/configs/DDR4_8Gb_x8_2400.ini
diff --git a/configs/DDR4_8Gb_x8_2400_2.ini b/pnm_sim/configs/DDR4_8Gb_x8_2400_2.ini
similarity index 100%
rename from configs/DDR4_8Gb_x8_2400_2.ini
rename to pnm_sim/configs/DDR4_8Gb_x8_2400_2.ini
diff --git a/configs/DDR4_8Gb_x8_2666.ini b/pnm_sim/configs/DDR4_8Gb_x8_2666.ini
similarity index 100%
rename from configs/DDR4_8Gb_x8_2666.ini
rename to pnm_sim/configs/DDR4_8Gb_x8_2666.ini
diff --git a/configs/DDR4_8Gb_x8_2666_2.ini b/pnm_sim/configs/DDR4_8Gb_x8_2666_2.ini
similarity index 100%
rename from configs/DDR4_8Gb_x8_2666_2.ini
rename to pnm_sim/configs/DDR4_8Gb_x8_2666_2.ini
diff --git a/configs/DDR4_8Gb_x8_2933.ini b/pnm_sim/configs/DDR4_8Gb_x8_2933.ini
similarity index 100%
rename from configs/DDR4_8Gb_x8_2933.ini
rename to pnm_sim/configs/DDR4_8Gb_x8_2933.ini
diff --git a/configs/DDR4_8Gb_x8_2933_2.ini b/pnm_sim/configs/DDR4_8Gb_x8_2933_2.ini
similarity index 100%
rename from configs/DDR4_8Gb_x8_2933_2.ini
rename to pnm_sim/configs/DDR4_8Gb_x8_2933_2.ini
diff --git a/configs/DDR4_8Gb_x8_3200.ini b/pnm_sim/configs/DDR4_8Gb_x8_3200.ini
similarity index 100%
rename from configs/DDR4_8Gb_x8_3200.ini
rename to pnm_sim/configs/DDR4_8Gb_x8_3200.ini
diff --git a/configs/GDDR5X_8Gb_x32.ini b/pnm_sim/configs/GDDR5X_8Gb_x32.ini
similarity index 100%
rename from configs/GDDR5X_8Gb_x32.ini
rename to pnm_sim/configs/GDDR5X_8Gb_x32.ini
diff --git a/configs/GDDR5_1Gb_x32.ini b/pnm_sim/configs/GDDR5_1Gb_x32.ini
similarity index 100%
rename from configs/GDDR5_1Gb_x32.ini
rename to pnm_sim/configs/GDDR5_1Gb_x32.ini
diff --git a/configs/GDDR5_8Gb_x32.ini b/pnm_sim/configs/GDDR5_8Gb_x32.ini
similarity index 100%
rename from configs/GDDR5_8Gb_x32.ini
rename to pnm_sim/configs/GDDR5_8Gb_x32.ini
diff --git a/configs/GDDR6_8Gb_x16.ini b/pnm_sim/configs/GDDR6_8Gb_x16.ini
similarity index 100%
rename from configs/GDDR6_8Gb_x16.ini
rename to pnm_sim/configs/GDDR6_8Gb_x16.ini
diff --git a/configs/HBM1_4Gb_x128.ini b/pnm_sim/configs/HBM1_4Gb_x128.ini
similarity index 100%
rename from configs/HBM1_4Gb_x128.ini
rename to pnm_sim/configs/HBM1_4Gb_x128.ini
diff --git a/configs/HBM2_4Gb_x128.ini b/pnm_sim/configs/HBM2_4Gb_x128.ini
similarity index 100%
rename from configs/HBM2_4Gb_x128.ini
rename to pnm_sim/configs/HBM2_4Gb_x128.ini
diff --git a/configs/HBM2_8Gb_x128.ini b/pnm_sim/configs/HBM2_8Gb_x128.ini
similarity index 100%
rename from configs/HBM2_8Gb_x128.ini
rename to pnm_sim/configs/HBM2_8Gb_x128.ini
diff --git a/configs/HBM_4Gb_x128.ini b/pnm_sim/configs/HBM_4Gb_x128.ini
similarity index 100%
rename from configs/HBM_4Gb_x128.ini
rename to pnm_sim/configs/HBM_4Gb_x128.ini
diff --git a/configs/HMC2_8GB_4Lx16.ini b/pnm_sim/configs/HMC2_8GB_4Lx16.ini
similarity index 100%
rename from configs/HMC2_8GB_4Lx16.ini
rename to pnm_sim/configs/HMC2_8GB_4Lx16.ini
diff --git a/configs/HMC_2GB_4Lx16.ini b/pnm_sim/configs/HMC_2GB_4Lx16.ini
similarity index 100%
rename from configs/HMC_2GB_4Lx16.ini
rename to pnm_sim/configs/HMC_2GB_4Lx16.ini
diff --git a/configs/HMC_2GB_4Lx16_dummy.ini b/pnm_sim/configs/HMC_2GB_4Lx16_dummy.ini
similarity index 100%
rename from configs/HMC_2GB_4Lx16_dummy.ini
rename to pnm_sim/configs/HMC_2GB_4Lx16_dummy.ini
diff --git a/configs/HMC_4GB_4Lx16.ini b/pnm_sim/configs/HMC_4GB_4Lx16.ini
similarity index 100%
rename from configs/HMC_4GB_4Lx16.ini
rename to pnm_sim/configs/HMC_4GB_4Lx16.ini
diff --git a/configs/LPDDR3_8Gb_x32_1333.ini b/pnm_sim/configs/LPDDR3_8Gb_x32_1333.ini
similarity index 100%
rename from configs/LPDDR3_8Gb_x32_1333.ini
rename to pnm_sim/configs/LPDDR3_8Gb_x32_1333.ini
diff --git a/configs/LPDDR3_8Gb_x32_1600.ini b/pnm_sim/configs/LPDDR3_8Gb_x32_1600.ini
similarity index 100%
rename from configs/LPDDR3_8Gb_x32_1600.ini
rename to pnm_sim/configs/LPDDR3_8Gb_x32_1600.ini
diff --git a/configs/LPDDR3_8Gb_x32_1866.ini b/pnm_sim/configs/LPDDR3_8Gb_x32_1866.ini
similarity index 100%
rename from configs/LPDDR3_8Gb_x32_1866.ini
rename to pnm_sim/configs/LPDDR3_8Gb_x32_1866.ini
diff --git a/configs/LPDDR4_8Gb_x16_2400.ini b/pnm_sim/configs/LPDDR4_8Gb_x16_2400.ini
similarity index 100%
rename from configs/LPDDR4_8Gb_x16_2400.ini
rename to pnm_sim/configs/LPDDR4_8Gb_x16_2400.ini
diff --git a/configs/ST-1.2x.ini b/pnm_sim/configs/ST-1.2x.ini
similarity index 100%
rename from configs/ST-1.2x.ini
rename to pnm_sim/configs/ST-1.2x.ini
diff --git a/configs/ST-1.5x.ini b/pnm_sim/configs/ST-1.5x.ini
similarity index 100%
rename from configs/ST-1.5x.ini
rename to pnm_sim/configs/ST-1.5x.ini
diff --git a/configs/ST-2.0x.ini b/pnm_sim/configs/ST-2.0x.ini
similarity index 100%
rename from configs/ST-2.0x.ini
rename to pnm_sim/configs/ST-2.0x.ini
diff --git a/configs/ddr3_debug.ini b/pnm_sim/configs/ddr3_debug.ini
similarity index 100%
rename from configs/ddr3_debug.ini
rename to pnm_sim/configs/ddr3_debug.ini
diff --git a/configs/ddr4_debug.ini b/pnm_sim/configs/ddr4_debug.ini
similarity index 100%
rename from configs/ddr4_debug.ini
rename to pnm_sim/configs/ddr4_debug.ini
diff --git a/configs/lpddr_2Gb_x16.ini b/pnm_sim/configs/lpddr_2Gb_x16.ini
similarity index 100%
rename from configs/lpddr_2Gb_x16.ini
rename to pnm_sim/configs/lpddr_2Gb_x16.ini
diff --git a/ext/fmt/LICENSE.rst b/pnm_sim/ext/fmt/LICENSE.rst
similarity index 100%
rename from ext/fmt/LICENSE.rst
rename to pnm_sim/ext/fmt/LICENSE.rst
diff --git a/ext/fmt/include/fmt/core.h b/pnm_sim/ext/fmt/include/fmt/core.h
similarity index 100%
rename from ext/fmt/include/fmt/core.h
rename to pnm_sim/ext/fmt/include/fmt/core.h
diff --git a/ext/fmt/include/fmt/format-inl.h b/pnm_sim/ext/fmt/include/fmt/format-inl.h
similarity index 100%
rename from ext/fmt/include/fmt/format-inl.h
rename to pnm_sim/ext/fmt/include/fmt/format-inl.h
diff --git a/ext/fmt/include/fmt/format.h b/pnm_sim/ext/fmt/include/fmt/format.h
similarity index 100%
rename from ext/fmt/include/fmt/format.h
rename to pnm_sim/ext/fmt/include/fmt/format.h
diff --git a/ext/headers/INIHLICENSE.txt b/pnm_sim/ext/headers/INIHLICENSE.txt
similarity index 100%
rename from ext/headers/INIHLICENSE.txt
rename to pnm_sim/ext/headers/INIHLICENSE.txt
diff --git a/ext/headers/INIReader.h b/pnm_sim/ext/headers/INIReader.h
similarity index 100%
rename from ext/headers/INIReader.h
rename to pnm_sim/ext/headers/INIReader.h
diff --git a/ext/headers/args.hxx b/pnm_sim/ext/headers/args.hxx
similarity index 100%
rename from ext/headers/args.hxx
rename to pnm_sim/ext/headers/args.hxx
diff --git a/ext/headers/catch.hpp b/pnm_sim/ext/headers/catch.hpp
similarity index 100%
rename from ext/headers/catch.hpp
rename to pnm_sim/ext/headers/catch.hpp
diff --git a/ext/headers/json.hpp b/pnm_sim/ext/headers/json.hpp
similarity index 100%
rename from ext/headers/json.hpp
rename to pnm_sim/ext/headers/json.hpp
diff --git a/scripts/batch_run.py b/pnm_sim/scripts/batch_run.py
similarity index 100%
rename from scripts/batch_run.py
rename to pnm_sim/scripts/batch_run.py
diff --git a/scripts/final_PowerTemperature_map.py b/pnm_sim/scripts/final_PowerTemperature_map.py
similarity index 100%
rename from scripts/final_PowerTemperature_map.py
rename to pnm_sim/scripts/final_PowerTemperature_map.py
diff --git a/scripts/heatmap.py b/pnm_sim/scripts/heatmap.py
similarity index 100%
rename from scripts/heatmap.py
rename to pnm_sim/scripts/heatmap.py
diff --git a/scripts/parse_config.py b/pnm_sim/scripts/parse_config.py
similarity index 100%
rename from scripts/parse_config.py
rename to pnm_sim/scripts/parse_config.py
diff --git a/scripts/plot_stats.py b/pnm_sim/scripts/plot_stats.py
similarity index 100%
rename from scripts/plot_stats.py
rename to pnm_sim/scripts/plot_stats.py
diff --git a/scripts/trace_gen.py b/pnm_sim/scripts/trace_gen.py
similarity index 100%
rename from scripts/trace_gen.py
rename to pnm_sim/scripts/trace_gen.py
diff --git a/scripts/validation.py b/pnm_sim/scripts/validation.py
similarity index 100%
rename from scripts/validation.py
rename to pnm_sim/scripts/validation.py
diff --git a/pnm_sim/src/address_decoder.cc b/pnm_sim/src/address_decoder.cc
new file mode 100644
index 0000000..ab42210
--- /dev/null
+++ b/pnm_sim/src/address_decoder.cc
@@ -0,0 +1,169 @@
+#include "address_decoder.h"
+
+namespace dramsim3 {
+
+AddrDecoder::AddrDecoder(int channel, const Config &config,
+                         const Timing &timing)
+    : channel_id_(channel),
+      clk_(0),
+      config_(config) {
+
+    trans_queue_.reserve(config_.trans_queue_size);
+    return_queue_.reserve(config_.trans_queue_size); // output_buffer
+    ctrl_ = new Controller(channel_id_, config_, timing);
+    pnm_ = new PNM(channel_id_, config_, timing, *ctrl_);
+#ifdef CMD_TRACE
+    std::string trace_file_name = "./pnm_ch" +
+                                  std::to_string(channel_id_) + "_cmd.trace";
+    std::cout << "Command Trace write to " << trace_file_name << std::endl;
+    pnm_trace_.open(trace_file_name, std::ofstream::out);
+#endif  // CMD_TRACE
+}
+
+bool AddrDecoder::WillAcceptTransaction(uint64_t hex_addr, bool is_write,
+                                        FenceMode fence_mode) const {
+    if (fence_mode == FenceMode::NONE) {
+        // just for transfer the transaction.
+        return trans_queue_.size() < trans_queue_.capacity();
+    }
+    if (fence_mode == FenceMode::MFENCE) {
+        return IsAllReadCommandDone()
+               && IsAllWriteCommandDone()
+               && IsAllTransSent();
+    }
+    if (fence_mode == FenceMode::LFENCE) {
+        return IsAllReadCommandDone()
+               && IsAllTransSent();
+    }
+    if(fence_mode == FenceMode::SFENCE) {
+        return IsAllWriteCommandDone()
+               && IsAllTransSent();
+    }
+    if (fence_mode == FenceMode::DONE) {
+        return IsPNMDone()
+               && IsAllTransSent();
+    }
+    std::cerr << " not supported " << std::endl;
+    exit(1);
+    return false;
+}
+
+bool AddrDecoder::AddTransaction(Transaction trans) {
+    trans_queue_.push_back(trans);
+    return true;
+}
+
+void AddrDecoder::SendTransaction() {
+    // add transaction to controller or pnm.
+    auto trans = trans_queue_.begin();
+    if (trans == trans_queue_.end()) return;
+
+    auto pnm_addr = HexToPNMAddress(trans->addr, &config_); 
+    if (trans->IsPNM(pnm_addr)) {
+        if (trans->is_write) {
+            // write instruction, config register
+            pnm_->Write(*trans, pnm_addr);
+#ifdef CMD_TRACE
+            pnm_trace_ << std::left << std::setw(18)
+                       << clk_ << " PNM " << *trans << std::endl;
+#endif  // CMD_TRACE
+        } else {
+            // read psum
+            trans->data = (void*) pnm_->Read(trans->addr, pnm_addr);
+            trans->complete_cycle = clk_ + PNM_PSUM_READ_LATENCY;
+            return_queue_.push_back(*trans);
+#ifdef CMD_TRACE
+            pnm_trace_ << std::left << std::setw(18)
+                       << clk_ << " PNM " << *trans << std::endl;
+#endif  // CMD_TRACE
+        }
+        trans_queue_.erase(trans);
+    }
+    // normal DRAM transaction
+    else {
+        if (ctrl_->WillAcceptTransaction(trans->addr, trans->is_write)) {
+            ctrl_->AddTransaction(*trans);
+            trans_queue_.erase(trans);
+        }
+    }
+}
+
+void AddrDecoder::ClockTick() {
+    // Return PSUM
+    if (!return_queue_.empty())
+        ReturnReadData();
+
+    ctrl_->ClockTick();
+
+    pnm_->ClockTick();
+
+    // send transaction to PNM/controller
+    SendTransaction();
+
+    clk_++;
+}
+
+void AddrDecoder::PrintEpochStats() {
+    ctrl_->PrintEpochStats();
+}
+
+void AddrDecoder::PrintFinalStats() {
+    ctrl_->PrintFinalStats();
+}
+
+void AddrDecoder::ResetStats() {
+    ctrl_->ResetStats();
+}
+
+std::pair<uint64_t, int> AddrDecoder::ReturnDoneTrans(uint64_t clk) {
+    return pnm_->ReturnDoneTrans(clk);
+}
+
+void AddrDecoder::ReturnReadData() {
+    auto it = return_queue_.begin();
+    for (; it != return_queue_.end(); it++) {
+        if (it->complete_cycle < clk_) {
+            // return read data
+            break;
+        }
+    }
+    // there is nothing to return
+    if (it == return_queue_.end()) return;
+    // return 'it'
+    return_queue_.erase(it);
+    return;
+}
+
+bool AddrDecoder::IsAllQueueEmpty() const {
+    return (ctrl_->IsAllQueueEmpty() && return_queue_.empty());
+}
+
+bool AddrDecoder::IsAllReadCommandDone() const {
+    return ctrl_->IsReadQueueEmpty();
+}
+
+bool AddrDecoder::IsAllWriteCommandDone() const {
+    return ctrl_->IsWriteQueueEmpty(); 
+}
+
+bool AddrDecoder::IsPNMDone() const {
+    return pnm_->Done();
+}
+
+bool AddrDecoder::IsAllTransSent() const {
+    return (trans_queue_.size() == 0); 
+}
+
+uint64_t AddrDecoder::HexToPNMAddress(uint64_t hex_addr,
+                                      const Config* config_p_) {
+    uint64_t pnm_addr = 0;
+    uint64_t addr_mask = ((uint64_t)1 << config_p_->addr_bits) - 1;
+    uint64_t low_mask = ((uint64_t)1 
+                        << (config_p_->shift_bits + config_p_->ch_pos)) - 1;
+    uint64_t low_eraser = ~low_mask;
+    pnm_addr += ((hex_addr & addr_mask) >> config_p_->ch_bits) & low_eraser;
+    pnm_addr += hex_addr & low_mask;
+
+    return pnm_addr;
+}
+}  // namespace dramsim3
diff --git a/pnm_sim/src/address_decoder.h b/pnm_sim/src/address_decoder.h
new file mode 100644
index 0000000..b63fad1
--- /dev/null
+++ b/pnm_sim/src/address_decoder.h
@@ -0,0 +1,52 @@
+#ifndef __ADDRDECODER_H
+#define __ADDRDECODER_H
+
+#include "common.h"
+#include "configuration.h"
+#include "timing.h"
+#include "pnm.h"
+#include "controller.h"
+
+namespace dramsim3 {
+#define PNM_PSUM_READ_LATENCY 0 // FIXME will be estimated in board
+
+class AddrDecoder {
+   public:
+    AddrDecoder(int channel, const Config &config, const Timing &timing);
+    ~AddrDecoder() { delete pnm_; delete ctrl_; }
+    void ClockTick();
+    bool WillAcceptTransaction(uint64_t hex_addr, bool is_write,
+                               FenceMode fence_mode = FenceMode::NONE) const;
+    bool AddTransaction(Transaction trans);
+    // Stats output
+    void PrintEpochStats();
+    void PrintFinalStats();
+    void ResetStats();
+    std::pair<uint64_t, int> ReturnDoneTrans(uint64_t clock);
+    void ReturnReadData();
+    bool IsAllQueueEmpty() const;
+
+    Controller* ctrl_;
+    PNM* pnm_;
+
+   private:
+    int channel_id_;
+    uint64_t clk_;
+    const Config &config_;
+
+    std::vector<Transaction> trans_queue_;
+    std::vector<Transaction> return_queue_;
+
+#ifdef CMD_TRACE
+    std::ofstream pnm_trace_;
+#endif  // CMD_TRACE
+
+    void SendTransaction();
+    bool IsAllReadCommandDone() const;
+    bool IsAllWriteCommandDone() const;
+    bool IsPNMDone() const;
+    bool IsAllTransSent() const;
+    uint64_t HexToPNMAddress(uint64_t hex_addr, const Config *config_p_);
+};
+}  // namespace dramsim3
+#endif
diff --git a/src/bankstate.cc b/pnm_sim/src/bankstate.cc
similarity index 100%
rename from src/bankstate.cc
rename to pnm_sim/src/bankstate.cc
diff --git a/src/bankstate.h b/pnm_sim/src/bankstate.h
similarity index 100%
rename from src/bankstate.h
rename to pnm_sim/src/bankstate.h
diff --git a/src/channel_state.cc b/pnm_sim/src/channel_state.cc
similarity index 99%
rename from src/channel_state.cc
rename to pnm_sim/src/channel_state.cc
index 765a18a..88308ec 100644
--- a/src/channel_state.cc
+++ b/pnm_sim/src/channel_state.cc
@@ -44,7 +44,7 @@ bool ChannelState::IsRWPendingOnRef(const Command& cmd) const {
 void ChannelState::BankNeedRefresh(int rank, int bankgroup, int bank,
                                    bool need) {
     if (need) {
-        Address addr = Address(-1, rank, bankgroup, bank, -1, -1);
+        Address addr = Address(-1, rank, bankgroup, bank, -1, -1, &config_);
         refresh_q_.emplace_back(CommandType::REFRESH_BANK, addr, -1);
     } else {
         for (auto it = refresh_q_.begin(); it != refresh_q_.end(); it++) {
@@ -60,7 +60,7 @@ void ChannelState::BankNeedRefresh(int rank, int bankgroup, int bank,
 
 void ChannelState::RankNeedRefresh(int rank, bool need) {
     if (need) {
-        Address addr = Address(-1, rank, -1, -1, -1, -1);
+        Address addr = Address(-1, rank, -1, -1, -1, -1, &config_);
         refresh_q_.emplace_back(CommandType::REFRESH, addr, -1);
     } else {
         for (auto it = refresh_q_.begin(); it != refresh_q_.end(); it++) {
@@ -85,7 +85,7 @@ Command ChannelState::GetReadyCommand(const Command& cmd, uint64_t clk) const {
                     continue;
                 }
                 if (ready_cmd.cmd_type != cmd.cmd_type) {  // likely PRECHARGE
-                    Address new_addr = Address(-1, cmd.Rank(), j, k, -1, -1);
+                    Address new_addr = Address(-1, cmd.Rank(), j, k, -1, -1, &config_);
                     ready_cmd.addr = new_addr;
                     return ready_cmd;
                 } else {
diff --git a/src/channel_state.h b/pnm_sim/src/channel_state.h
similarity index 100%
rename from src/channel_state.h
rename to pnm_sim/src/channel_state.h
diff --git a/src/command_queue.cc b/pnm_sim/src/command_queue.cc
similarity index 100%
rename from src/command_queue.cc
rename to pnm_sim/src/command_queue.cc
diff --git a/src/command_queue.h b/pnm_sim/src/command_queue.h
similarity index 100%
rename from src/command_queue.h
rename to pnm_sim/src/command_queue.h
diff --git a/pnm_sim/src/common.cc b/pnm_sim/src/common.cc
new file mode 100644
index 0000000..b0c7e93
--- /dev/null
+++ b/pnm_sim/src/common.cc
@@ -0,0 +1,289 @@
+#include "common.h"
+#include "fmt/format.h"
+#include <sstream>
+#include <unordered_map>
+#include <unordered_set>
+#include <sys/stat.h>
+
+namespace dramsim3 {
+
+void Address::reset(int ch, int ra, int bg, int ba, int ro, int col,
+                    const Config *config_p_){
+    channel = ch;
+    rank = ra;
+    bankgroup = bg;
+    bank = ba;
+    row = ro;
+    column = col;
+    is_pnm = false;
+    pnm_addr = -1;
+    config_p = config_p_;
+}
+
+void Address::reset(int ch, uint64_t channel_addr_, const Config *config_p_) {
+
+    channel = ch;
+    config_p = config_p_;
+    channel_addr = (channel_addr_) >> config_p->shift_bits; 
+    is_pnm = false;
+
+    if (config_p->ra_pos > config_p->ch_pos) {
+        rank = 
+            (channel_addr_
+             >> (config_p->shift_bits + config_p->ra_pos - config_p->ch_bits))
+            & config_p->ra_mask;
+    } else {
+        rank =
+            (channel_addr_ >> (config_p->shift_bits + config_p->ra_pos))
+            & config_p->ra_mask;
+    }
+
+    if (config_p->bg_pos > config_p->ch_pos) {
+        bankgroup =
+            (channel_addr_ 
+             >> (config_p->shift_bits + config_p->bg_pos + config_p->ch_bits))
+            & config_p->bg_mask;
+    } else {
+        bankgroup =
+            (channel_addr_ >> (config_p->shift_bits + config_p->bg_pos))
+            & config_p->bg_mask;
+    }
+
+    if (config_p->ba_pos > config_p->ch_pos) {
+        bank =
+            (channel_addr_ >>
+             (config_p->shift_bits + config_p->ba_pos + config_p->ch_bits))
+            & config_p->ba_mask;
+    } else {
+        bank =
+            (channel_addr_ >> (config_p->shift_bits + config_p->ba_pos))
+            & config_p->ba_mask;
+    }
+
+    if (config_p->ro_pos > config_p->ch_pos) {
+        row =
+            (channel_addr_
+             >> (config_p->shift_bits + config_p->ro_pos + config_p->ch_bits))
+            & config_p->ro_mask;
+    } else {
+        row =
+            (channel_addr_ >> (config_p->shift_bits + config_p->ro_pos))
+            & config_p->ro_mask;
+    }
+
+    if (config_p->co_pos > config_p->ch_pos) {
+        column =
+            (channel_addr_
+             >> (config_p->shift_bits + config_p->co_pos + config_p->ch_bits))
+            & config_p->co_mask;
+    } else {
+        column =
+            (channel_addr_
+             >> (config_p->shift_bits + config_p->co_pos)) & config_p->co_mask;
+    }
+}
+
+uint64_t Address::GetHexAddress() {
+    uint64_t addr = 0;
+
+    if (is_pnm == false) {
+        addr += (uint64_t)channel << (config_p->shift_bits + config_p->ch_pos);
+        addr += (uint64_t)rank << (config_p->shift_bits + config_p->ra_pos);
+        addr += (uint64_t)bankgroup << (config_p->shift_bits + config_p->bg_pos);
+        addr += (uint64_t)bank << (config_p->shift_bits + config_p->ba_pos);
+        addr += (uint64_t)row << (config_p->shift_bits + config_p->ro_pos);
+        addr += (uint64_t)column << (config_p->shift_bits + config_p->co_pos);
+    } else {
+        uint64_t low_eraser =
+            ~(((uint64_t)1 
+               << (config_p->shift_bits + config_p->ch_pos + config_p->ch_bits))
+             - 1);
+        addr += (pnm_addr << config_p->ch_bits) & low_eraser;
+        addr += (uint64_t)channel << (config_p->shift_bits + config_p->ch_pos);
+        addr += pnm_addr & 
+            (((uint64_t)1 << (config_p->shift_bits + config_p->ch_pos)) - 1);
+    }
+
+    return addr; 
+}
+
+uint64_t Address::GetChannelAddress() {
+    uint64_t addr = 0;
+
+    if (config_p->ra_pos > config_p->ch_pos) {
+        addr += (uint64_t)rank 
+               << (config_p->shift_bits + config_p->ra_pos - config_p->ch_bits);
+    } else {
+        addr += (uint64_t)rank << (config_p->shift_bits + config_p->ra_pos);
+    }
+
+    if (config_p->bg_pos > config_p->ch_pos) {
+        addr += (uint64_t)bankgroup
+               << (config_p->shift_bits + config_p->bg_pos - config_p->ch_bits);
+    } else {
+        addr += (uint64_t)bankgroup
+               << (config_p->shift_bits + config_p->bg_pos);
+    }
+
+    if (config_p->ba_pos > config_p->ch_pos) {
+        addr += (uint64_t)bank
+               << (config_p->shift_bits + config_p->ba_pos - config_p->ch_bits);
+    } else {
+        addr += (uint64_t)bank << (config_p->shift_bits + config_p->ba_pos);
+    }
+
+    if (config_p->ro_pos > config_p->ch_pos) {
+        addr += (uint64_t)row
+               << (config_p->shift_bits + config_p->ro_pos - config_p->ch_bits);
+    } else {
+        addr += (uint64_t)row << (config_p->shift_bits + config_p->ro_pos);
+    }
+
+    if (config_p->co_pos > config_p->ch_pos) {
+        addr += (uint64_t)column
+               << (config_p->shift_bits + config_p->co_pos - config_p->ch_bits);
+    } else {
+        addr += (uint64_t)column << (config_p->shift_bits + config_p->co_pos);
+    }
+
+    channel_addr = addr >> config_p->shift_bits;
+
+    return addr;
+}
+
+uint64_t Address::GetPNMAddress() {
+    return pnm_addr;
+}
+
+std::ostream& operator<<(std::ostream& os, const Command& cmd) {
+    std::vector<std::string> command_string = {
+        "read",
+        "read_p",
+        "write",
+        "write_p",
+        "activate",
+        "precharge",
+        "refresh_bank",  // verilog model doesn't distinguish bank/rank refresh
+        "refresh",
+        "self_refresh_enter",
+        "self_refresh_exit",
+        "WRONG"};
+    os << fmt::format("{:<20} {:>3} {:>3} {:>3} {:>3} {:>#8x} {:>#8x}",
+                      command_string[static_cast<int>(cmd.cmd_type)],
+                      cmd.Channel(), cmd.Rank(), cmd.Bankgroup(), cmd.Bank(),
+                      cmd.Row(), cmd.Column());
+    return os;
+}
+
+std::ostream& operator<<(std::ostream& os, const Transaction& trans) {
+    const std::string trans_type = trans.is_write ? "WRITE" : "READ";
+    os << fmt::format("{:<20} {:>#8x}", trans_type, trans.addr);
+    return os;
+}
+
+std::istream& operator>>(std::istream& is, Transaction& trans) {
+    std::unordered_map<std::string, FenceMode> 
+        fence_types = {{"MFENCE", FenceMode::MFENCE},
+                       {"mfence", FenceMode::MFENCE},
+                       {"LFENCE", FenceMode::LFENCE},
+                       {"lfence", FenceMode::LFENCE},
+                       {"SFENCE", FenceMode::SFENCE},
+                       {"sfence", FenceMode::SFENCE},
+                       {"DONE", FenceMode::DONE},
+                       {"done", FenceMode::DONE}};
+    std::unordered_set<std::string> write_types = {"WRITE", "write", "P_MEM_WR",
+                                                   "SFENCE", "sfence"
+                                                   "BOFF"};
+    std::string mem_op;
+
+    std::string line;
+    size_t pos, end;
+    getline(is, line);
+    if (is.eof()){
+        trans.added_cycle = -1;
+        return is;
+    }
+
+    trans.addr = std::stoul(line, &pos, 16);
+
+    pos = line.find_first_not_of(' ', pos+1);
+    end = line.find(' ', pos+1);
+    mem_op = line.substr(pos, end-pos);
+    trans.is_write = write_types.count(mem_op) == 1;
+    auto it_f = fence_types.find(mem_op);
+    trans.fence_mode = (it_f == fence_types.end()) ?
+                       FenceMode::NONE : it_f->second;
+
+    pos = line.find_first_not_of(' ', end+1);
+    trans.added_cycle = std::stoul(line.substr(pos), &end, 10);
+
+    if (trans.is_write) {
+        pos = line.find_first_not_of(' ', pos+end);
+        std::vector<uint64_t> tmp;
+        while (pos != std::string::npos) {
+            tmp.push_back(std::stoul(line.substr(pos), &end, 16));
+            pos = line.find_first_not_of(' ', pos+end);
+        }
+        trans.data_size = tmp.size();
+
+        uint64_t *t_tmp = new uint64_t [trans.data_size];
+        for (unsigned i = 0; i < tmp.size(); i++){
+            t_tmp[i] = tmp[i];
+        }
+        trans.data = (void *) t_tmp;
+    }
+
+    return is;
+}
+
+int GetBitInPos(uint64_t bits, int pos) {
+    // given a uint64_t value get the binary value of pos-th bit
+    // from MSB to LSB indexed as 63 - 0
+    return (bits >> pos) & 1;
+}
+
+int LogBase2(int power_of_two) {
+    int i = 0;
+    while (power_of_two > 1) {
+        power_of_two /= 2;
+        i++;
+    }
+    return i;
+}
+
+std::vector<std::string> StringSplit(const std::string& s, char delim) {
+    std::vector<std::string> elems;
+    StringSplit(s, delim, std::back_inserter(elems));
+    return elems;
+}
+
+template <typename Out>
+void StringSplit(const std::string& s, char delim, Out result) {
+    std::stringstream ss;
+    ss.str(s);
+    std::string item;
+    while (std::getline(ss, item, delim)) {
+        if (!item.empty()) {
+            *(result++) = item;
+        }
+    }
+}
+
+void AbruptExit(const std::string& file, int line) {
+    std::cerr << "Exiting Abruptly - " << file << ":" << line << std::endl;
+    std::exit(-1);
+}
+
+bool DirExist(std::string dir) {
+    // courtesy to stackoverflow
+    struct stat info;
+    if (stat(dir.c_str(), &info) != 0) {
+        return false;
+    } else if (info.st_mode & S_IFDIR) {
+        return true;
+    } else {  // exists but is file
+        return false;
+    }
+}
+
+}  // namespace dramsim3
diff --git a/src/common.h b/pnm_sim/src/common.h
similarity index 55%
rename from src/common.h
rename to pnm_sim/src/common.h
index 2f3f044..aefc032 100644
--- a/src/common.h
+++ b/pnm_sim/src/common.h
@@ -5,31 +5,92 @@
 #include <iostream>
 #include <vector>
 
+#include "configuration.h"
+#define INST_BUFFER_BYTE_SIZE (256 * 1024)
+#define PNM_INST_BUF_START 0
+#define PNM_INST_BUF_END (PNM_INST_BUF_START + INST_BUFFER_BYTE_SIZE - 1)
+
+#define CONFIG_REG_SIZE 1024
+#define PNM_CONFIG_REG_START (PNM_INST_BUF_END + 1 + 1024)
+#define PNM_CONFIG_REG_END (PNM_CONFIG_REG_START + CONFIG_REG_SIZE - 1)
+#define PNM_EXE_REG_OFFSET 0
+#define PNM_STATUS_REG_OFFSET 64
+
+#define PSUM_BUFFER_BYTE_SIZE (256 * 1024)
+#define PNM_PSUM_BUF_START (PNM_CONFIG_REG_END + 1 + 1024)
+#define PNM_PSUM_BUF_END (PNM_PSUM_BUF_START + PSUM_BUFFER_BYTE_SIZE - 1)
+
 namespace dramsim3 {
 
+enum class FenceMode {NONE, MFENCE, LFENCE, SFENCE, DONE};
+
+class Config;
+
 struct Address {
     Address()
-        : channel(-1), rank(-1), bankgroup(-1), bank(-1), row(-1), column(-1) {}
-    Address(int channel, int rank, int bankgroup, int bank, int row, int column)
+        : channel(-1), rank(-1), bankgroup(-1), bank(-1), row(-1), column(-1),
+          channel_addr(-1), is_pnm(false), pnm_addr(-1), config_p(NULL) {}
+
+    Address(int channel, int rank, int bankgroup, int bank,
+            int row, int column, const Config *config_p)
         : channel(channel),
           rank(rank),
           bankgroup(bankgroup),
           bank(bank),
           row(row),
-          column(column) {}
+          column(column),
+          is_pnm(false),
+          pnm_addr(-1),
+          config_p(config_p) { GetChannelAddress();}
+
     Address(const Address& addr)
         : channel(addr.channel),
           rank(addr.rank),
           bankgroup(addr.bankgroup),
           bank(addr.bank),
           row(addr.row),
-          column(addr.column) {}
+          column(addr.column),
+          channel_addr(addr.channel_addr),
+          is_pnm(addr.is_pnm),
+          pnm_addr(addr.pnm_addr),
+          config_p(addr.config_p) {}
+
+    Address(int ch, uint64_t channel_addr_, const Config *config_p_) {
+        reset(ch, channel_addr_, config_p_); 
+    }
+
+    Address(int ch, bool is_pnm_, uint64_t addr_, const Config *config_p_) {
+        channel = ch;
+        rank = -1;
+        bankgroup = -1;
+        bank = -1;
+        row = -1;
+        column = -1;
+        channel_addr = -1;
+        is_pnm = is_pnm_;
+        pnm_addr = addr_;
+        config_p = config_p_;
+    }
+
+    void reset(int ch, int ra, int bg, int ba, int ro, int col,
+               const Config *config_p_);
+    void reset(int ch, uint64_t channel_addr_, const Config *config_p_);
+    uint64_t GetHexAddress();
+    uint64_t GetChannelAddress();
+    uint64_t GetPNMAddress();
+
     int channel;
     int rank;
     int bankgroup;
     int bank;
     int row;
     int column;
+
+    uint64_t channel_addr;
+    bool is_pnm;
+    uint64_t pnm_addr;
+
+    const Config *config_p;
 };
 
 inline uint32_t ModuloWidth(uint64_t addr, uint32_t bit_width, uint32_t pos) {
@@ -69,7 +130,6 @@ struct Command {
     Command() : cmd_type(CommandType::SIZE), hex_addr(0) {}
     Command(CommandType cmd_type, const Address& addr, uint64_t hex_addr)
         : cmd_type(cmd_type), addr(addr), hex_addr(hex_addr) {}
-    // Command(const Command& cmd) {}
 
     bool IsValid() const { return cmd_type != CommandType::SIZE; }
     bool IsRefresh() const {
@@ -110,16 +170,39 @@ struct Transaction {
         : addr(addr),
           added_cycle(0),
           complete_cycle(0),
-          is_write(is_write) {}
+          is_write(is_write),
+          data(NULL),
+          data_size(0),
+          fence_mode(FenceMode::NONE) {}
     Transaction(const Transaction& tran)
         : addr(tran.addr),
           added_cycle(tran.added_cycle),
           complete_cycle(tran.complete_cycle),
-          is_write(tran.is_write) {}
+          is_write(tran.is_write),
+          data(tran.data),
+          data_size(tran.data_size),
+          fence_mode(tran.fence_mode)  {}
+    Transaction(uint64_t addr, bool is_write, void *data, int data_size,
+                FenceMode fence_mode = FenceMode::NONE)
+        : addr(addr),
+          added_cycle(0),
+          complete_cycle(0),
+          is_write(is_write),
+          data(data),
+          data_size(data_size),
+          fence_mode(fence_mode) {}
+    bool IsPNM(uint64_t hex_addr) const {
+        if ((hex_addr >= PNM_INST_BUF_START) && (hex_addr <= PNM_PSUM_BUF_END))
+            return true;
+        return false;
+    }
     uint64_t addr;
     uint64_t added_cycle;
     uint64_t complete_cycle;
     bool is_write;
+    void *data;
+    int data_size;
+    FenceMode fence_mode;
 
     friend std::ostream& operator<<(std::ostream& os, const Transaction& trans);
     friend std::istream& operator>>(std::istream& is, Transaction& trans);
diff --git a/src/configuration.cc b/pnm_sim/src/configuration.cc
similarity index 93%
rename from src/configuration.cc
rename to pnm_sim/src/configuration.cc
index 297692d..3cc6b97 100644
--- a/src/configuration.cc
+++ b/pnm_sim/src/configuration.cc
@@ -38,7 +38,7 @@ Address Config::AddressMapping(uint64_t hex_addr) const {
     int ba = (hex_addr >> ba_pos) & ba_mask;
     int ro = (hex_addr >> ro_pos) & ro_mask;
     int co = (hex_addr >> co_pos) & co_mask;
-    return Address(channel, rank, bg, ba, ro, co);
+    return Address(channel, rank, bg, ba, ro, co, this);
 }
 
 void Config::CalculateSize() {
@@ -119,6 +119,21 @@ void Config::InitDRAMParams() {
         // for 32B block size
         BL = block_size * 8 / device_width;
     }
+
+    use_pnm                     = reader.GetBoolean("PNM", "use_PNM", true);
+
+    instruction_buffer_size     = GetInteger("PNM", "instruction_buffer_size",
+                                                    256*1024);
+    psum_buffer_size            = GetInteger("PNM", "psum_buffer_size",
+                                                    256*1024);
+    sparse_feature_size         = GetInteger("PNM", "sparse_feature_size", 16);
+    instruction_size            = GetInteger("PNM", "instruction_size", 8);
+    data_size                   = GetInteger("PNM", "data_size", 4);
+
+    instruction_double          = reader.GetBoolean("PNM", "instruction_double",
+                                                           false);
+    psum_double                 = reader.GetBoolean("PNM", "psum_double", false);
+
     // set burst cycle according to protocol
     // We use burst_cycle for timing and use BL for capacity calculation
     // BL = 0 simulate perfect BW
@@ -352,6 +367,13 @@ void Config::SetAddressMapping() {
     int col_low_bits = LogBase2(BL);
     int actual_col_bits = LogBase2(columns) - col_low_bits;
 
+    ch_bits = LogBase2(channels);
+    ra_bits = LogBase2(ranks);
+    bg_bits = LogBase2(bankgroups);
+    ba_bits = LogBase2(banks_per_group);
+    ro_bits = LogBase2(rows);
+    co_bits = actual_col_bits;
+
     // has to strictly follow the order of chan, rank, bg, bank, row, col
     std::map<std::string, int> field_widths;
     field_widths["ch"] = LogBase2(channels);
@@ -401,6 +423,9 @@ void Config::SetAddressMapping() {
     ba_mask = (1 << field_widths.at("ba")) - 1;
     ro_mask = (1 << field_widths.at("ro")) - 1;
     co_mask = (1 << field_widths.at("co")) - 1;
+
+    addr_bits = ch_bits + ra_bits + bg_bits + ba_bits
+                + ro_bits + co_bits + shift_bits;
 }
 
 }  // namespace dramsim3
diff --git a/src/configuration.h b/pnm_sim/src/configuration.h
similarity index 92%
rename from src/configuration.h
rename to pnm_sim/src/configuration.h
index 44dae77..b46e6ee 100644
--- a/src/configuration.h
+++ b/pnm_sim/src/configuration.h
@@ -31,6 +31,10 @@ enum class RefreshPolicy {
     SIZE 
 };
 
+enum class RowBufPolicy { OPEN_PAGE, CLOSE_PAGE, SIZE };
+
+struct Address;
+
 class Config {
    public:
     Config(std::string config_file, std::string out_dir);
@@ -52,8 +56,10 @@ class Config {
 
     // Address mapping numbers
     int shift_bits;
+    int ch_bits, ra_bits, bg_bits, ba_bits, ro_bits, co_bits;
     int ch_pos, ra_pos, bg_pos, ba_pos, ro_pos, co_pos;
     uint64_t ch_mask, ra_mask, bg_mask, ba_mask, ro_mask, co_mask;
+    int addr_bits;
 
     // Generic DRAM timing parameters
     double tCK;
@@ -119,6 +125,16 @@ class Config {
     int num_vaults;
     int block_size;  // block size in bytes
     int xbar_queue_depth;
+    
+    // PNM
+    bool use_pnm; 
+    int instruction_buffer_size; 
+    int psum_buffer_size;
+    int sparse_feature_size;  
+    int instruction_size;  
+    int data_size; 
+    bool instruction_double; 
+    bool psum_double;  
 
     // System
     std::string address_mapping;
@@ -197,6 +213,7 @@ class Config {
 #endif  // THERMAL
     void InitTimingParams();
     void SetAddressMapping();
+
 };
 
 }  // namespace dramsim3
diff --git a/src/controller.cc b/pnm_sim/src/controller.cc
similarity index 93%
rename from src/controller.cc
rename to pnm_sim/src/controller.cc
index a582dcc..e853a08 100644
--- a/src/controller.cc
+++ b/pnm_sim/src/controller.cc
@@ -35,8 +35,8 @@ Controller::Controller(int channel, const Config &config, const Timing &timing)
     }
 
 #ifdef CMD_TRACE
-    std::string trace_file_name = config_.output_prefix + "ch_" +
-                                  std::to_string(channel_id_) + "cmd.trace";
+    std::string trace_file_name = config_.output_prefix + "_ch" +
+                                  std::to_string(channel_id_) + "_cmd.trace";
     std::cout << "Command Trace write to " << trace_file_name << std::endl;
     cmd_trace_.open(trace_file_name, std::ofstream::out);
 #endif  // CMD_TRACE
@@ -62,6 +62,21 @@ std::pair<uint64_t, int> Controller::ReturnDoneTrans(uint64_t clk) {
     return std::make_pair(-1, -1);
 }
 
+bool Controller::IsAllQueueEmpty() {
+
+    // return_queue_
+    if (!return_queue_.empty()) return false;
+    // cmd_queue_
+    if (!cmd_queue_.QueueEmpty()) return false;
+    // unified_queue_
+    if (is_unified_queue_ && !unified_queue_.empty()) return false;
+    // read_queue_, write_buffer_
+    if (!is_unified_queue_
+        && (!read_queue_.empty() || !write_buffer_.empty())) return false;
+    // all queue empty
+    return true;
+}
+
 void Controller::ClockTick() {
     // update refresh counter
     refresh_.ClockTick();
@@ -199,7 +214,8 @@ void Controller::ScheduleTransaction() {
     if (write_draining_ == 0 && !is_unified_queue_) {
         // we basically have a upper and lower threshold for write buffer
         if ((write_buffer_.size() >= write_buffer_.capacity()) ||
-            (write_buffer_.size() > 8 && cmd_queue_.QueueEmpty())) {
+            (write_buffer_.size() > 8 && cmd_queue_.QueueEmpty()) ||
+            (read_queue_.size() == 0)) {
             write_draining_ = write_buffer_.size();
         }
     }
@@ -246,6 +262,7 @@ void Controller::IssueCommand(const Command &cmd) {
             auto it = pending_rd_q_.find(cmd.hex_addr);
             it->second.complete_cycle = clk_ + config_.read_delay;
             return_queue_.push_back(it->second);
+            // update read data to pnm
             pending_rd_q_.erase(it);
             num_reads -= 1;
         }
@@ -344,4 +361,15 @@ void Controller::UpdateCommandStats(const Command &cmd) {
     }
 }
 
+bool Controller::IsReadQueueEmpty() {
+    return (pending_rd_q_.size() == 0);
+}
+
+bool Controller::IsWriteQueueEmpty() {
+    return (pending_wr_q_.size() == 0);
+}
+
+bool Controller::QueueEmpty() const {
+    return cmd_queue_.QueueEmpty();
+}
 }  // namespace dramsim3
diff --git a/src/controller.h b/pnm_sim/src/controller.h
similarity index 94%
rename from src/controller.h
rename to pnm_sim/src/controller.h
index 77bd6af..12806b8 100644
--- a/src/controller.h
+++ b/pnm_sim/src/controller.h
@@ -17,8 +17,6 @@
 
 namespace dramsim3 {
 
-enum class RowBufPolicy { OPEN_PAGE, CLOSE_PAGE, SIZE };
-
 class Controller {
    public:
 #ifdef THERMAL
@@ -36,6 +34,11 @@ class Controller {
     void PrintFinalStats();
     void ResetStats() { simple_stats_.Reset(); }
     std::pair<uint64_t, int> ReturnDoneTrans(uint64_t clock);
+    bool IsAllQueueEmpty();
+
+    bool IsReadQueueEmpty();
+    bool IsWriteQueueEmpty();
+    bool QueueEmpty() const;
 
     int channel_id_;
 
@@ -76,10 +79,12 @@ class Controller {
 
     // transaction queueing
     int write_draining_;
+
     void ScheduleTransaction();
     void IssueCommand(const Command &tmp_cmd);
     Command TransToCommand(const Transaction &trans);
     void UpdateCommandStats(const Command &cmd);
+
 };
 }  // namespace dramsim3
 #endif
diff --git a/src/cpu.cc b/pnm_sim/src/cxl.cc
similarity index 67%
rename from src/cpu.cc
rename to pnm_sim/src/cxl.cc
index 175955f..8017e28 100644
--- a/src/cpu.cc
+++ b/pnm_sim/src/cxl.cc
@@ -1,9 +1,13 @@
-#include "cpu.h"
+#include "cxl.h"
 
 namespace dramsim3 {
 
-void RandomCPU::ClockTick() {
-    // Create random CPU requests at full speed
+bool RandomCXL::ClockTick() {
+    // Only support trace mode
+    std::cerr << "Trace file does not exist" << std::endl;
+    AbruptExit(__FILE__, __LINE__);
+	
+    // Create random CXL requests at full speed
     // this is useful to exploit the parallelism of a DRAM protocol
     // and is also immune to address mapping and scheduling policies
     memory_system_.ClockTick();
@@ -16,10 +20,14 @@ void RandomCPU::ClockTick() {
         memory_system_.AddTransaction(last_addr_, last_write_);
     }
     clk_++;
-    return;
+    return false;
 }
 
-void StreamCPU::ClockTick() {
+bool StreamCXL::ClockTick() {
+    // Only support trace mode
+    std::cerr << "Trace file does not exist" << std::endl;
+    AbruptExit(__FILE__, __LINE__);
+
     // stream-add, read 2 arrays, add them up to the third array
     // this is a very simple approximate but should be able to produce
     // enough buffer hits
@@ -56,13 +64,13 @@ void StreamCPU::ClockTick() {
         inserted_c_ = false;
     }
     clk_++;
-    return;
+    return false;
 }
 
-TraceBasedCPU::TraceBasedCPU(const std::string& config_file,
+TraceBasedCXL::TraceBasedCXL(const std::string& config_file,
                              const std::string& output_dir,
                              const std::string& trace_file)
-    : CPU(config_file, output_dir) {
+    : CXL(config_file, output_dir) {
     trace_file_.open(trace_file);
     if (trace_file_.fail()) {
         std::cerr << "Trace file does not exist" << std::endl;
@@ -70,23 +78,34 @@ TraceBasedCPU::TraceBasedCPU(const std::string& config_file,
     }
 }
 
-void TraceBasedCPU::ClockTick() {
+bool TraceBasedCXL::ClockTick() {
     memory_system_.ClockTick();
     if (!trace_file_.eof()) {
         if (get_next_) {
             get_next_ = false;
             trace_file_ >> trans_;
+            // add CXL_LATENCY
+            trans_.added_cycle += CXL_LATENCY;
         }
         if (trans_.added_cycle <= clk_) {
             get_next_ = memory_system_.WillAcceptTransaction(trans_.addr,
-                                                             trans_.is_write);
-            if (get_next_) {
-                memory_system_.AddTransaction(trans_.addr, trans_.is_write);
+                                                             trans_.is_write,
+                                                             trans_.fence_mode
+                                                            );
+            if (get_next_ &&  trans_.fence_mode == FenceMode::NONE) {
+                memory_system_.AddTransaction(trans_.addr, trans_.is_write,
+                                              trans_.data, trans_.data_size,
+                                              trans_.fence_mode
+                                             );
             }
         }
+    } else {
+        /// check all request queue is empty 
+        return memory_system_.IsAllQueueEmpty();
     }
+
     clk_++;
-    return;
+    return false;
 }
 
 }  // namespace dramsim3
diff --git a/src/cpu.h b/pnm_sim/src/cxl.h
similarity index 62%
rename from src/cpu.h
rename to pnm_sim/src/cxl.h
index 9ec28e7..46bd5bb 100644
--- a/src/cpu.h
+++ b/pnm_sim/src/cxl.h
@@ -1,5 +1,5 @@
-#ifndef __CPU_H
-#define __CPU_H
+#ifndef __CXL_H
+#define __CXL_H
 
 #include <fstream>
 #include <functional>
@@ -9,15 +9,17 @@
 
 namespace dramsim3 {
 
-class CPU {
+#define CXL_LATENCY 0 //FIXME real CXL_LATENCY (cycle)
+
+class CXL {
    public:
-    CPU(const std::string& config_file, const std::string& output_dir)
+    CXL(const std::string& config_file, const std::string& output_dir)
         : memory_system_(
               config_file, output_dir,
-              std::bind(&CPU::ReadCallBack, this, std::placeholders::_1),
-              std::bind(&CPU::WriteCallBack, this, std::placeholders::_1)),
+              std::bind(&CXL::ReadCallBack, this, std::placeholders::_1),
+              std::bind(&CXL::WriteCallBack, this, std::placeholders::_1)),
           clk_(0) {}
-    virtual void ClockTick() = 0;
+    virtual bool ClockTick() = 0; // return done
     void ReadCallBack(uint64_t addr) { return; }
     void WriteCallBack(uint64_t addr) { return; }
     void PrintStats() { memory_system_.PrintStats(); }
@@ -27,10 +29,10 @@ class CPU {
     uint64_t clk_;
 };
 
-class RandomCPU : public CPU {
+class RandomCXL : public CXL {
    public:
-    using CPU::CPU;
-    void ClockTick() override;
+    using CXL::CXL;
+    bool ClockTick() override;
 
    private:
     uint64_t last_addr_;
@@ -39,10 +41,10 @@ class RandomCPU : public CPU {
     bool get_next_ = true;
 };
 
-class StreamCPU : public CPU {
+class StreamCXL : public CXL {
    public:
-    using CPU::CPU;
-    void ClockTick() override;
+    using CXL::CXL;
+    bool ClockTick() override;
 
    private:
     uint64_t addr_a_, addr_b_, addr_c_, offset_ = 0;
@@ -54,12 +56,12 @@ class StreamCPU : public CPU {
     const int stride_ = 64;                // stride in bytes
 };
 
-class TraceBasedCPU : public CPU {
+class TraceBasedCXL : public CXL {
    public:
-    TraceBasedCPU(const std::string& config_file, const std::string& output_dir,
+    TraceBasedCXL(const std::string& config_file, const std::string& output_dir,
                   const std::string& trace_file);
-    ~TraceBasedCPU() { trace_file_.close(); }
-    void ClockTick() override;
+    ~TraceBasedCXL() { trace_file_.close(); }
+    bool ClockTick() override;
 
    private:
     std::ifstream trace_file_;
diff --git a/src/dram_system.cc b/pnm_sim/src/dram_system.cc
similarity index 68%
rename from src/dram_system.cc
rename to pnm_sim/src/dram_system.cc
index 86f35f8..382f77a 100644
--- a/src/dram_system.cc
+++ b/pnm_sim/src/dram_system.cc
@@ -39,8 +39,8 @@ void BaseDRAMSystem::PrintEpochStats() {
         std::ofstream epoch_out(config_.json_epoch_name, std::ofstream::out);
         epoch_out << "[";
     }
-    for (size_t i = 0; i < ctrls_.size(); i++) {
-        ctrls_[i]->PrintEpochStats();
+    for (size_t i = 0; i < decoders_.size(); i++) {
+        decoders_[i]->PrintEpochStats();
         std::ofstream epoch_out(config_.json_epoch_name, std::ofstream::app);
         epoch_out << "," << std::endl;
     }
@@ -64,9 +64,9 @@ void BaseDRAMSystem::PrintStats() {
 
     // close it now so that each channel can handle it
     json_out.close();
-    for (size_t i = 0; i < ctrls_.size(); i++) {
-        ctrls_[i]->PrintFinalStats();
-        if (i != ctrls_.size() - 1) {
+    for (size_t i = 0; i < decoders_.size(); i++) {
+        decoders_[i]->PrintFinalStats();
+        if (i != decoders_.size() - 1) {
             std::ofstream chan_out(config_.json_stats_name, std::ofstream::app);
             chan_out << "," << std::endl;
         }
@@ -80,8 +80,8 @@ void BaseDRAMSystem::PrintStats() {
 }
 
 void BaseDRAMSystem::ResetStats() {
-    for (size_t i = 0; i < ctrls_.size(); i++) {
-        ctrls_[i]->ResetStats();
+    for (size_t i = 0; i < decoders_.size(); i++) {
+        decoders_[i]->ResetStats();
     }
 }
 
@@ -103,29 +103,49 @@ JedecDRAMSystem::JedecDRAMSystem(Config &config, const std::string &output_dir,
         AbruptExit(__FILE__, __LINE__);
     }
 
-    ctrls_.reserve(config_.channels);
+    decoders_.reserve(config_.channels);
     for (auto i = 0; i < config_.channels; i++) {
 #ifdef THERMAL
-        ctrls_.push_back(new Controller(i, config_, timing_, thermal_calc_));
+        std::cerr << "CXL-PNM system does not support termal mode!"
+                  << std::endl;
+        AbruptExit(__FILE__, __LINE__);
 #else
-        ctrls_.push_back(new Controller(i, config_, timing_));
+        decoders_.push_back(new AddrDecoder(i, config_, timing_));
 #endif  // THERMAL
     }
 }
 
 JedecDRAMSystem::~JedecDRAMSystem() {
-    for (auto it = ctrls_.begin(); it != ctrls_.end(); it++) {
+    for (auto it = decoders_.begin(); it != decoders_.end(); it++) {
         delete (*it);
     }
 }
 
-bool JedecDRAMSystem::WillAcceptTransaction(uint64_t hex_addr,
-                                            bool is_write) const {
+bool JedecDRAMSystem::WillAcceptTransaction(uint64_t hex_addr, bool is_write,
+                                            FenceMode fence_mode) const {
     int channel = GetChannel(hex_addr);
-    return ctrls_[channel]->WillAcceptTransaction(hex_addr, is_write);
+    return decoders_[channel]->WillAcceptTransaction(hex_addr,
+                                                     is_write, fence_mode);
 }
 
 bool JedecDRAMSystem::AddTransaction(uint64_t hex_addr, bool is_write) {
+    // not used 
+    int channel = GetChannel(hex_addr);
+    bool ok = decoders_[channel]->WillAcceptTransaction(hex_addr, is_write);
+
+    // what if it is not ok???
+    assert(ok);
+    if (ok) {
+        Transaction trans = Transaction(hex_addr, is_write);
+        decoders_[channel]->AddTransaction(trans);
+    }
+    last_req_clk_ = clk_; 
+    return ok;
+}
+
+bool JedecDRAMSystem::AddTransaction(uint64_t hex_addr, bool is_write,
+                                     void* data, int data_size,
+                                     FenceMode fence_mode) {
 // Record trace - Record address trace for debugging or other purposes
 #ifdef ADDR_TRACE
     address_trace_ << std::hex << hex_addr << std::dec << " "
@@ -133,22 +153,24 @@ bool JedecDRAMSystem::AddTransaction(uint64_t hex_addr, bool is_write) {
 #endif
 
     int channel = GetChannel(hex_addr);
-    bool ok = ctrls_[channel]->WillAcceptTransaction(hex_addr, is_write);
+    bool ok = decoders_[channel]->WillAcceptTransaction(hex_addr, is_write);
 
+    // what if it is not ok???
     assert(ok);
     if (ok) {
-        Transaction trans = Transaction(hex_addr, is_write);
-        ctrls_[channel]->AddTransaction(trans);
+        Transaction trans = Transaction(hex_addr, is_write,
+                                        data, data_size, fence_mode);
+        decoders_[channel]->AddTransaction(trans);
     }
-    last_req_clk_ = clk_;
+    last_req_clk_ = clk_; 
     return ok;
 }
 
 void JedecDRAMSystem::ClockTick() {
-    for (size_t i = 0; i < ctrls_.size(); i++) {
+    for (size_t i = 0; i < decoders_.size(); i++) {
         // look ahead and return earlier
         while (true) {
-            auto pair = ctrls_[i]->ReturnDoneTrans(clk_);
+            auto pair = decoders_[i]->ReturnDoneTrans(clk_);
             if (pair.second == 1) {
                 write_callback_(pair.first);
             } else if (pair.second == 0) {
@@ -158,8 +180,8 @@ void JedecDRAMSystem::ClockTick() {
             }
         }
     }
-    for (size_t i = 0; i < ctrls_.size(); i++) {
-        ctrls_[i]->ClockTick();
+    for (size_t i = 0; i < decoders_.size(); i++) {
+        decoders_[i]->ClockTick();
     }
     clk_++;
 
@@ -169,6 +191,14 @@ void JedecDRAMSystem::ClockTick() {
     return;
 }
 
+bool JedecDRAMSystem::IsAllQueueEmpty() {
+    bool empty = true;
+    for (size_t i = 0; i < decoders_.size(); i++)
+        empty = empty && decoders_[i]->IsAllQueueEmpty();
+
+    return empty;
+}
+
 IdealDRAMSystem::IdealDRAMSystem(Config &config, const std::string &output_dir,
                                  std::function<void(uint64_t)> read_callback,
                                  std::function<void(uint64_t)> write_callback)
@@ -184,6 +214,15 @@ bool IdealDRAMSystem::AddTransaction(uint64_t hex_addr, bool is_write) {
     return true;
 }
 
+bool IdealDRAMSystem::AddTransaction(uint64_t hex_addr, bool is_write,
+                                     void* data, int data_size,
+                                     FenceMode fence_mode) {
+    auto trans = Transaction(hex_addr, is_write, data, data_size, fence_mode);
+    trans.added_cycle = clk_;
+    infinite_buffer_q_.push_back(trans);
+    return true;
+}
+
 void IdealDRAMSystem::ClockTick() {
     for (auto trans_it = infinite_buffer_q_.begin();
          trans_it != infinite_buffer_q_.end();) {
@@ -204,4 +243,8 @@ void IdealDRAMSystem::ClockTick() {
     return;
 }
 
+bool IdealDRAMSystem::IsAllQueueEmpty() {
+    return infinite_buffer_q_.empty();
+}
+
 }  // namespace dramsim3
diff --git a/src/dram_system.h b/pnm_sim/src/dram_system.h
similarity index 65%
rename from src/dram_system.h
rename to pnm_sim/src/dram_system.h
index 7864b2c..3731577 100644
--- a/src/dram_system.h
+++ b/pnm_sim/src/dram_system.h
@@ -7,7 +7,7 @@
 
 #include "common.h"
 #include "configuration.h"
-#include "controller.h"
+#include "address_decoder.h"
 #include "timing.h"
 
 #ifdef THERMAL
@@ -28,13 +28,20 @@ class BaseDRAMSystem {
     void PrintStats();
     void ResetStats();
 
-    virtual bool WillAcceptTransaction(uint64_t hex_addr,
-                                       bool is_write) const = 0;
+    virtual bool WillAcceptTransaction(uint64_t hex_addr, bool is_write,
+                                       FenceMode fence_mode = FenceMode::NONE)
+                                      const = 0;
     virtual bool AddTransaction(uint64_t hex_addr, bool is_write) = 0;
+    virtual bool AddTransaction(uint64_t hex_addr, bool is_write, void* data,
+                                int data_size,
+                                FenceMode fence_mode = FenceMode::NONE) = 0;
     virtual void ClockTick() = 0;
     int GetChannel(uint64_t hex_addr) const;
 
     std::function<void(uint64_t req_id)> read_callback_, write_callback_;
+
+    virtual bool IsAllQueueEmpty() = 0;
+
     static int total_channels_;
 
    protected:
@@ -50,6 +57,9 @@ class BaseDRAMSystem {
 #endif  // THERMAL
 
     uint64_t clk_;
+    std::vector<AddrDecoder*> decoders_;
+
+    // left for hmc
     std::vector<Controller*> ctrls_;
 
 #ifdef ADDR_TRACE
@@ -64,9 +74,15 @@ class JedecDRAMSystem : public BaseDRAMSystem {
                     std::function<void(uint64_t)> read_callback,
                     std::function<void(uint64_t)> write_callback);
     ~JedecDRAMSystem();
-    bool WillAcceptTransaction(uint64_t hex_addr, bool is_write) const override;
+    bool WillAcceptTransaction(uint64_t hex_addr, bool is_write,
+                               FenceMode fence_mode = FenceMode::NONE)
+                              const override;
     bool AddTransaction(uint64_t hex_addr, bool is_write) override;
+    bool AddTransaction(uint64_t hex_addr, bool is_write, void* data,
+                        int data_size,
+                        FenceMode fence_mode = FenceMode::NONE) override;
     void ClockTick() override;
+    bool IsAllQueueEmpty() override;
 };
 
 // Model a memorysystem with an infinite bandwidth and a fixed latency (possibly
@@ -78,12 +94,17 @@ class IdealDRAMSystem : public BaseDRAMSystem {
                     std::function<void(uint64_t)> read_callback,
                     std::function<void(uint64_t)> write_callback);
     ~IdealDRAMSystem();
-    bool WillAcceptTransaction(uint64_t hex_addr,
-                               bool is_write) const override {
+    bool WillAcceptTransaction(uint64_t hex_addr, bool is_write,
+                               FenceMode fence_mode = FenceMode::NONE)
+                              const override {
         return true;
     };
     bool AddTransaction(uint64_t hex_addr, bool is_write) override;
+    bool AddTransaction(uint64_t hex_addr, bool is_write, void* data,
+                        int data_size,
+                        FenceMode fence_mode = FenceMode::NONE) override;
     void ClockTick() override;
+    bool IsAllQueueEmpty() override;
 
    private:
     int latency_;
diff --git a/src/dramsim3.h b/pnm_sim/src/dramsim3.h
similarity index 100%
rename from src/dramsim3.h
rename to pnm_sim/src/dramsim3.h
diff --git a/src/hmc.cc b/pnm_sim/src/hmc.cc
similarity index 97%
rename from src/hmc.cc
rename to pnm_sim/src/hmc.cc
index 5f5c23b..e01aba7 100644
--- a/src/hmc.cc
+++ b/pnm_sim/src/hmc.cc
@@ -327,8 +327,8 @@ inline void HMCMemorySystem::IterateNextLink() {
     return;
 }
 
-bool HMCMemorySystem::WillAcceptTransaction(uint64_t hex_addr,
-                                            bool is_write) const {
+bool HMCMemorySystem::WillAcceptTransaction(uint64_t hex_addr, bool is_write,
+                                            FenceMode fence_mode) const {
     bool insertable = false;
     for (auto link_queue = link_req_queues_.begin();
          link_queue != link_req_queues_.end(); link_queue++) {
@@ -394,6 +394,14 @@ bool HMCMemorySystem::AddTransaction(uint64_t hex_addr, bool is_write) {
     return InsertHMCReq(req);
 }
 
+bool HMCMemorySystem::AddTransaction(uint64_t hex_addr, bool is_write,
+                                     void* data, int data_size,
+                                     FenceMode fence_mode) {
+    // NOT IMPLEMENTED
+    assert(false);
+    return false;
+}
+
 bool HMCMemorySystem::InsertReqToLink(HMCRequest *req, int link) {
     // These things need to happen when an HMC request is inserted to a link:
     // 1. check if link queue full
@@ -586,6 +594,11 @@ void HMCMemorySystem::ClockTick() {
     return;
 }
 
+bool HMCMemorySystem::IsAllQueueEmpty() {
+    assert(false);
+    return true;
+}
+
 std::vector<int> HMCMemorySystem::BuildAgeQueue(std::vector<int> &age_counter) {
     // return a vector of indices sorted in decending order
     // meaning that the oldest age link/quad should be processed first
diff --git a/src/hmc.h b/pnm_sim/src/hmc.h
similarity index 92%
rename from src/hmc.h
rename to pnm_sim/src/hmc.h
index f9900c6..d2894a8 100644
--- a/src/hmc.h
+++ b/pnm_sim/src/hmc.h
@@ -114,11 +114,17 @@ class HMCMemorySystem : public BaseDRAMSystem {
     void ClockTick() override;
 
     // had to have 3 insert interfaces cuz HMC is so different...
-    bool WillAcceptTransaction(uint64_t hex_addr, bool is_write) const override;
+    bool WillAcceptTransaction(uint64_t hex_addr, bool is_write,
+                        FenceMode fence_mode = FenceMode::NONE) const override;
     bool AddTransaction(uint64_t hex_addr, bool is_write) override;
+    bool AddTransaction(uint64_t hex_addr, bool is_write, void *data,
+                        int data_size,
+                        FenceMode fence_mode = FenceMode::NONE) override;
     bool InsertReqToLink(HMCRequest* req, int link);
     bool InsertHMCReq(HMCRequest* req);
 
+    bool IsAllQueueEmpty() override;
+
    private:
     uint64_t logic_clk_, ps_per_dram_, ps_per_logic_, logic_ps_, dram_ps_;
 
diff --git a/src/main.cc b/pnm_sim/src/main.cc
similarity index 65%
rename from src/main.cc
rename to pnm_sim/src/main.cc
index 9ca252e..3d6740b 100644
--- a/src/main.cc
+++ b/pnm_sim/src/main.cc
@@ -1,16 +1,14 @@
 #include <iostream>
 #include "./../ext/headers/args.hxx"
-#include "cpu.h"
+#include "cxl.h"
 
 using namespace dramsim3;
 
 int main(int argc, const char **argv) {
     args::ArgumentParser parser(
-        "DRAM Simulator.",
+        "CXL-PNM SIMULATOR using Dramsim3.",
         "Examples: \n."
-        "./build/dramsim3main configs/DDR4_8Gb_x8_3200.ini -c 100 -t "
-        "sample_trace.txt\n"
-        "./build/dramsim3main configs/DDR4_8Gb_x8_3200.ini -s random -c 100");
+        "./build/dramsim3main configs/DDR4_8Gb_x8_3200.ini -c 100 -t sample_trace.txt\n");
     args::HelpFlag help(parser, "help", "Display the help menu", {'h', "help"});
     args::ValueFlag<uint64_t> num_cycles_arg(parser, "num_cycles",
                                              "Number of cycles to simulate",
@@ -18,12 +16,9 @@ int main(int argc, const char **argv) {
     args::ValueFlag<std::string> output_dir_arg(
         parser, "output_dir", "Output directory for stats files",
         {'o', "output-dir"}, ".");
-    args::ValueFlag<std::string> stream_arg(
-        parser, "stream_type", "address stream generator - (random), stream",
-        {'s', "stream"}, "");
     args::ValueFlag<std::string> trace_file_arg(
         parser, "trace",
-        "Trace file, setting this option will ignore -s option",
+        "Trace file, CXL-PNM only support trace mode (mandatory)",
         {'t', "trace"});
     args::Positional<std::string> config_arg(
         parser, "config", "The config file name (mandatory)");
@@ -48,25 +43,24 @@ int main(int argc, const char **argv) {
     uint64_t cycles = args::get(num_cycles_arg);
     std::string output_dir = args::get(output_dir_arg);
     std::string trace_file = args::get(trace_file_arg);
-    std::string stream_type = args::get(stream_arg);
 
-    CPU *cpu;
+    CXL *cxl;
     if (!trace_file.empty()) {
-        cpu = new TraceBasedCPU(config_file, output_dir, trace_file);
+        cxl = new TraceBasedCXL(config_file, output_dir, trace_file);
     } else {
-        if (stream_type == "stream" || stream_type == "s") {
-            cpu = new StreamCPU(config_file, output_dir);
-        } else {
-            cpu = new RandomCPU(config_file, output_dir);
-        }
+        std::cerr << "Trace file does not exist" << std::endl;
+        AbruptExit(__FILE__, __LINE__);
     }
 
-    for (uint64_t clk = 0; clk < cycles; clk++) {
-        cpu->ClockTick();
+    uint64_t clk = 0;
+    bool done = false;
+    while ((cycles && (clk < cycles)) || ((!cycles) && (!done))) {
+        done = cxl->ClockTick();
+        clk++;
     }
-    cpu->PrintStats();
+    cxl->PrintStats();
 
-    delete cpu;
+    delete cxl;
 
     return 0;
 }
diff --git a/src/memory_system.cc b/pnm_sim/src/memory_system.cc
similarity index 80%
rename from src/memory_system.cc
rename to pnm_sim/src/memory_system.cc
index 739ea1a..78d8b04 100644
--- a/src/memory_system.cc
+++ b/pnm_sim/src/memory_system.cc
@@ -37,15 +37,25 @@ void MemorySystem::RegisterCallbacks(
     dram_system_->RegisterCallbacks(read_callback, write_callback);
 }
 
-bool MemorySystem::WillAcceptTransaction(uint64_t hex_addr,
-                                         bool is_write) const {
-    return dram_system_->WillAcceptTransaction(hex_addr, is_write);
+bool MemorySystem::WillAcceptTransaction(uint64_t hex_addr, bool is_write,
+                                         FenceMode fence_mode) const {
+    return dram_system_->WillAcceptTransaction(hex_addr, is_write, fence_mode);
 }
 
 bool MemorySystem::AddTransaction(uint64_t hex_addr, bool is_write) {
     return dram_system_->AddTransaction(hex_addr, is_write);
 }
 
+bool MemorySystem::IsAllQueueEmpty() {
+    return dram_system_->IsAllQueueEmpty();
+}
+
+bool MemorySystem::AddTransaction(uint64_t hex_addr, bool is_write, void* data,
+                                  int data_size, FenceMode fence_mode) {
+    return dram_system_->AddTransaction(hex_addr, is_write, data,
+                                        data_size, fence_mode);
+}
+
 void MemorySystem::PrintStats() const { dram_system_->PrintStats(); }
 
 void MemorySystem::ResetStats() { dram_system_->ResetStats(); }
diff --git a/src/memory_system.h b/pnm_sim/src/memory_system.h
similarity index 80%
rename from src/memory_system.h
rename to pnm_sim/src/memory_system.h
index 57eeca1..1d35aaa 100644
--- a/src/memory_system.h
+++ b/pnm_sim/src/memory_system.h
@@ -27,8 +27,14 @@ class MemorySystem {
     void PrintStats() const;
     void ResetStats();
 
-    bool WillAcceptTransaction(uint64_t hex_addr, bool is_write) const;
+    bool WillAcceptTransaction(uint64_t hex_addr, bool is_write,
+                               FenceMode fence_mode = FenceMode::NONE) const;
     bool AddTransaction(uint64_t hex_addr, bool is_write);
+    bool AddTransaction(uint64_t hex_addr, bool is_write,
+                        void* data, int data_size,
+                        FenceMode fence_mode = FenceMode::NONE);
+
+    bool IsAllQueueEmpty();
 
    private:
     // These have to be pointers because Gem5 will try to push this object
diff --git a/pnm_sim/src/pnm.cc b/pnm_sim/src/pnm.cc
new file mode 100644
index 0000000..1d94480
--- /dev/null
+++ b/pnm_sim/src/pnm.cc
@@ -0,0 +1,455 @@
+#include "pnm.h"
+
+
+namespace dramsim3 {
+
+Instruction::Instruction(uint64_t inst_data, int channel_id,
+                         const Config *config_p_) {
+    config_p = config_p_;
+
+    opcode         = static_cast<Opcode>((inst_data >> 62) & 0x3);
+    if (opcode == Opcode::SUM) {
+        cache_hit  = static_cast<bool>((inst_data >> 61) & 0x1);
+        psum_idx   = static_cast<int>((inst_data >> 49) & 0xfff);
+        trace_end  = static_cast<bool>((inst_data >> 48) & 0x1);
+        type       = static_cast<DataType>((inst_data >> 47) & 0x1);
+        input_idx  = static_cast<int>((inst_data >> 43) & 0xf);
+
+        int ch_addr_bits = config_p->addr_bits
+                           - config_p->shift_bits
+                           - config_p->ch_bits;
+        uint64_t ch_addr_mask = (((uint64_t)1 << ch_addr_bits) - 1);
+        addr       = Address(channel_id,
+                     static_cast<uint64_t>
+                     ((inst_data & ch_addr_mask) << config_p->shift_bits),
+                     config_p);
+
+    } else {
+        std::cerr << "unknown opcode" << (int)opcode << std::endl;
+        AbruptExit(__FILE__, __LINE__);
+    }
+    hex_addr = addr.GetHexAddress();
+}
+
+PNM::PNM(int channel, const Config &config, const Timing &timing,
+         Controller& ctrl)
+    : channel_id_(channel),
+      clk_(0),
+      config_(config),
+      sls_exec(false), program_count(-1),
+      num_write_inst(0), num_read_inst(-1), num_accum(-1),
+      inst_offset_idx(0), psum_offset_idx(0),
+      ctrl_(ctrl)
+{
+    auto num_inst = config_.instruction_buffer_size / config_.instruction_size;
+    for (int i = 0; i < num_inst; i++) {
+       inst_buf.insert(std::pair<uint64_t, Instruction>(
+                                 index_to_address(i, PNMRegister::INSTRUCTION),
+                                           Instruction(&config_)));
+    }
+
+    uint64_t inst_buffer_offset =
+        index_to_address(num_inst / 2, PNMRegister::INSTRUCTION)
+        - index_to_address(0, PNMRegister::INSTRUCTION);
+
+    write_instruction_offset.push_back(0);
+
+    if (config_.instruction_double == true) {
+        write_instruction_offset.push_back(inst_buffer_offset);
+        pc_offset.push_back(num_inst / 2);
+    }
+    pc_offset.push_back(0);
+
+    auto num_psum = config_.psum_buffer_size
+                    / config_.sparse_feature_size
+                    / config_.data_size;
+
+    for (int i = 0; i < num_psum; i++) {
+        float *t_data = new float[config_.sparse_feature_size];
+        for (int j = 0; j < config_.sparse_feature_size; j++) {
+            t_data[j] = 0;
+        }
+        psum.insert(std::pair<uint64_t, float *>(
+                              index_to_address(i, PNMRegister::PSUM),
+                                        t_data));
+    }
+
+    read_psum_offset.push_back(0);
+    if (config_.psum_double == true) {
+        psum_offset.push_back(num_psum / 2);
+        read_psum_offset.push_back(index_to_address(num_psum / 2,
+                                                    PNMRegister::PSUM) 
+                                   - index_to_address(0, PNMRegister::PSUM));
+    }
+    psum_offset.push_back(0);
+
+}
+
+bool PNM::Done() {
+    if ((num_write_inst == 0) &&
+        (program_count == -1) &&
+        (num_accum == -1)) return true;
+
+    return false;
+}
+
+void PNM::ClockTick() {
+    if (!sls_exec) {
+        clk_++;
+        // Nothing 
+        return;
+    }
+    // 1. Adder -> PSUM
+    if (!adder_.empty()) {
+        ExecuteAdder();
+    }
+
+    // 2. Data in return_queue_ -> SLS op
+    if (!return_queue_.empty()) {
+        ReturnDataReady();
+    }
+
+    // 3-1. Cache check
+    else if (!cache_q_.empty()) {
+        ReadCache();
+    }
+
+    // 4. Instruction fetch -> Send to controller
+    ScheduleInstruction();
+
+    clk_++;
+    return;
+}
+
+void PNM::Write(Transaction trans, uint64_t pnm_addr) {
+
+    // instruction
+    if ((pnm_addr >= PNM_INST_BUF_START)
+         && (pnm_addr <= PNM_INST_BUF_END)) {
+        WriteInstruction(trans);
+    }
+    // control register
+    else if ((pnm_addr >= PNM_CONFIG_REG_START)
+              && (pnm_addr <= PNM_CONFIG_REG_END)) {
+        WriteConfigRegister(trans);
+    }
+    else {
+        std::cerr << " Write: unknown pnm address " << std::endl;
+        AbruptExit(__FILE__, __LINE__);
+    }
+    return;
+}
+
+void PNM::WriteInstruction(Transaction trans) {
+
+    uint64_t *t_data = (uint64_t*) trans.data;
+    for (int i = 0; i < trans.data_size; i++) {
+        auto it = inst_buf.find(write_instruction_offset[inst_offset_idx]
+                                + trans.addr + i*8);
+
+        if (it == inst_buf.end()) {
+            std::cerr << "instruction address not matching " 
+                      << channel_id_ << "  " 
+                      << std::hex << trans.addr + i*8  << std::dec
+                      << std::endl;
+            AbruptExit(__FILE__, __LINE__);
+        }
+
+        it->second = Instruction(t_data[i], channel_id_, &config_);
+        num_write_inst++;
+    }
+    delete[] t_data;
+
+    return ;
+}
+
+void PNM::WriteConfigRegister(Transaction trans) {
+
+    if (trans.addr == Address(channel_id_,
+                              true,
+                              PNM_CONFIG_REG_START + PNM_EXE_REG_OFFSET,
+                              &config_).GetHexAddress()) { // SLS EXEC
+        if (trans.data_size == 0)
+            AbruptExit(__FILE__, __LINE__);
+
+
+        uint64_t* t_data = (uint64_t*) trans.data;
+        sls_exec = t_data[0] == 0xcafe ? true : false;
+
+        if (sls_exec) {
+            program_count = 0;
+            num_read_inst = 0;
+            num_accum = 0;
+            inst_offset_idx = (inst_offset_idx + 1)
+                              % write_instruction_offset.size();
+            psum_offset_idx = (psum_offset_idx + 1)
+                              % psum_offset.size();
+
+#ifdef DEBUG_PRINT
+            std::cout << clk_ << " sls exec enable " 
+                      << channel_id_ << "  "
+                      << num_write_inst << "  "
+                      << std::endl;
+            num_input = 0;
+            num_weight = 0;
+#endif
+        }
+    }
+    else {
+         std::cerr << " unknown config register write " << std::endl;
+        AbruptExit(__FILE__, __LINE__);
+    }
+
+    return;
+}
+
+
+float *PNM::Read(uint64_t hex_addr, uint64_t pnm_addr) {
+
+    // psum
+    if ((pnm_addr >= PNM_PSUM_BUF_START)
+         && (pnm_addr <= PNM_PSUM_BUF_END)) {
+        return ReadPsumData(hex_addr);
+    }
+    // control register
+    else if ((pnm_addr >= PNM_CONFIG_REG_START)
+              && (pnm_addr <= PNM_CONFIG_REG_END)) {
+        return ReadConfigRegister(hex_addr);
+    }
+    else {
+        std::cerr << " READ: unknown pnm address " 
+                  << std::hex << hex_addr << std::dec 
+                  << std::endl;
+        AbruptExit(__FILE__, __LINE__);
+    }
+
+    return NULL;
+}
+
+float* PNM::ReadConfigRegister(uint64_t hex_addr) {
+
+    float *t_data = new float[config_.sparse_feature_size];
+
+    if (hex_addr == Address(channel_id_,
+                            true,
+                            PNM_CONFIG_REG_START + PNM_STATUS_REG_OFFSET,
+                            &config_
+                           ).GetHexAddress()) {
+
+        for (int i = 0; i < config_.sparse_feature_size; i++) {
+            t_data[i] = 0;
+        }
+
+        t_data[0] = (float)program_count;
+        t_data[1] = this->Done() ? 1111 : 0 ;
+
+    }
+    else {
+        std::cerr << " unknown config register write "
+                  << std::hex << hex_addr << std::dec
+                  << std::endl;
+        AbruptExit(__FILE__, __LINE__);
+    }
+
+    return t_data;
+}
+
+float* PNM::ReadPsumData(uint64_t hex_addr) {
+
+    auto it = psum.find(read_psum_offset[psum_offset_idx] + hex_addr);
+    if (it == psum.end()) {
+        std::cout << "psum buffer idx: "
+                  << psum_offset_idx << "  "
+                  << std::hex << hex_addr << std::dec << "  "
+                  << read_psum_offset[psum_offset_idx]
+                  << std::endl;
+        AbruptExit(__FILE__, __LINE__);
+    }
+
+    return it->second;
+}
+
+
+uint64_t PNM::index_to_address(int idx, PNMRegister reg_mode) {
+
+    uint64_t idx_addr;
+    switch (reg_mode) {
+        case PNMRegister::INSTRUCTION :
+            idx_addr = PNM_INST_BUF_START;
+            // = instruction_size = 8Byte  vs. idx = 64 Byte
+            idx_addr += idx * config_.instruction_size;
+            break;
+        case PNMRegister::PSUM :
+            idx_addr = PNM_PSUM_BUF_START;
+            // size of a psum in sparse feature size x 4 (=fp32)
+            idx_addr += idx * (config_.sparse_feature_size * config_.data_size);
+            break;
+        default:
+            idx_addr = -1;
+            std::cerr << "unknown reg_mode" << std::endl;
+            AbruptExit(__FILE__, __LINE__);
+            break;
+    }
+
+    return Address(channel_id_, true, idx_addr, &config_).GetHexAddress();
+}
+
+
+void PNM::ScheduleInstruction() {
+    if (program_count == -1)
+        return;
+    auto it = inst_buf.find(index_to_address(pc_offset[inst_offset_idx]
+                                             + program_count,
+                                             PNMRegister::INSTRUCTION));
+    if (it == inst_buf.end()) {
+        std::cerr<< "instruction fetching error " << std::endl;
+        AbruptExit(__FILE__, __LINE__);
+    }
+
+    if (it->second.cache_hit == false) {
+        Transaction trans = InstructionToTransaction(it->second);
+        if (requested_rd_q_.count(it->second.hex_addr) == 0) {
+            if (ctrl_.WillAcceptTransaction(trans.addr, trans.is_write)) {
+                ctrl_.AddTransaction(trans);
+            } else {
+                return;
+            }
+        }
+        requested_rd_q_.insert(std::make_pair(it->second.hex_addr, it->second));
+    }
+    else {
+        if (cache_q_.size() < 8) {
+            // = max cache queue size
+            cache_q_.push_back(it->second);
+        }
+        else
+            return;
+    }
+
+    program_count++;
+    if (it->second.trace_end == 1){
+        // program_cout == num_write_inst
+#ifdef DEBUG_PRINT
+        std::cout << "trace_end: " 
+                  << program_count << " " 
+                  << num_write_inst << std::endl;
+#endif
+        num_read_inst = program_count;
+        program_count = -1;
+        num_write_inst = 0;
+    }
+    it->second = Instruction(&config_);
+    return;
+}
+
+Transaction PNM::InstructionToTransaction(const Instruction inst) {
+    // only read (write is not supported)
+    return Transaction(inst.hex_addr, false, NULL, inst.data_size);
+}
+
+void PNM::ReadCache() {
+    auto it = cache_q_.begin();
+    auto it_c = weight_cache_.find(it->hex_addr);
+
+    if (it_c == weight_cache_.end()){
+        return;
+    }
+
+#ifdef CMD_TRACE
+    std::cout << "in cache [" << channel_id_ << "] "
+              << std::left << std::setw(18)
+              << clk_ << " cache hit \t\t"
+              << std::hex << it->addr.channel << "   "
+              << it->addr.rank << "   "
+              << it->addr.bankgroup << "   "
+              << it->addr.bank << "   0x"
+              << it->addr.row << "   0x"
+              << it->addr.column << std::dec
+              << std::endl;
+#endif  // CMD_TRACE
+
+    it->complete_cycle = clk_ + 1;
+    it->data = new float[config_.sparse_feature_size];
+    for (int i = 0; i < config_.sparse_feature_size; i++) {
+        it->data[i] = it_c->second[i];
+    }
+
+    return_queue_.push_back(*it);
+    cache_q_.erase(it);
+}
+
+void PNM::ReturnDataReady() {
+    auto inst = return_queue_.begin();
+    for (; inst != return_queue_.end(); inst++) {
+        if (inst->complete_cycle >= clk_)
+            continue;
+        else // read data ready 
+            break;
+    }
+    if (inst == return_queue_.end()) return; // nothing is ready
+
+    if (inst->opcode == Opcode::SUM) {
+        auto psum_it = psum.find(index_to_address(
+                                  psum_offset[psum_offset_idx] + inst->psum_idx,
+                                  PNMRegister::PSUM));
+        AdderElement adder = AdderElement(inst->psum_idx,
+                                          psum_it->second,
+                                          inst->data);
+        adder_.push_back(adder);
+    }
+    else {
+        std::cerr << "unknown opcode" << (int)inst->opcode << std::endl;
+        AbruptExit(__FILE__, __LINE__);
+    }
+
+    return_queue_.erase(inst);
+}
+
+void PNM::ExecuteAdder(){
+    auto adder_it = adder_.begin();
+    auto it = psum.find(index_to_address(
+                            psum_offset[psum_offset_idx] + adder_it->psum_idx,
+                            PNMRegister::PSUM));
+    if (it == psum.end()) {
+        std::cerr << "unknown address" 
+                  << adder_it->psum_idx << "  "
+                  << std::hex
+                  << index_to_address(adder_it->psum_idx, PNMRegister::PSUM)
+                  << std::dec
+                  << std::endl;
+        AbruptExit(__FILE__, __LINE__);
+    }
+
+    for (int i = 0; i < config_.sparse_feature_size; i++) {
+       it->second[i] = adder_it->psum_data[i] + adder_it->dram_data[i];
+    }
+    adder_.erase(adder_it);
+    num_accum++;
+
+    if (num_accum == num_read_inst) {
+        num_accum = -1;
+        num_read_inst = -1;
+        sls_exec = false;
+    }
+}
+
+std::pair<uint64_t, int> PNM::ReturnDoneTrans(uint64_t clock) {
+    auto pair = ctrl_.ReturnDoneTrans(clock);
+    if (pair.second == -1) return pair; // nothing
+    if (pair.second == 1) return pair; // write
+    auto num_reads = requested_rd_q_.count(pair.first);
+    while (num_reads > 0) {
+        auto it = requested_rd_q_.find(pair.first);
+        it->second.complete_cycle = clock;
+        it->second.data = new float[config_.sparse_feature_size];
+        for (int i = 0; i < config_.sparse_feature_size; i++) {
+            it->second.data[i] = clk_;
+        }
+        return_queue_.push_back(it->second);
+        requested_rd_q_.erase(it);
+        num_reads -= 1;
+    }
+
+   return pair; 
+}
+} // namespace dramsim3
diff --git a/pnm_sim/src/pnm.h b/pnm_sim/src/pnm.h
new file mode 100644
index 0000000..c9d6cd4
--- /dev/null
+++ b/pnm_sim/src/pnm.h
@@ -0,0 +1,188 @@
+#ifndef __PNM_H
+#define __PNM_H
+
+#include <unordered_map>
+#include <iomanip>
+
+#include "controller.h"
+#include "configuration.h"
+
+namespace dramsim3 {
+
+enum class Opcode {SUM, SIZE};
+enum class PNMRegister {INSTRUCTION, PSUM};
+enum class DataType {INPUT, WEIGHT, SIZE};
+
+class Instruction {
+  public:
+    Instruction(const Config *config_p_)
+        : opcode(Opcode::SIZE),
+          trace_end(false),
+          psum_idx(-1),
+          addr(Address()),
+          hex_addr(-1),
+          data(NULL),
+          type(DataType::SIZE),
+          complete_cycle(-1),
+          input_idx(-1),
+          cache_hit(false),
+          data_size(0),
+          batch_size(0),
+          channel_addr(0),
+          config_p(config_p_) {}
+    Instruction(Opcode opcode, bool trace_end, int psum_idx,
+                Address addr, const Config *config_p_)
+        : opcode(opcode),
+          trace_end(trace_end),
+          psum_idx(psum_idx),
+          addr(addr),
+          hex_addr(addr.GetHexAddress()),
+          type(DataType::SIZE),
+          complete_cycle(-1),
+          input_idx(-1),
+          cache_hit(false),
+          config_p(config_p_) {}
+    Instruction(Opcode opcode, bool trace_end, int psum_idx, Address addr,
+                DataType type, const Config *config_p_)
+        : opcode(opcode),
+          trace_end(trace_end),
+          psum_idx(psum_idx),
+          addr(addr),
+          hex_addr(addr.GetHexAddress()),
+          type(type),
+          complete_cycle(-1),
+          input_idx(-1),
+          cache_hit(false),
+          config_p(config_p_) {}
+    Instruction(Opcode opcode, bool trace_end, int psum_idx, int input_idx,
+                bool cache_hit, DataType type, uint32_t channel_addr,
+                int channel_id, const Config *config_p_)
+        : opcode(opcode),
+          trace_end(trace_end),
+          psum_idx(psum_idx),
+          addr(Address(channel_id, 
+                      (channel_addr << config_p_->shift_bits),
+                      config_p_)),
+          hex_addr(addr.GetHexAddress()),
+          type(type),
+          complete_cycle(-1),
+          input_idx(input_idx),
+          cache_hit(cache_hit),
+          config_p(config_p_) {}
+
+    Instruction(uint64_t inst_data, int channel_id, const Config *config_p_);
+
+    Opcode    opcode;
+    bool      trace_end;
+    int       psum_idx;
+    Address   addr;
+    uint64_t  hex_addr;
+    float*    data;
+    DataType  type;
+    uint64_t  complete_cycle;
+    int       input_idx;
+    bool      cache_hit;
+
+    uint32_t       data_size; // (input or output size) / 8
+    uint32_t       batch_size;
+    uint32_t       channel_addr;
+
+    const Config *config_p;
+
+    Instruction& operator= (const Instruction &inst) {
+        opcode           = inst.opcode;
+        trace_end        = inst.trace_end;
+        psum_idx         = inst.psum_idx;
+        addr             = inst.addr;
+        hex_addr         = inst.hex_addr;
+        data             = inst.data;
+        type             = inst.type;
+        complete_cycle   = inst.complete_cycle;
+        input_idx        = inst.input_idx;
+        cache_hit        = inst.cache_hit;
+        data_size        = inst.data_size;
+        batch_size       = inst.batch_size;
+        channel_addr     = inst.channel_addr;
+        config_p         = inst.config_p;
+        return *this;
+    }
+};
+
+class AdderElement {
+  public:
+    AdderElement():psum_idx(-1), psum_data(NULL), dram_data(NULL) {}
+    AdderElement(int idx, float *a, float *b)
+            : psum_idx(idx), psum_data(a), dram_data(b) {}
+    int psum_idx;
+    float* psum_data;
+    float* dram_data;
+};
+
+class PNM {
+  public:
+    PNM(int channel, const Config &config, const Timing &timing,
+        Controller& ctrl);
+    bool Done();
+    void ClockTick();
+    void Write(Transaction trans, uint64_t pnm_addr);
+    float *Read(uint64_t hex_addr, uint64_t pnm_addr);
+    std::pair<uint64_t, int> ReturnDoneTrans(uint64_t clock);
+
+  private:
+    int channel_id_;
+    uint64_t clk_;
+    const Config &config_;
+
+    std::vector<Instruction> cache_q_;
+
+    std::multimap<uint64_t, Instruction> requested_rd_q_;
+    std::vector<Instruction> return_queue_;
+
+    std::vector<AdderElement> adder_;
+
+    std::vector<float*> input_cache_;
+    std::map<uint64_t, float* > weight_cache_;
+
+    // instruction buffer addr - instruction
+    // map 64bit(8B) address to a instruction
+    std::unordered_map<uint64_t, Instruction> inst_buf;
+    // psum buffer
+    // map 64Byte address to 16 x 4B data
+    std::unordered_map<uint64_t, float*> psum;
+
+    bool sls_exec;
+    int program_count, num_write_inst, num_read_inst, num_accum;
+
+    // offset choose instruction or psum
+    uint64_t index_to_address(int idx, PNMRegister reg_mode);
+
+    void WriteInstruction(Transaction Trans);
+    void WriteConfigRegister(Transaction Trans);
+
+    float *ReadConfigRegister(uint64_t hex_addr);
+    float *ReadPsumData(uint64_t hex_addr);
+
+    void ScheduleInstruction();
+    Transaction InstructionToTransaction(const Instruction inst);
+
+    void ReadCache();
+
+    void ReturnDataReady();
+    void ExecuteAdder();
+
+    int inst_offset_idx, psum_offset_idx;
+    std::vector<uint64_t> write_instruction_offset;
+    std::vector<uint64_t> pc_offset;
+    std::vector<uint64_t> psum_offset;
+    std::vector<uint64_t> read_psum_offset;
+
+#ifdef DEBUG_PRINT
+    int num_input, num_weight;
+#endif
+
+   protected:
+    Controller& ctrl_;
+};
+
+}  // namespace dramsim3
+#endif
diff --git a/src/refresh.cc b/pnm_sim/src/refresh.cc
similarity index 100%
rename from src/refresh.cc
rename to pnm_sim/src/refresh.cc
diff --git a/src/refresh.h b/pnm_sim/src/refresh.h
similarity index 100%
rename from src/refresh.h
rename to pnm_sim/src/refresh.h
diff --git a/src/simple_stats.cc b/pnm_sim/src/simple_stats.cc
similarity index 100%
rename from src/simple_stats.cc
rename to pnm_sim/src/simple_stats.cc
diff --git a/src/simple_stats.h b/pnm_sim/src/simple_stats.h
similarity index 100%
rename from src/simple_stats.h
rename to pnm_sim/src/simple_stats.h
diff --git a/src/sp_ienv.c b/pnm_sim/src/sp_ienv.c
similarity index 100%
rename from src/sp_ienv.c
rename to pnm_sim/src/sp_ienv.c
diff --git a/src/thermal.cc b/pnm_sim/src/thermal.cc
similarity index 99%
rename from src/thermal.cc
rename to pnm_sim/src/thermal.cc
index d5da089..b6e6e1d 100644
--- a/src/thermal.cc
+++ b/pnm_sim/src/thermal.cc
@@ -231,7 +231,7 @@ void ThermalCalculator::SetPhyAddressMapping() {
 #endif
 
         return Address(new_pos[0], new_pos[1], new_pos[2], new_pos[3],
-                       new_pos[4], new_pos[5]);
+                       new_pos[4], new_pos[5], &config_);
     };
 }
 
diff --git a/src/thermal.h b/pnm_sim/src/thermal.h
similarity index 100%
rename from src/thermal.h
rename to pnm_sim/src/thermal.h
diff --git a/src/thermal_config.h b/pnm_sim/src/thermal_config.h
similarity index 100%
rename from src/thermal_config.h
rename to pnm_sim/src/thermal_config.h
diff --git a/src/thermal_replay.cc b/pnm_sim/src/thermal_replay.cc
similarity index 100%
rename from src/thermal_replay.cc
rename to pnm_sim/src/thermal_replay.cc
diff --git a/src/thermal_replay.h b/pnm_sim/src/thermal_replay.h
similarity index 100%
rename from src/thermal_replay.h
rename to pnm_sim/src/thermal_replay.h
diff --git a/src/thermal_solver.c b/pnm_sim/src/thermal_solver.c
similarity index 100%
rename from src/thermal_solver.c
rename to pnm_sim/src/thermal_solver.c
diff --git a/src/timing.cc b/pnm_sim/src/timing.cc
similarity index 100%
rename from src/timing.cc
rename to pnm_sim/src/timing.cc
diff --git a/src/timing.h b/pnm_sim/src/timing.h
similarity index 100%
rename from src/timing.h
rename to pnm_sim/src/timing.h
diff --git a/tests/example.trace b/pnm_sim/tests/example.trace
similarity index 100%
rename from tests/example.trace
rename to pnm_sim/tests/example.trace
diff --git a/tests/test_config.cc b/pnm_sim/tests/test_config.cc
similarity index 100%
rename from tests/test_config.cc
rename to pnm_sim/tests/test_config.cc
diff --git a/tests/test_dramsys.cc b/pnm_sim/tests/test_dramsys.cc
similarity index 100%
rename from tests/test_dramsys.cc
rename to pnm_sim/tests/test_dramsys.cc
diff --git a/tests/test_hmcsys.cc b/pnm_sim/tests/test_hmcsys.cc
similarity index 100%
rename from tests/test_hmcsys.cc
rename to pnm_sim/tests/test_hmcsys.cc
diff --git a/scripts/parse_configs_for_trace_gen.py b/scripts/parse_configs_for_trace_gen.py
new file mode 100644
index 0000000..8978c37
--- /dev/null
+++ b/scripts/parse_configs_for_trace_gen.py
@@ -0,0 +1,110 @@
+#!/usr/bin/python3
+
+import sys, re
+
+ch_pattern = re.compile("channels = ([0-9]+)")
+bg_pattern = re.compile("bankgroups = ([0-9]+)")
+ba_pattern = re.compile("banks_per_group = ([0-9]+)")
+ro_pattern = re.compile("rows = ([0-9]+)")
+co_pattern = re.compile("columns = ([0-9]+)")
+device_width_pattern = re.compile("device_width = ([0-9]+)")
+BL_pattern = re.compile("BL = ([0-9]+)")
+
+channel_size_pattern = re.compile("channel_size = ([0-9]+)")
+bus_width_pattern = re.compile("bus_width = ([0-9]+)")
+address_mapping_pattern = re.compile("address_mapping = ([a-z]+)")
+
+ch = 0
+ra = 0
+bg = 0
+ba = 0
+ro = 0
+co = 0
+
+device_width = 0
+BL = 0
+
+channel_size = 0
+bus_width = 0
+address_mapping = "rochrababgco"
+
+ch_list = "0"
+ra_list = "0"
+
+total_banks = 0
+devices_per_rank = 0
+megs_per_bank = 0
+megs_per_rank = 0
+
+configs = ""
+
+config_file = open(sys.argv[1], "r")
+config_line = config_file.readline()
+while config_line:
+    match = re.match(ch_pattern, config_line)
+    if (match):
+        ch = int(match.group(1))
+
+    match = re.match(bg_pattern, config_line)
+    if (match):
+        bg = int(match.group(1))
+
+    match = re.match(ba_pattern, config_line)
+    if (match):
+        ba = int(match.group(1))
+
+    match = re.match(ro_pattern, config_line)
+    if (match):
+        ro = int(match.group(1))
+
+    match = re.match(co_pattern, config_line)
+    if (match):
+        co = int(match.group(1))
+
+    match = re.match(device_width_pattern, config_line)
+    if (match):
+        device_width = int(match.group(1))
+
+    match = re.match(BL_pattern, config_line)
+    if (match):
+        BL = int(match.group(1))
+
+    match = re.match(channel_size_pattern, config_line)
+    if (match):
+        channel_size = int(match.group(1))
+
+    match = re.match(bus_width_pattern, config_line)
+    if (match):
+        bus_width = int(match.group(1))
+
+    match = re.match(address_mapping_pattern, config_line)
+    if (match):
+        address_mapping = str(match.group(1))
+
+    config_line = config_file.readline()
+
+total_banks = bg * ba
+devices_per_rank = bus_width / device_width
+page_size = co * device_width / 8
+megs_per_bank = page_size * (ro / 1024) / 1024
+megs_per_rank = megs_per_bank * total_banks * devices_per_rank
+
+ra = int(channel_size / megs_per_rank)
+
+for i in range(1, ch):
+    ch_list += "-" + str(i)
+
+for i in range(1, ra):
+    ra_list += "-" + str(i)
+
+configs += " --channel " + ch_list
+configs += " --rank " + ra_list
+configs += " --bg_size " + str(bg)
+configs += " --ba_size " + str(ba)
+configs += " --ro_size " + str(ro)
+configs += " --co_size " + str(co)
+configs += " --bus_width " + str(bus_width)
+configs += " --BL " + str(BL)
+configs += " --address_mapping " + address_mapping
+
+sys.stdout.write("%s" %(configs))
diff --git a/scripts/run_pnm_sim.sh b/scripts/run_pnm_sim.sh
new file mode 100644
index 0000000..99ad753
--- /dev/null
+++ b/scripts/run_pnm_sim.sh
@@ -0,0 +1,31 @@
+#!/bin/bash
+
+loc_check="$(basename ${PWD})"
+if [ "${loc_check}" != "scripts" ]; then
+    echo "[warning] Run this script in <PNMSimulator_path>/scripts directory!"
+    exit
+fi
+
+# Configuration file path
+config_file="../configs/DDR4_8Gb_x16_3200.ini"
+
+curr_ts="$(date +%Y%m%d_%H%M%S)"
+res_dir="../results/res_${curr_ts}"
+mkdir -p ${res_dir}/cxlpnm
+mkdir -p ${res_dir}/base
+
+# Run with CXL-PNM trace
+../pnm_sim/build/pnmsim ${config_file} \
+    -t traces/test_cxlpnm.trc \
+    -c 0 \
+    > ${res_dir}/cxlpnm/pnm_sim_cxlpnm.log 2>&1
+mv pnm_*.trace ${res_dir}/cxlpnm
+mv dramsim3* ${res_dir}/cxlpnm
+
+# Run with base trace
+../pnm_sim/build/pnmsim ${config_file} \
+    -t traces/test_base.trc \
+    -c 0 \
+    > ${res_dir}/base/pnm_sim_base.log 2>&1
+mv pnm_*.trace ${res_dir}/base
+mv dramsim3* ${res_dir}/base
diff --git a/scripts/run_trace_gen.sh b/scripts/run_trace_gen.sh
new file mode 100644
index 0000000..dccd092
--- /dev/null
+++ b/scripts/run_trace_gen.sh
@@ -0,0 +1,32 @@
+#!/bin/bash
+
+loc_check="$(basename ${PWD})"
+if [ "${loc_check}" != "scripts" ]; then
+    echo "[warning] Run this script in <PNMSimulator_path>/scripts directory!"
+    exit
+fi
+
+# Configuration file path
+config_file="../configs/DDR4_8Gb_x16_3200.ini"
+
+configs="$(python3 parse_configs_for_trace_gen.py ${config_file})"
+
+# Parameters
+params="
+    --opcode 0
+    --nepochs 2
+    --batch_size 4
+    --embedding_table 1000000-1000000
+    --sparse_feature_size 16
+    --data_type_size 4
+    --pooling_type 0
+    --default_interval 4
+    --miss_ratio 100
+    --base_only false
+    --file_name test
+"
+
+../trace_gen/trace_gen ${configs} ${params} > trace_gen.log 2>&1
+
+mkdir -p traces
+mv *.trc traces
diff --git a/scripts_real_app_mode/run_pnm_sim_real_app_mode.sh b/scripts_real_app_mode/run_pnm_sim_real_app_mode.sh
new file mode 100644
index 0000000..926c7c8
--- /dev/null
+++ b/scripts_real_app_mode/run_pnm_sim_real_app_mode.sh
@@ -0,0 +1,22 @@
+#!/bin/bash
+
+loc_check="$(basename ${PWD})"
+if [ "${loc_check}" != "scripts_real_app_mode" ]; then
+    echo "[warning] Run this script in <PNMSimulator_path>/scripts directory!"
+    exit
+fi
+
+# Configuration file path
+config_file="../configs/real_app_mode.ini"
+
+curr_ts="$(date +%Y%m%d_%H%M%S)"
+res_dir="../results/res_${curr_ts}"
+mkdir -p ${res_dir}/cxlpnm
+
+# Run with CXL-PNM trace
+../pnm_sim/build/pnmsim ${config_file} \
+    -t converted.trc \
+    -c 0 \
+    > ${res_dir}/cxlpnm/pnm_sim_cxlpnm.log 2>&1
+mv pnm_*.trace ${res_dir}/cxlpnm
+mv dramsim3* ${res_dir}/cxlpnm
diff --git a/scripts_real_app_mode/run_qemu.sh b/scripts_real_app_mode/run_qemu.sh
new file mode 100644
index 0000000..524014a
--- /dev/null
+++ b/scripts_real_app_mode/run_qemu.sh
@@ -0,0 +1,39 @@
+#!/bin/bash
+
+curr_ts=$(date +%Y%m%d_%H%M%S)
+
+ID="1"
+INSTALL="0"
+
+CURR_DIR="${PWD}"
+#QEMU_DIR="${CURR_DIR}/../PNMqemu"
+QEMU_DIR="${CURR_DIR}/../PNMqemu"
+QEMU_BUILD_DIR="${QEMU_DIR}/build"
+QEMU_IMG="${QEMU_BUILD_DIR}/pnm-qemu.img"
+ISO="${CURR_DIR}/../ubuntu-22.04.2-live-server-amd64.iso"
+
+if [ "${INSTALL}" == "1" ]; then
+    CDROM_PARAM="-cdrom ${ISO}"
+else
+    CDROM_PARAM=""
+fi
+
+# Use host CPU for setup and emulated CPU for tracing
+CPU_PARAM="-cpu host -enable-kvm -smp 36"
+#CPU_PARAM="-cpu max,+avx,+avx2 --accel tcg -smp 16"
+
+PARAMS=""
+PARAMS="${PARAMS} -drive file=${QEMU_IMG},if=virtio,format=raw"
+PARAMS="${PARAMS} ${CDROM_PARAM}"
+PARAMS="${PARAMS} ${CPU_PARAM}"
+PARAMS="${PARAMS} -m 96G,slots=4,maxmem=128G"
+PARAMS="${PARAMS} -boot d"
+PARAMS="${PARAMS} -nographic"
+PARAMS="${PARAMS} -monitor unix:qemu-monitor-sock,server,nowait"
+PARAMS="${PARAMS} -serial mon:stdio"
+PARAMS="${PARAMS} -net nic -net user,hostfwd=tcp::$((2028 + ${ID}))-:22"
+PARAMS="${PARAMS} -vnc 127.0.0.1:$((1 + ${ID}))"
+PARAMS="${PARAMS} -echr 0x2" # Escape letter for monitor mode: Ctrl + b
+PARAMS="${PARAMS} "
+
+sudo ${QEMU_BUILD_DIR}/qemu-system-x86_64 ${PARAMS}
diff --git a/scripts_real_app_mode/ssh_qemu.sh b/scripts_real_app_mode/ssh_qemu.sh
new file mode 100644
index 0000000..8833de0
--- /dev/null
+++ b/scripts_real_app_mode/ssh_qemu.sh
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+# Change HOST_IP and USER
+ID="1"
+HOST_IP="11.22.33.44"
+USER="pnmsimulator"
+
+ssh -p $((2028 + ${ID})) ${USER}@${HOST_IP}
diff --git a/scripts_real_app_mode/trace_conv.py b/scripts_real_app_mode/trace_conv.py
new file mode 100644
index 0000000..b9dbeae
--- /dev/null
+++ b/scripts_real_app_mode/trace_conv.py
@@ -0,0 +1,286 @@
+#!/usr/bin/python3
+
+import sys, re
+
+CLK = 0
+CLK_INTERVAL = 4
+
+CH_NUM = 2
+
+BUF_SIZE = 0x3FFC0
+INST_SIZE = 0x40
+
+FS_CH_BIT = 34
+FS_CH_MASK = 0x400000000
+FS_ADDR_MASK = 0x3FFFFFFFF
+QEMU_BASE_ADDR = 0x100000000
+
+FS_INST_BASE = 0x3E0000000
+FS_CFGR_BASE = 0x3E1000000
+FS_PSUM_BASE = 0x3E4000000
+
+
+PS_INST_BASE = [0x0, 0x40000]
+PS_PSUM_BASE = [0x80C00, 0xc0C00]
+PS_CFGR_BASE = [0x80400, 0xc0400]
+PS_DONE_BASE = [0x0, 0x40000]
+
+# [ch][addr_space]
+inst_addr_space = [[-1 for i in range(BUF_SIZE)] for j in range(CH_NUM)]
+
+fs_trace_w_p = re.compile("WRITE addr: ([0-9a-z]+), size: ([0-9]+), val: ([0-9a-z\(\)]+)")
+fs_trace_r_p = re.compile("READ addr: ([0-9a-z]+), size: ([0-9]+)")
+
+# set 0xcafe
+is_set = [False for i in range(CH_NUM)]
+
+# for debug
+cnt_write_inst = [0 for i in range(CH_NUM)]
+cnt_read_psum = [0 for i in range(CH_NUM)]
+cnt_write_cfgr = [0 for i in range(CH_NUM)]
+
+# address_mapping = rochrababgco
+ps_ch_bits = 1
+ps_ra_bits = 1
+ps_bg_bits = 2
+ps_ba_bits = 2
+ps_ro_bits = 17
+ps_co_bits = 10
+shift_bits = 3
+
+ps_ch_pos = 18
+ps_ra_pos = 17
+ps_bg_pos = 13
+ps_ba_pos = 15
+ps_ro_pos = 19
+ps_co_pos = 3
+
+inst_list = [[], []]
+trace_list = []
+
+class Address:
+    ch = -1
+    ra = -1
+    bg = -1
+    ba = -1
+    ro = -1
+    co = -1
+
+def trace_conv(fs_addr, fs_size, fs_val, ch, is_write):
+    global is_set
+    global CLK
+    global trace_list
+
+    if (is_write):
+        if fs_addr >= FS_INST_BASE  and fs_addr < FS_INST_BASE + BUF_SIZE:
+            conv_inst(ch, fs_addr, fs_size, fs_val)
+            if is_set[ch] == True:
+                trace_list.append(hex(PS_CFGR_BASE[ch]) + " MFENCE " + str(CLK))
+                CLK += CLK_INTERVAL
+            is_set[ch] = False
+        elif fs_addr == FS_CFGR_BASE + 0x40:
+            conv_cfgr(ch, fs_addr)
+        """
+        else:
+            sys.stdout.write("[debug] Don't care\n")
+        """
+    elif (is_set[ch]):
+        if fs_addr >= FS_PSUM_BASE and fs_addr < FS_PSUM_BASE + BUF_SIZE:
+            conv_psum(ch, fs_addr)
+        """
+        else:
+            sys.stdout.write("[debug] Don't care\n")
+        """
+
+def parse_qemu_trace(match, is_write):
+    fs_addr = int(match.group(1), 0) - QEMU_BASE_ADDR
+    fs_size = int(match.group(2))
+
+    ch = (fs_addr & FS_CH_MASK) >> FS_CH_BIT
+    fs_addr = fs_addr & FS_ADDR_MASK
+
+    fs_val = 0
+    if (is_write):
+        fs_val = match.group(3)
+        if fs_val == "(nil)":
+            fs_val = 0
+        else:
+            fs_val = int(fs_val, 0)
+
+    return fs_addr, fs_size, fs_val, ch
+
+def conv_inst(ch, fs_addr, fs_size, fs_val):
+    global CLK
+    global cnt_write_inst
+    global inst_list
+    addr = fs_addr - FS_INST_BASE
+    inst_id = int(addr / INST_SIZE)
+    inst_str = ""
+
+    for i in range(fs_size):
+        inst_addr_space[ch][addr + i] = get_byte(fs_val, i)
+
+    # check 64 bytes instructions
+    if (not is_inst_full(ch, inst_id)):
+        return
+
+    ps_addr = get_inst_addr(ch, inst_id)
+    inst_str += str(hex(ps_addr)) + " WRITE " + str(CLK)
+    cnt_write_inst[ch] += 1
+
+    for data_idx in range(8):
+        ps_data = get_inst_data(ch, inst_id, data_idx)
+        inst_str += " " + str(hex(ps_data))
+    CLK += CLK_INTERVAL
+
+    inst_list[ch].append(inst_str)
+
+    for i in range(inst_id * 64, inst_id * 64 + INST_SIZE):
+        inst_addr_space[ch][i] = -1
+
+def get_byte(val, i):
+    return (val & (0xff << (i * 8))) >> (i * 8)
+
+def is_inst_full(ch, inst_id):
+    inst_full = True
+
+    for i in range(inst_id * 64, (inst_id * 64) + 64):
+        if inst_addr_space[ch][i] == -1:
+            inst_full = False
+            break
+
+    return inst_full
+
+def get_inst_addr(ch, inst_id):
+    tmp_addr = inst_id * 8 * 8
+    tmp_addr_lower = tmp_addr & 0b11111111111111111
+    tmp_addr_upper = tmp_addr - tmp_addr_lower
+    ps_addr = (tmp_addr_upper << ps_ch_bits) + tmp_addr_lower + PS_INST_BASE[ch]
+
+    return ps_addr
+
+def get_inst_data(ch, inst_id, data_idx):
+    fs_data = 0
+    for j in range(8):
+        fs_data += inst_addr_space[ch][inst_id * INST_SIZE + data_idx * 8 + j] << j*8
+
+    fs_data_addr = get_fs_data_addr(fs_data)
+    fs_data_etc = fs_data - fs_data_addr
+    ps_data_addr = conv_data_addr(fs_data_addr)
+    ps_data = fs_data_etc + ps_data_addr
+
+    return ps_data
+
+def get_fs_data_addr(fs_data):
+    return fs_data & 0x7ffffffff
+
+def conv_data_addr(fs_data_addr):
+    addr = Address()
+
+    addr.ch = 0
+
+    addr.ra = (fs_data_addr >> 34) & 0x1
+
+    addr.bg = ((fs_data_addr >> 17) & 0x1) << 1
+    addr.bg += (fs_data_addr >> 6) & 0x1
+
+    addr.ba = (fs_data_addr >> 18) & 0x3
+    
+    addr.ro = ((fs_data_addr >> 29) & 0x1f) << 12
+    addr.ro += ((fs_data_addr >> 21) & 0x7f) << 5
+    addr.ro += ((fs_data_addr >> 28) & 0x1) << 4
+    addr.ro += ((fs_data_addr >> 20) & 0x1) << 3
+    addr.ro += ((fs_data_addr >> 14) & 0x1)
+
+    addr.co = (fs_data_addr >> 3) & 0x3ff
+
+    ps_data_addr = addr.ro << ps_ch_pos
+    ps_data_addr = addr.ra << ps_ra_pos
+    ps_data_addr = addr.ba << ps_ba_pos
+    ps_data_addr = addr.bg << ps_bg_pos
+    ps_data_addr = addr.co << ps_co_pos
+
+    return ps_data_addr
+
+def conv_psum(ch, fs_addr):
+    global CLK
+    global cnt_read_psum
+    global trace_list
+
+    if ((fs_addr % 0x40) != 0): return
+
+    if (fs_addr == FS_PSUM_BASE):
+        trace_list.append(hex(PS_DONE_BASE[ch]) + " DONE " + str(CLK))
+        CLK += CLK_INTERVAL
+
+    ps_addr = fs_addr - FS_PSUM_BASE + PS_PSUM_BASE[ch]
+    trace_list.append(hex(ps_addr) + " READ " + str(CLK))
+    cnt_read_psum[ch] += 1
+    CLK += CLK_INTERVAL
+
+def conv_cfgr(ch, fs_addr):
+    global CLK
+    global cnt_write_cfgr
+    global is_set
+    global inst_list
+    global trace_list
+
+    last_addr = -1
+    last_idx = -1
+    for i in range(len(inst_list[ch])):
+        inst_split = inst_list[ch][i].split()
+        inst_addr = int(inst_split[0], 0)
+        if inst_addr > last_addr:
+            last_addr = inst_addr
+            last_idx = i
+
+    last_inst = inst_list[ch][last_idx]
+    last_inst_split = last_inst.rsplit(" ", 1)
+    ended = hex(int(last_inst_split[1], 0) | (1 << 48))
+    inst_list[ch][last_idx] = last_inst_split[0] + " " + ended
+
+    for inst in inst_list[ch]:
+        trace_list.append(inst)
+
+    inst_list[ch].clear()
+
+    trace_list.append(hex(PS_CFGR_BASE[ch]) + " SFENCE " + str(CLK))
+    CLK += CLK_INTERVAL
+    trace_list.append(hex(PS_CFGR_BASE[ch]) + " WRITE " + str(CLK) + " 0xcafe")
+    CLK += CLK_INTERVAL
+    if fs_addr == (FS_CFGR_BASE + 0x40):
+        cnt_write_cfgr[ch] += 1
+        is_set[ch] = True
+
+if __name__ == "__main__":
+    trace_file = open(sys.argv[1], "r")
+
+    trace_line = trace_file.readline()
+
+    while trace_line:
+        is_write = False
+
+        match = re.match(fs_trace_w_p, trace_line)
+        if match:
+            is_write = True
+            fs_addr, fs_size, fs_val, ch = parse_qemu_trace(match, is_write)
+
+        else:
+            match = re.match(fs_trace_r_p, trace_line)
+            if match:
+                fs_addr, fs_size, fs_val, ch = parse_qemu_trace(match, is_write)
+            else:
+                sys.stdout.write("[ERROR] Undefined trace line\n")
+
+        trace_conv(fs_addr, fs_size, fs_val, ch, is_write)
+
+        trace_line = trace_file.readline()
+
+    trace_list.sort(key=lambda x: int(x.split()[2]))
+    for i in range(len(trace_list)):
+        print(trace_list[i])
+
+    # for debug
+    #for i in range(CH_NUM):
+    #    sys.stdout.write("CH%d INST %d PSUM %d CFGR %d\n" %(i, cnt_write_inst[i], cnt_read_psum[i], cnt_write_cfgr[i]))
+
diff --git a/scripts_real_app_mode/vnc_qemu.sh b/scripts_real_app_mode/vnc_qemu.sh
new file mode 100644
index 0000000..066ec50
--- /dev/null
+++ b/scripts_real_app_mode/vnc_qemu.sh
@@ -0,0 +1,5 @@
+#!/bin/bash
+ 
+ID="1"
+ 
+gvncviewer 127.0.0.1:$((1 + ${ID}))
diff --git a/src/common.cc b/src/common.cc
deleted file mode 100644
index 5be3303..0000000
--- a/src/common.cc
+++ /dev/null
@@ -1,94 +0,0 @@
-#include "common.h"
-#include "fmt/format.h"
-#include <sstream>
-#include <unordered_set>
-#include <sys/stat.h>
-
-namespace dramsim3 {
-
-std::ostream& operator<<(std::ostream& os, const Command& cmd) {
-    std::vector<std::string> command_string = {
-        "read",
-        "read_p",
-        "write",
-        "write_p",
-        "activate",
-        "precharge",
-        "refresh_bank",  // verilog model doesn't distinguish bank/rank refresh
-        "refresh",
-        "self_refresh_enter",
-        "self_refresh_exit",
-        "WRONG"};
-    os << fmt::format("{:<20} {:>3} {:>3} {:>3} {:>3} {:>#8x} {:>#8x}",
-                      command_string[static_cast<int>(cmd.cmd_type)],
-                      cmd.Channel(), cmd.Rank(), cmd.Bankgroup(), cmd.Bank(),
-                      cmd.Row(), cmd.Column());
-    return os;
-}
-
-std::ostream& operator<<(std::ostream& os, const Transaction& trans) {
-    const std::string trans_type = trans.is_write ? "WRITE" : "READ";
-    os << fmt::format("{:<30} {:>8}", trans.addr, trans_type);
-    return os;
-}
-
-std::istream& operator>>(std::istream& is, Transaction& trans) {
-    std::unordered_set<std::string> write_types = {"WRITE", "write", "P_MEM_WR",
-                                                   "BOFF"};
-    std::string mem_op;
-    is >> std::hex >> trans.addr >> mem_op >> std::dec >> trans.added_cycle;
-    trans.is_write = write_types.count(mem_op) == 1;
-    return is;
-}
-
-int GetBitInPos(uint64_t bits, int pos) {
-    // given a uint64_t value get the binary value of pos-th bit
-    // from MSB to LSB indexed as 63 - 0
-    return (bits >> pos) & 1;
-}
-
-int LogBase2(int power_of_two) {
-    int i = 0;
-    while (power_of_two > 1) {
-        power_of_two /= 2;
-        i++;
-    }
-    return i;
-}
-
-std::vector<std::string> StringSplit(const std::string& s, char delim) {
-    std::vector<std::string> elems;
-    StringSplit(s, delim, std::back_inserter(elems));
-    return elems;
-}
-
-template <typename Out>
-void StringSplit(const std::string& s, char delim, Out result) {
-    std::stringstream ss;
-    ss.str(s);
-    std::string item;
-    while (std::getline(ss, item, delim)) {
-        if (!item.empty()) {
-            *(result++) = item;
-        }
-    }
-}
-
-void AbruptExit(const std::string& file, int line) {
-    std::cerr << "Exiting Abruptly - " << file << ":" << line << std::endl;
-    std::exit(-1);
-}
-
-bool DirExist(std::string dir) {
-    // courtesy to stackoverflow
-    struct stat info;
-    if (stat(dir.c_str(), &info) != 0) {
-        return false;
-    } else if (info.st_mode & S_IFDIR) {
-        return true;
-    } else {  // exists but is file
-        return false;
-    }
-}
-
-}  // namespace dramsim3
diff --git a/trace_gen/Sconstruct b/trace_gen/Sconstruct
new file mode 100644
index 0000000..021fa7d
--- /dev/null
+++ b/trace_gen/Sconstruct
@@ -0,0 +1,37 @@
+import os
+import socket
+
+num_cpu = int(os.environ.get('NUM_CPU',16))
+SetOption('num_jobs', num_cpu)
+print ("running with -j{}".format(GetOption('num_jobs')))
+
+AddOption('--debug_build', action='store_true', help='debug build', default=False)
+
+cpp_defines = []
+cpp_flags   = '-std=c++11 -Wall'
+ld_flags    = '-std=c++11 -Wall'
+
+if GetOption('debug_build'):
+    cpp_defines.append("DEBUG")
+    cpp_flags += ' -O2 -g'
+    ld_flags  += ' -O2 -g'
+else:
+    cpp_flags += ' -O2 -g'
+    ld_flags  += ' -O2 -g'
+
+
+env = Environment(CXXFLAGS = cpp_flags,     \
+                  LINKFLAGS = ld_flags,     \
+                  CPPDEFINES = cpp_defines)
+env.VariantDir('./bin', './', duplicate=0)
+
+program_name = "trace_gen"
+source  = [Glob('bin' + '/*.cpp')],
+CPPPATH = [Dir('#').abspath, 'include/'],
+LIBPATH = ['.'],
+LIBS    = ['boost_regex', 'boost_program_options']
+
+
+
+env.Program(program_name, source=source,
+            CPPPATH=CPPPATH, LIBPATH=LIBPATH, LIBS=LIBS)
diff --git a/trace_gen/common.h b/trace_gen/common.h
new file mode 100644
index 0000000..84fc4a8
--- /dev/null
+++ b/trace_gen/common.h
@@ -0,0 +1,220 @@
+#ifndef __COMMON_H
+#define __COMMON_H
+
+#include "config.h"
+
+struct Address {
+    Address()
+        : channel(-1),
+          rank(-1),
+          bankgroup(-1),
+          bank(-1),
+          row(-1),
+          column(-1),
+          channel_addr(-1),
+          is_pnm(false),
+          pnm_addr(-1),
+          config_p(NULL) {}
+
+    Address(int channel, int rank, int bankgroup, int bank, int row, int column,
+            const Config *config_p)
+        : channel(channel),
+          rank(rank),
+          bankgroup(bankgroup),
+          bank(bank),
+          row(row),
+          column(column),
+          is_pnm(false),
+          pnm_addr(-1),
+          config_p(config_p)
+    {
+        GetChannelAddress();
+    }
+
+    Address(const Address& addr)
+        : channel(addr.channel),
+          rank(addr.rank),
+          bankgroup(addr.bankgroup),
+          bank(addr.bank),
+          row(addr.row),
+          column(addr.column), 
+          channel_addr(addr.channel_addr),
+          is_pnm(addr.is_pnm),
+          pnm_addr(addr.pnm_addr),
+          config_p(addr.config_p) {}
+
+    Address(int ch, uint64_t channel_addr_, const Config *config_p_)
+    {
+        reset(ch, channel_addr_, config_p_); 
+    }
+
+    Address(int ch, bool is_pnm_, uint64_t pnm_addr_, const Config *config_p_)
+    {
+        channel = ch;
+        rank = -1;
+        bankgroup = -1;
+        bank = -1;
+        row = -1;
+        column = -1;
+        channel_addr = -1;
+        is_pnm = is_pnm_;
+        pnm_addr = pnm_addr_;
+        config_p = config_p_;
+    }
+
+    void reset(int ch, int ra, int bg, int ba, int ro, int col,
+            const Config *config_p_)
+    {
+        channel = ch;
+        rank = ra;
+        bankgroup = bg;
+        bank = ba;
+        row = ro;
+        column = col;
+        is_pnm = false;
+        pnm_addr = -1;
+        config_p = config_p_;
+    }   
+
+    void reset(int ch, uint64_t channel_addr_, const Config *config_p_)
+    {
+        const Config *cp = config_p_;
+        channel = ch;
+        config_p = cp;
+        channel_addr = (channel_addr_) >> cp->shift_bits; 
+
+        if (cp->ra_pos > cp->ch_pos) {
+            rank =
+                (channel_addr_ >> (cp->shift_bits + cp->ra_pos - cp->ch_bits))
+                & cp->ra_mask;
+        } else {
+            rank =
+                (channel_addr_ >> (cp->shift_bits + cp->ra_pos)) & cp->ra_mask;
+        }
+
+        if (cp->bg_pos > cp->ch_pos) {
+            bankgroup =
+                (channel_addr_ >> (cp->shift_bits + cp->bg_pos + cp->ch_bits))
+                & cp->bg_mask;
+        } else {
+            bankgroup =
+                (channel_addr_ >> (cp->shift_bits + cp->bg_pos)) & cp->bg_mask;
+        }
+
+        if (cp->ba_pos > cp->ch_pos) {
+            bank =
+                (channel_addr_ >> (cp->shift_bits + cp->ba_pos + cp->ch_bits))
+                & cp->ba_mask;
+        } else {
+            bank =
+                (channel_addr_ >> (cp->shift_bits + cp->ba_pos)) & cp->ba_mask;
+        }
+
+        if (cp->ro_pos > cp->ch_pos) {
+            row =
+                (channel_addr_ >> (cp->shift_bits + cp->ro_pos + cp->ch_bits))
+                & cp->ro_mask;
+        } else {
+            row =
+                (channel_addr_ >> (cp->shift_bits + cp->ro_pos)) & cp->ro_mask;
+        }
+
+        if (cp->co_pos > cp->ch_pos) {
+            column =
+                (channel_addr_ >> (cp->shift_bits + cp->co_pos + cp->ch_bits))
+                & cp->co_mask;
+        } else {
+            column =
+                (channel_addr_ >> (cp->shift_bits + cp->co_pos)) & cp->co_mask;
+        }
+    }
+
+    uint64_t GetHexAddress()
+    {
+        const Config *cp = config_p;
+        uint64_t addr = 0;
+
+        if (is_pnm == false) {
+            addr += (uint64_t)channel << (cp->shift_bits + cp->ch_pos);
+            addr += (uint64_t)rank << (cp->shift_bits + cp->ra_pos);
+            addr += (uint64_t)bankgroup << (cp->shift_bits + cp->bg_pos);
+            addr += (uint64_t)bank << (cp->shift_bits + cp->ba_pos);
+            addr += (uint64_t)row << (cp->shift_bits + cp->ro_pos);
+            addr += (uint64_t)column << (cp->shift_bits + cp->co_pos);
+        } else {
+            int low_bits = cp->shift_bits + cp->ch_pos + cp->ch_bits;
+            uint64_t low_eraser = ~(((uint64_t)1 << (low_bits)) - 1);
+            addr += (pnm_addr << cp->ch_bits) & low_eraser;
+            addr += (uint64_t)channel << (cp->shift_bits + cp->ch_pos);
+            addr += pnm_addr & (((uint64_t)1 << (cp->shift_bits + cp->ch_pos)) - 1);
+        }
+
+        return addr; 
+    }
+
+    uint64_t GetChannelAddress()
+    {
+        const Config *cp = config_p;
+        uint64_t addr = 0;
+
+        if (cp->ra_pos > cp->ch_pos) {
+            addr +=
+                (uint64_t)rank << (cp->shift_bits + cp->ra_pos - cp->ch_bits);
+        } else {
+            addr += (uint64_t)rank << (cp->shift_bits + cp->ra_pos);
+        }
+
+        if (cp->bg_pos > cp->ch_pos) {
+            addr +=
+                (uint64_t)bankgroup
+                << (cp->shift_bits + cp->bg_pos - cp->ch_bits);
+        } else {
+            addr += (uint64_t)bankgroup << (cp->shift_bits + cp->bg_pos);
+        }
+
+        if (cp->ba_pos > cp->ch_pos) {
+            addr +=
+                (uint64_t)bank << (cp->shift_bits + cp->ba_pos - cp->ch_bits);
+        } else {
+            addr += (uint64_t)bank << (cp->shift_bits + cp->ba_pos);
+        }
+
+        if (cp->ro_pos > cp->ch_pos) {
+            addr +=
+                (uint64_t)row << (cp->shift_bits + cp->ro_pos - cp->ch_bits);
+        } else {
+            addr += (uint64_t)row << (cp->shift_bits + cp->ro_pos);
+        }
+
+        if (cp->co_pos > cp->ch_pos) {
+            addr +=
+                (uint64_t)column << (cp->shift_bits + cp->co_pos - cp->ch_bits);
+        } else {
+            addr += (uint64_t)column << (cp->shift_bits + cp->co_pos);
+        }
+
+        channel_addr = addr >> cp->shift_bits;
+
+        return addr;
+    }
+
+    uint64_t GetPNMAddress()
+    {
+        return pnm_addr;
+    }
+
+    int channel;
+    int rank;
+    int bankgroup;
+    int bank;
+    int row;
+    int column;
+
+    uint64_t channel_addr; 
+    bool is_pnm;
+    uint64_t pnm_addr;
+
+    const Config *config_p;
+};
+
+#endif
diff --git a/trace_gen/config.cpp b/trace_gen/config.cpp
new file mode 100644
index 0000000..5c43fa6
--- /dev/null
+++ b/trace_gen/config.cpp
@@ -0,0 +1,231 @@
+#include "config.h"
+
+namespace po = boost::program_options;
+
+Config::Config(int argc, const char* argv[])
+{
+    po::options_description desc{"Options"};
+    desc.add_options()
+        ("help, h", "Help")
+        ("opcode",                 po::value<unsigned>(&opcode)->default_value(0),                     "opcode")
+        ("nepochs",                po::value<int>(&nepochs)->default_value(2),                         "nepochs")
+        ("batch_size",             po::value<unsigned>(&batch_size)->default_value(64),                "batch_size")
+        ("embedding_table, t",     po::value<string>(&table_list)->default_value("1000000-1000000"),   "embedding table list")
+        ("num_tables",             po::value<int>(&num_tables)->default_value(0),                      "num_tables")
+        ("sparse_feature_size",    po::value<int>(&sparse_feature_size)->default_value(16),            "sparse_feature_size")
+        ("data_type_size",         po::value<int>(&data_type_size)->default_value(4),                  "data_type_size")
+        ("max_indices_per_lookup", po::value<int>(&max_indices_per_lookup)->default_value(50),         "max_indices_per_lookup")
+        ("pooling_type",           po::value<int>(&pooling_type)->default_value(0),                    "pooling_type")
+        ("pooling_prod_list",      po::value<string>(&pooling_prod_list)->default_value("48-122-25-50-30-70-25-25-25-40"), "num_indices_per_lookup_prod")
+        ("default_interval",       po::value<int>(&default_interval)->default_value(4),                "default_interval")
+        ("miss_ratio",             po::value<int>(&miss_ratio)->default_value(100),                    "miss_ratio")
+        ("base_only",              po::value<bool>(&base_only)->default_value(false),                  "base_only")
+        ("channel",                po::value<string>(&channel_list)->default_value("1"),               "channel")
+        ("rank",                   po::value<string>(&rank_list)->default_value("0-1"),                "rank")
+        ("bg_size",                po::value<int>(&bg_size)->default_value(4),                         "bg_size")
+        ("ba_size",                po::value<int>(&ba_size)->default_value(4),                         "ba_size")
+        ("ro_size",                po::value<int>(&ro_size)->default_value(65536),                     "ro_size")
+        ("co_size",                po::value<int>(&co_size)->default_value(1024),                      "co_size")
+        ("bus_width",              po::value<int>(&bus_width)->default_value(64),                      "bus_width")
+        ("BL",                     po::value<int>(&BL)->default_value(8),                              "BL")
+        ("address_mapping",        po::value<string>(&address_mapping)->default_value("rochrababgco"), "address_mapping")
+        ("file_name, f",           po::value<string>(&file_name)->default_value("test"),               "Output trace file name")
+        ;
+
+    po::variables_map vm;
+    po::store(po::parse_command_line(argc, argv, desc), vm);
+    if (vm.count("help")) {
+        cout << desc << endl;
+        assert(false);
+    }
+    po::notify(vm);
+
+    data_size = sparse_feature_size * data_type_size;
+
+    channel = split(channel_list, '-');
+    rank = split(rank_list, '-');
+    ch_size = channel.size();
+    ra_size = rank.size();
+
+    base_out.open(file_name + "_base.trc");
+    if (!base_only)
+        cxlpnm_out.open(file_name + "_cxlpnm.trc");
+
+    if (opcode == 0) {
+        tables = split(table_list, '-');
+        if(num_tables != 0) {
+            tables.resize(num_tables, tables[0]);
+        }
+
+        accum_table_size.resize(tables.size() + 1);
+        accum_table_size[0] = 0;
+        for(unsigned i = 1; i < accum_table_size.size(); i++) {
+            accum_table_size[i] = accum_table_size[i-1] + tables[i-1];
+        }
+
+        pooling_prod = split(pooling_prod_list, '-');
+
+        num_indices_per_lookup.resize(tables.size()); // [table]
+        indices.resize(nepochs); // [nepochs] [table] [batch] [lookup]
+
+        total_lookup = 0;
+        int p = 0;
+        for (int c = 0; c < nepochs; c++) {
+            indices[c].resize(tables.size());
+            for (unsigned i = 0; i < tables.size(); i++) {
+                if (c == 0) {
+                    switch (static_cast<PoolType>(pooling_type)) {
+                        case PoolType::FIXED:
+                            num_indices_per_lookup[i] = max_indices_per_lookup;
+                            break;
+                        case PoolType::RANDOM:
+                            num_indices_per_lookup[i] =
+                                rand() % max_indices_per_lookup + 1;
+                            break;
+                        case PoolType::PROD:
+                            num_indices_per_lookup[i] = pooling_prod[p];
+                            p = (p + 1) % pooling_prod.size();
+                            break;
+                        default:
+                            break;
+                    }
+
+                    assert(num_indices_per_lookup[i] <= tables[i]);
+
+                    total_lookup += num_indices_per_lookup[i];
+                }
+
+                indices[c][i].resize(batch_size);
+                for (unsigned j = 0; j < batch_size; j++) {
+                    set<unsigned> unique_idx;
+                    while (unique_idx.size() < num_indices_per_lookup[i]) {
+                        //unsigned idx_tt = unique_idx.size();
+                        unsigned idx_tt = rand() % tables[i];
+                        if (unique_idx.find(idx_tt) == unique_idx.end()) {
+                            indices[c][i][j].push_back(idx_tt);
+                            unique_idx.insert(idx_tt);
+                        }
+                    }
+                }
+            }
+        }
+        // batch list
+        // # of instruction / batch = total_lookup
+        // Inst size = # of instruction x 8B
+        // 256 KB / Inst size = batch_s
+        int batch_s = INST_BUFFER_BYTE_SIZE / (total_lookup * 8);
+        int tmp_batch_size = batch_size;
+        while (tmp_batch_size > 0) {
+            batch_list.push_back(min(batch_s, tmp_batch_size));
+            tmp_batch_size -= batch_s;
+        }
+    }
+    else{
+        assert(false);
+    }
+
+    SetAddressMapping();
+
+    uint64_t total_data_size = accum_table_size[tables.size()] * data_size;
+    uint64_t memory_size = (uint32_t)1 << (addr_bits - shift_bits - ch_bits);
+    if (total_data_size >= memory_size) {
+        cerr << "Error: table size exceeds memory size!" << endl;
+        exit(1);
+    }
+}
+
+Config::~Config()
+{
+    base_out.close();
+    cxlpnm_out.close();
+}
+
+vector<unsigned> Config::split(string str, char delimiter)
+{
+    vector<unsigned> internal;
+    stringstream ss(str);
+    string temp;
+
+    while (getline(ss, temp, delimiter)) {
+        internal.push_back(stoi(temp));
+    }
+    return internal;
+}
+
+void Config::SetAddressMapping()
+{
+    // memory addresses are byte addressable, but each request comes with
+    // multiple bytes because of bus width, and burst length
+    int request_size_bytes = bus_width / 8 * BL;
+    shift_bits = LogBase2(request_size_bytes);
+    int col_low_bits = LogBase2(BL);
+    int actual_col_bits = LogBase2(co_size) - col_low_bits;
+
+    ch_bits = LogBase2(ch_size);
+    ra_bits = LogBase2(ra_size);
+    bg_bits = LogBase2(bg_size);
+    ba_bits = LogBase2(ba_size);
+    ro_bits = LogBase2(ro_size);
+    co_bits = actual_col_bits;
+
+    // has to strictly follow the order of chan, rank, bg, bank, row, col
+    std::map<std::string, int> field_widths;
+    field_widths["ch"] = LogBase2(ch_size);
+    field_widths["ra"] = LogBase2(ra_size);
+    field_widths["bg"] = LogBase2(bg_size);
+    field_widths["ba"] = LogBase2(ba_size);
+    field_widths["ro"] = LogBase2(ro_size);
+    field_widths["co"] = actual_col_bits;
+
+    if (address_mapping.size() != 12) {
+        std::cerr << "Unknown address mapping (6 fields each 2 chars required)"
+                  << std::endl;
+    }
+
+    // // get address mapping position fields from config
+    // // each field must be 2 chars
+    std::vector<std::string> fields;
+    for (size_t i = 0; i < address_mapping.size(); i += 2) {
+        std::string token = address_mapping.substr(i, 2);
+        fields.push_back(token);
+    }
+
+    std::map<std::string, int> field_pos;
+    int pos = 0;
+    while (!fields.empty()) {
+        auto token = fields.back();
+        fields.pop_back();
+        if (field_widths.find(token) == field_widths.end()) {
+            std::cerr << "Unrecognized field: " << token << std::endl;
+        }
+        field_pos[token] = pos;
+        pos += field_widths[token];
+    }
+
+    ch_pos = field_pos.at("ch");
+    ra_pos = field_pos.at("ra");
+    bg_pos = field_pos.at("bg");
+    ba_pos = field_pos.at("ba");
+    ro_pos = field_pos.at("ro");
+    co_pos = field_pos.at("co");
+
+    ch_mask = (1 << field_widths.at("ch")) - 1;
+    ra_mask = (1 << field_widths.at("ra")) - 1;
+    bg_mask = (1 << field_widths.at("bg")) - 1;
+    ba_mask = (1 << field_widths.at("ba")) - 1;
+    ro_mask = (1 << field_widths.at("ro")) - 1;
+    co_mask = (1 << field_widths.at("co")) - 1;
+
+    addr_bits = 
+        ch_bits + ra_bits + bg_bits + ba_bits + ro_bits + co_bits + shift_bits;
+}
+
+int LogBase2(int power_of_two)
+{
+    int i = 0;
+    while (power_of_two > 1) {
+        power_of_two /= 2;
+        i++;
+    }
+    return i;
+}
diff --git a/trace_gen/config.h b/trace_gen/config.h
new file mode 100644
index 0000000..f6d9e93
--- /dev/null
+++ b/trace_gen/config.h
@@ -0,0 +1,85 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <iostream>
+#include <string>
+#include <sstream>
+#include <fstream>
+#include <boost/program_options.hpp>
+
+#define INST_BUFFER_BYTE_SIZE (256 * 1024)
+#define PNM_INST_BUF_START 0
+#define PNM_INST_BUF_END (PNM_INST_BUF_START + INST_BUFFER_BYTE_SIZE - 1)
+
+#define CONFIG_REG_SIZE 1024
+#define PNM_CONFIG_REG_START (PNM_INST_BUF_END + 1 + 1024)
+#define PNM_CONFIG_REG_END (PNM_CONFIG_REG_START + CONFIG_REG_SIZE - 1)
+#define PNM_EXE_REG_OFFSET 0
+#define PNM_STATUS_REG_OFFSET 64
+
+#define PSUM_BUFFER_BYTE_SIZE (256 * 1024)
+#define PNM_PSUM_BUF_START (PNM_CONFIG_REG_END + 1 + 1024)
+#define PNM_PSUM_BUF_END (PNM_PSUM_BUF_START + PSUM_BUFFER_BYTE_SIZE - 1)
+
+using namespace std;
+
+class Config {
+    enum class PoolType {
+        FIXED, 
+        RANDOM, 
+        PROD, 
+        SIZE
+    }; 
+
+ public:
+    Config(int argc, const char* argv[]);     
+    ~Config();
+    
+    vector<unsigned> split(string str, char delimiter); 
+
+    void SetAddressMapping();
+    
+    unsigned opcode;  
+    int nepochs;
+    unsigned batch_size;
+    vector<unsigned> batch_list; 
+    string table_list;
+    int num_tables; 
+    vector<unsigned> tables;
+    vector<unsigned> accum_table_size;
+    int sparse_feature_size; 
+    int data_type_size; 
+    int data_size; 
+
+    int max_indices_per_lookup; 
+    int pooling_type;
+    string pooling_prod_list;
+    vector<unsigned> pooling_prod;  
+    vector<unsigned> num_indices_per_lookup; // [table]
+    int total_lookup; // per batch
+
+    // [nepochs] [table] [lookup]  
+    vector<vector<vector<vector<unsigned>>>> indices; 
+
+    int default_interval;
+    int miss_ratio;
+    bool base_only; 
+
+    string channel_list, rank_list;  
+    vector<unsigned> channel, rank;
+    int ch_size, ra_size, bg_size, ba_size, ro_size, co_size;
+    int ch_bits, ra_bits, bg_bits, ba_bits, ro_bits, co_bits;
+    int ch_pos, ra_pos, bg_pos, ba_pos, ro_pos, co_pos;
+    uint64_t ch_mask, ra_mask, bg_mask, ba_mask, ro_mask, co_mask;
+    int addr_bits;
+    int shift_bits;
+    int bus_width, BL;
+    string address_mapping;
+
+    string file_name; 
+    ofstream base_out, cxlpnm_out;  
+}; 
+
+int LogBase2(int power_of_two);
+
+#endif
diff --git a/trace_gen/instruction.cpp b/trace_gen/instruction.cpp
new file mode 100644
index 0000000..d09b280
--- /dev/null
+++ b/trace_gen/instruction.cpp
@@ -0,0 +1,133 @@
+#include <stdlib.h>
+#include "instruction.h"
+
+Instruction::Instruction(const Config *config_p_)
+{
+    config_p = config_p_;
+
+    std::vector<int> bit_width_tmp; 
+    std::vector<int> start_tmp;
+
+    int ch_addr_bits = 
+        config_p->addr_bits - config_p->shift_bits - config_p->ch_bits;
+
+    ////////////////// opcode = 0 /////////////////////
+    int bit_width_0[5] = {2, 1, 12, 1, ch_addr_bits}; 
+    int start_0[5]    = {62, 61, 49, 48, 0};
+
+    field_size.push_back(sizeof(bit_width_0) / sizeof(int));
+  
+    for(int i = 0; i < field_size[0]; i++) {
+        bit_width_tmp.push_back(bit_width_0[i]); 
+        start_tmp.push_back(start_0[i]); 
+    }
+
+    bit_width.push_back(bit_width_tmp); 
+    start.push_back(start_tmp); 
+
+    bit_width_tmp.clear(); 
+    start_tmp.clear();
+
+    num_instruction = 0;
+    interval = config_p->default_interval;  
+}
+
+Instruction::Instruction(uint64_t addr_offset, uint64_t exec_addr_,
+        const Config *config_p_)
+ : Instruction(config_p_)
+{
+
+    start_pnm_addr = addr_offset; 
+    exec_addr = exec_addr_;
+    num_instruction = 0; 
+}
+
+
+Instruction::~Instruction()
+{
+    bit_width.clear(); 
+    start.clear();
+} 
+
+void Instruction::init(
+        uint64_t addr_offset,
+        uint64_t exec_addr_,
+        int total_instruction_)
+{
+    start_pnm_addr = addr_offset;
+    exec_addr = exec_addr_;    
+    total_instruction = total_instruction_;
+    num_instruction = 0; 
+}
+
+uint64_t Instruction::index_to_address(int idx, int channel_id)
+{ 
+    assert(idx < NUM_INST_BUFFER); // = 256KB
+ 
+    uint64_t pnm_addr = start_pnm_addr + idx * 8;
+
+    return Address(channel_id, true, pnm_addr, config_p).GetHexAddress();
+}
+
+void Instruction::write_instruction(
+        unsigned opcode,
+        bool local_bit,
+        unsigned output_idx,
+        Address *ad,
+        std::ofstream &trc,
+        int &time)
+{
+    assert(opcode == 0);
+
+    bool trace_end = num_instruction == (total_instruction - 1) ? true : false;
+ 
+    uint32_t inst_vec[5] = {
+        opcode,
+        (uint32_t)local_bit,
+        output_idx,
+        (uint32_t)trace_end,
+        (uint32_t)ad->channel_addr};
+
+    uint64_t inst_tmp = 0;
+    for (int i = 0; i < field_size[opcode]; i++) {
+        assert(inst_vec[i] < ((uint32_t)1 << bit_width[opcode][i]));  
+
+        inst_tmp += ((uint64_t) inst_vec[i] << start[opcode][i]);
+    }
+
+    if ((num_instruction % 8) == 0) {
+        if(num_instruction != 0)
+            trc << std::endl; 
+
+        trc
+            << "0x"
+            << std::hex << index_to_address(num_instruction, ad->channel)
+            << " WRITE "
+            << std::dec << time ; 
+
+        time += interval;
+    }
+
+    trc << " 0x" << std::hex << inst_tmp; 
+
+    num_instruction++; 
+
+    if (trace_end) {
+        trc << std::endl;
+
+        trc
+            << "0x"
+            << std::hex << exec_addr
+            << " SFENCE "
+            << std::dec << time << std::endl;
+
+        time += interval; 
+        trc
+            << "0x"
+            << std::hex << exec_addr
+            << " WRITE "
+            << std::dec << time << " 0xcafe" << std::endl;
+
+        time += interval;  
+    }
+}
diff --git a/trace_gen/instruction.h b/trace_gen/instruction.h
new file mode 100644
index 0000000..3549929
--- /dev/null
+++ b/trace_gen/instruction.h
@@ -0,0 +1,47 @@
+#ifndef __INSTRUCTION_H
+#define __INSTRUCTION_H
+
+#include <iostream>
+#include <cassert>
+#include <vector>
+#include <fstream>
+
+#include "common.h"
+#include "config.h"
+
+#define NUM_INST_BUFFER 256*1024/8 // 64bit instruction 
+
+class Instruction {
+  public:   
+    Instruction(const Config *config_p_);
+    Instruction(uint64_t start_addr, uint64_t exec_addr,
+            const Config *config_p_);
+
+    ~Instruction();  
+       
+    void init(uint64_t addr_offset, uint64_t exec_addr_, int total_instruction); 
+    void write_instruction(
+            unsigned opcode,
+            bool local_bit,
+            unsigned output_idx,
+            Address *ad,
+            std::ofstream &trc,
+            int &time); 
+
+  private:
+    std::vector<int> field_size; 
+    std::vector<std::vector<int> > bit_width;  
+    std::vector<std::vector<int> > start;
+
+    uint64_t index_to_address(int idx, int channel_id); 
+   
+    uint64_t start_pnm_addr;  
+    uint64_t exec_addr; 
+    int num_instruction;
+    int total_instruction; 
+    int interval;  
+    
+    const Config *config_p;
+}; 
+
+# endif
diff --git a/trace_gen/main.cpp b/trace_gen/main.cpp
new file mode 100644
index 0000000..8ede8fa
--- /dev/null
+++ b/trace_gen/main.cpp
@@ -0,0 +1,160 @@
+#include <iostream>
+
+#include "config.h"
+#include "common.h"
+#include "instruction.h"
+
+using namespace std;
+
+void read_psum(int channel, int num_read, Config *config, int &time)
+{
+    // Check done
+    config->cxlpnm_out <<
+        "0x"
+        << hex << Address(channel, 0, 0, 0, 0, 0, config).GetHexAddress()
+        << " DONE "
+        << dec << time << endl;
+
+    time += config->default_interval;
+
+    uint64_t psum_addr = Address(
+            channel,
+            true,
+            PNM_PSUM_BUF_START,
+            config).GetPNMAddress();
+
+    for(int i = 0; i < num_read; i++) {
+        config->cxlpnm_out
+            << "0x"
+            << hex << Address(channel, true , psum_addr, config).GetHexAddress()
+            << " READ "
+            << dec << time << endl;
+
+        time += config->default_interval;
+        psum_addr += config->data_size;
+    }
+
+    config->cxlpnm_out
+        << "0x"
+        << hex
+        << Address(
+                channel,
+                true,
+                PNM_CONFIG_REG_START + PNM_EXE_REG_OFFSET,
+                config).GetHexAddress()
+        << " MFENCE "
+        << dec << time << endl;
+
+    time += config->default_interval;
+}
+
+void write_base(Config *config, uint64_t addr, int &time)
+{
+    if ((rand() % 100) < config->miss_ratio) {
+        config->base_out
+            << "0x"
+            << hex << addr
+            << " READ "
+            << dec << time << endl;
+
+        time += config->default_interval;
+    }
+    else {
+        time += 1;
+    }
+}
+
+int main(int argc, const char* argv[])
+{
+    cout << " --- DRAMsim3 Trace Generator --- " << endl;
+
+    Config *config = new Config(argc, argv);
+    Address *addr = new Address();
+    Instruction *inst = new Instruction(config);
+
+    int num_trial = 0;
+    int ax_time = 0, b_time = 0;
+    if (config->opcode == 0) { // SLS
+        while (num_trial < config->nepochs) {
+            int p_idx = 0;
+            int acum_b = 0;
+            for (auto batch_s : config->batch_list) {
+                p_idx = 0;
+                for (auto ch: config->channel) {
+                    if ((num_trial + p_idx) >= config->nepochs)
+                        continue;
+
+                    inst->init(
+                            Address(
+                                ch,
+                                true,
+                                PNM_INST_BUF_START,
+                                config).GetPNMAddress(),
+                            Address(
+                                ch,
+                                true,
+                                PNM_CONFIG_REG_START
+                                + PNM_EXE_REG_OFFSET,
+                                config).GetHexAddress(),
+                            batch_s * config->total_lookup);
+
+                    int output_idx = 0;
+                    for (unsigned b_id = 0; b_id < batch_s; b_id++) {
+                        for (unsigned t_id = 0;
+                                t_id < config->tables.size();
+                                t_id++) {
+                            for (unsigned ll = 0;
+                                    ll < config->num_indices_per_lookup[t_id];
+                                    ll++) {
+                                addr->reset(
+                                        ch,
+                                        (t_id * config->accum_table_size[t_id]
+                                         + config->indices[num_trial
+                                         + p_idx][t_id][acum_b + b_id][ll])
+                                        * config->data_size,
+                                        config);
+                                write_base(
+                                        config,
+                                        addr->GetHexAddress(),
+                                        b_time);
+
+                                inst->write_instruction(
+                                        config->opcode,
+                                        false,
+                                        output_idx,
+                                        addr,
+                                        config->cxlpnm_out,
+                                        ax_time);
+                            }
+                            output_idx++;
+                        }
+                    }
+                    p_idx++;
+                }
+
+                p_idx = 0;
+                for (auto ch: config->channel) {
+                    if ((num_trial + p_idx) >= config->nepochs)
+                        continue;
+
+                    read_psum(
+                            ch,
+                            batch_s * config->tables.size(),
+                            config, ax_time);
+
+                    p_idx++;
+                }
+
+                acum_b += batch_s;
+            }
+            num_trial += p_idx;
+        }
+    }
+    else{
+        assert(false);
+    }
+
+    cout << " --- End ---" << endl;
+
+    return 0;
+}
-- 
2.34.1

